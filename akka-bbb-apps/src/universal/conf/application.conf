pekko {
  actor {
    debug {
      # enable DEBUG logging of all AutoReceiveMessages (Kill, PoisonPill et.c.)
      autoreceive = on
      # enable DEBUG logging of actor lifecycle changes
      lifecycle = on
    }
  }
  loggers = ["org.apache.pekko.event.slf4j.Slf4jLogger"]
  loglevel = "DEBUG"
  
  redis-publish-worker-dispatcher {
      mailbox-type = "org.apache.pekko.dispatch.SingleConsumerOnlyUnboundedMailbox"
      # Throughput defines the maximum number of messages to be
      # processed per actor before the thread jumps to the next actor.
      # Set to 1 for as fair as possible.
      throughput = 512
    }
    
  redis-subscriber-worker-dispatcher {
      mailbox-type = "org.apache.pekko.dispatch.SingleConsumerOnlyUnboundedMailbox"
      # Throughput defines the maximum number of messages to be
      # processed per actor before the thread jumps to the next actor.
      # Set to 1 for as fair as possible.
      throughput = 512
    }

  http {
    server {
        preview {
            enable-http2 = "on"
        }
    }
  }
}

client {
    clientSettingsFilePath = "/usr/share/meteor/bundle/programs/server/assets/app/config/settings.yml"
    clientSettingsOverrideFilePath = "/etc/bigbluebutton/bbb-html5.yml"
}

redis {
    host="127.0.0.1"
    port=6379
    password=""
    # recording keys should expire in 14 days
    keyExpiry=1209600
}

postgres {
    dataSourceClass = "org.postgresql.ds.PGSimpleDataSource"
        properties = {
            serverName = "localhost"
            portNumber = "5432"
            databaseName = "bbb_graphql"
            user = "postgres"
            password = "bbb_graphql"
        }
        numThreads = 1
        maxConnections = 1
}



expire {
  # time in seconds
  lastUserLeft = 60
  neverJoined = 300
}

services {
  bbbWebAPI = "https://192.168.23.33/bigbluebutton/api"
  sharedSecret = "changeme"
}

eventBus {
  meetingManagerChannel = "MeetingManagerChannel"
  outMessageChannel = "OutgoingMessageChannel"
  incomingJsonMsgChannel = "IncomingJsonMsgChannel"
  outBbbMsgMsgChannel = "OutBbbMsgChannel"
}

http {
  interface = "127.0.0.1"
  interface = ${?INTERFACE}
  port = 8901
  port = ${?PORT}
}

grpc {
  interface = "127.0.0.1"
  port = 8081
}

services {
  telizeHost = "www.telize.com"
  telizePort = 80
}

apps {
  checkPermissions = true
  ejectOnViolation = false
  endMeetingWhenNoMoreAuthedUsers = false
  endMeetingWhenNoMoreAuthedUsersAfterMinutes = 2
  reduceDuplicatedPick = false
}

analytics {
  includeChat = true
}

voiceConf {
  recordPath = "/var/freeswitch/meetings"
  # Use ogg instead of wav to get smaller audio files.
  # Valid values "wav", "ogg", "flac", "opus"
  recordCodec = "opus"
  # Interval seconds to check if FreeSWITCH is recording.
  checkRecordingInterval = 23
  # Internval seconds to sync voice users status.
  syncUserStatusInterval = 41
  # Voice users with no matching user record
  ejectRogueVoiceUsers = true

  # Path to the audio file being played when dial-in user is waiting for
  # approval. This can be relative to FreeSWITCH sounds folder
  dialInApprovalAudioPath = "ivr/ivr-please_hold_while_party_contacted.wav"

  # Time (seconds) to wait before requesting an audio channel hold after
  # muting a user. Used in the experimental, transparent listen only mode.
  toggleListenOnlyAfterMuteTimer = 4
}

recording {
  # set zero to disable chapter break
  chapterBreakLengthInMinutes = 0
}

transcript {
  words = 8 # per line
  lines = 2
}
