import { Tools } from "@babylonjs/core/Misc/tools";
import { ProceduralTexture } from "@babylonjs/core/Materials/Textures/Procedurals/proceduralTexture";
import { _Exporter } from "../glTFExporter";
var NAME = "KHR_texture_transform";
import "../shaders/textureTransform.fragment";
/**
 * @hidden
 */
var KHR_texture_transform = /** @class */ (function () {
    function KHR_texture_transform(exporter) {
        this._recordedTextures = [];
        /** Name of this extension */
        this.name = NAME;
        /** Defines whether this extension is enabled */
        this.enabled = true;
        /** Defines whether this extension is required */
        this.required = false;
        /** Reference to the glTF exporter */
        this._wasUsed = false;
    }
    KHR_texture_transform.prototype.dispose = function () {
        for (var _i = 0, _a = this._recordedTextures; _i < _a.length; _i++) {
            var texture = _a[_i];
            texture.dispose();
        }
    };
    Object.defineProperty(KHR_texture_transform.prototype, "wasUsed", {
        /** @hidden */
        get: function () {
            return this._wasUsed;
        },
        enumerable: true,
        configurable: true
    });
    KHR_texture_transform.prototype.postExportTexture = function (context, textureInfo, babylonTexture) {
        if (babylonTexture && babylonTexture.uRotationCenter === 0 && babylonTexture.vRotationCenter === 0) {
            var textureTransform = {};
            var transformIsRequired = false;
            if (babylonTexture.uOffset !== 0 || babylonTexture.vOffset !== 0) {
                textureTransform.offset = [babylonTexture.uOffset, babylonTexture.vOffset];
                transformIsRequired = true;
            }
            if (babylonTexture.uScale !== 1 || babylonTexture.vScale !== 1) {
                textureTransform.scale = [babylonTexture.uScale, babylonTexture.vScale];
                transformIsRequired = true;
            }
            if (babylonTexture.wAng !== 0) {
                textureTransform.rotation = babylonTexture.wAng;
                transformIsRequired = true;
            }
            if (babylonTexture.coordinatesIndex !== 0) {
                textureTransform.texCoord = babylonTexture.coordinatesIndex;
                transformIsRequired = true;
            }
            if (!transformIsRequired) {
                return;
            }
            this._wasUsed = true;
            if (!textureInfo.extensions) {
                textureInfo.extensions = {};
            }
            textureInfo.extensions[NAME] = textureTransform;
        }
    };
    KHR_texture_transform.prototype.preExportTextureAsync = function (context, babylonTexture, mimeType) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var scene = babylonTexture.getScene();
            if (!scene) {
                reject(context + ": \"scene\" is not defined for Babylon texture " + babylonTexture.name + "!");
                return;
            }
            var transformIsRequired = false;
            if (babylonTexture.uOffset !== 0 || babylonTexture.vOffset !== 0) {
                transformIsRequired = true;
            }
            if (babylonTexture.uScale !== 1 || babylonTexture.vScale !== 1) {
                transformIsRequired = true;
            }
            if (babylonTexture.wAng !== 0) {
                transformIsRequired = true;
            }
            if (!transformIsRequired) {
                resolve(babylonTexture);
                return;
            }
            // Do we need to flatten the transform?
            if (babylonTexture.uRotationCenter === 0 && babylonTexture.vRotationCenter === 0) {
                resolve(babylonTexture);
                return;
            }
            return _this._textureTransformTextureAsync(babylonTexture, scene)
                .then(function (proceduralTexture) {
                resolve(proceduralTexture);
            })
                .catch(function (e) {
                reject(e);
            });
        });
    };
    /**
     * Transform the babylon texture by the offset, rotation and scale parameters using a procedural texture
     * @param babylonTexture
     * @param offset
     * @param rotation
     * @param scale
     * @param scene
     */
    KHR_texture_transform.prototype._textureTransformTextureAsync = function (babylonTexture, scene) {
        var _this = this;
        return new Promise(function (resolve) {
            var proceduralTexture = new ProceduralTexture("" + babylonTexture.name, babylonTexture.getSize(), "textureTransform", scene);
            if (!proceduralTexture) {
                Tools.Log("Cannot create procedural texture for " + babylonTexture.name + "!");
                resolve(babylonTexture);
            }
            proceduralTexture.reservedDataStore = {
                hidden: true,
                source: babylonTexture
            };
            _this._recordedTextures.push(proceduralTexture);
            proceduralTexture.coordinatesIndex = babylonTexture.coordinatesIndex;
            proceduralTexture.setTexture("textureSampler", babylonTexture);
            proceduralTexture.setMatrix("textureTransformMat", babylonTexture.getTextureMatrix());
            // isReady trigger creation of effect if it doesnt exist yet
            if (proceduralTexture.isReady()) {
                proceduralTexture.render();
                resolve(proceduralTexture);
            }
            else {
                proceduralTexture.getEffect().executeWhenCompiled(function () {
                    proceduralTexture.render();
                    resolve(proceduralTexture);
                });
            }
        });
    };
    return KHR_texture_transform;
}());
export { KHR_texture_transform };
_Exporter.RegisterExtension(NAME, function (exporter) { return new KHR_texture_transform(exporter); });
//# sourceMappingURL=KHR_texture_transform.js.map