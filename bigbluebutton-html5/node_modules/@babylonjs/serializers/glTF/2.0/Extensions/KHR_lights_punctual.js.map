{"version":3,"file":"KHR_lights_punctual.js","sourceRoot":"","sources":["../../../../../sourceES6/serializers/src/glTF/2.0/Extensions/KHR_lights_punctual.ts"],"names":[],"mappings":"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","sourcesContent":["import { SpotLight } from \"@babylonjs/core/Lights/spotLight\";\nimport { Nullable } from \"@babylonjs/core/types\";\nimport { Vector3, Quaternion, TmpVectors, Matrix } from \"@babylonjs/core/Maths/math.vector\";\nimport { Color3 } from \"@babylonjs/core/Maths/math.color\";\nimport { Light } from \"@babylonjs/core/Lights/light\";\nimport { DirectionalLight } from \"@babylonjs/core/Lights/directionalLight\";\nimport { Node } from \"@babylonjs/core/node\";\nimport { ShadowLight } from \"@babylonjs/core/Lights/shadowLight\";\nimport { IChildRootProperty } from \"babylonjs-gltf2interface\";\nimport { INode } from \"babylonjs-gltf2interface\";\nimport { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\nimport { _Exporter } from \"../glTFExporter\";\nimport { Logger } from \"@babylonjs/core/Misc/logger\";\nimport { _GLTFUtilities } from \"../glTFUtilities\";\n\nconst NAME = \"KHR_lights_punctual\";\n\nenum LightType {\n    DIRECTIONAL = \"directional\",\n    POINT = \"point\",\n    SPOT = \"spot\"\n}\n\ninterface ILightReference {\n    light: number;\n}\n\ninterface ILight extends IChildRootProperty {\n    type: LightType;\n    color?: number[];\n    intensity?: number;\n    range?: number;\n    spot?: {\n        innerConeAngle?: number;\n        outerConeAngle?: number;\n    };\n}\n\ninterface ILights {\n    lights: ILight[];\n}\n\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md)\n */\nexport class KHR_lights_punctual implements IGLTFExporterExtensionV2 {\n    /** The name of this extension. */\n    public readonly name = NAME;\n\n    /** Defines whether this extension is enabled. */\n    public enabled = true;\n\n    /** Defines whether this extension is required */\n    public required = false;\n\n    /** Reference to the glTF exporter */\n    private _exporter: _Exporter;\n\n    private _lights: ILights;\n\n    /** @hidden */\n    constructor(exporter: _Exporter) {\n        this._exporter = exporter;\n    }\n\n    /** @hidden */\n    public dispose() {\n        delete this._lights;\n    }\n\n    /** @hidden */\n    public get wasUsed() {\n        return !!this._lights;\n    }\n\n    /** @hidden */\n    public onExporting(): void {\n        this._exporter!._glTF.extensions![NAME] = this._lights;\n    }\n    /**\n     * Define this method to modify the default behavior when exporting a node\n     * @param context The context when exporting the node\n     * @param node glTF node\n     * @param babylonNode BabylonJS node\n     * @param nodeMap Node mapping of unique id to glTF node index\n     * @returns nullable INode promise\n     */\n    public postExportNodeAsync(context: string, node: Nullable<INode>, babylonNode: Node, nodeMap?: {[key: number]: number}): Promise<Nullable<INode>> {\n        return new Promise((resolve, reject) => {\n            if (node && babylonNode instanceof ShadowLight) {\n                const babylonLight: ShadowLight = babylonNode;\n                let light: ILight;\n\n                const lightType = (\n                    babylonLight.getTypeID() == Light.LIGHTTYPEID_POINTLIGHT ? LightType.POINT : (\n                        babylonLight.getTypeID() == Light.LIGHTTYPEID_DIRECTIONALLIGHT ? LightType.DIRECTIONAL : (\n                            babylonLight.getTypeID() == Light.LIGHTTYPEID_SPOTLIGHT ? LightType.SPOT : null\n                        )));\n                if (lightType == null) {\n                    Logger.Warn(`${context}: Light ${babylonLight.name} is not supported in ${NAME}`);\n                }\n                else {\n                    const lightPosition = babylonLight.position.clone();\n                    let convertToRightHandedSystem = this._exporter._convertToRightHandedSystemMap[babylonNode.uniqueId];\n                    if (!lightPosition.equals(Vector3.Zero())) {\n                        if (convertToRightHandedSystem) {\n                            _GLTFUtilities._GetRightHandedPositionVector3FromRef(lightPosition);\n                        }\n                        node.translation = lightPosition.asArray();\n                    }\n                    if (lightType !== LightType.POINT) {\n                        const localAxis = babylonLight.direction;\n                        const yaw = -Math.atan2(localAxis.z * (this._exporter._babylonScene.useRightHandedSystem ? -1 : 1), localAxis.x) + Math.PI / 2;\n                        const len = Math.sqrt(localAxis.x * localAxis.x + localAxis.z * localAxis.z);\n                        const pitch = -Math.atan2(localAxis.y, len);\n                        const lightRotationQuaternion = Quaternion.RotationYawPitchRoll(yaw, pitch, 0);\n                        if (convertToRightHandedSystem) {\n                            _GLTFUtilities._GetRightHandedQuaternionFromRef(lightRotationQuaternion);\n                        }\n                        if (!lightRotationQuaternion.equals(Quaternion.Identity())) {\n                            node.rotation = lightRotationQuaternion.asArray();\n                        }\n                    }\n\n                    if (babylonLight.falloffType !== Light.FALLOFF_GLTF) {\n                        Logger.Warn(`${context}: Light falloff for ${babylonLight.name} does not match the ${NAME} specification!`);\n                    }\n                    light = {\n                        type: lightType\n                    };\n                    if (!babylonLight.diffuse.equals(Color3.White())) {\n                        light.color = babylonLight.diffuse.asArray();\n                    }\n                    if (babylonLight.intensity !== 1.0) {\n                        light.intensity = babylonLight.intensity;\n                    }\n                    if (babylonLight.range !== Number.MAX_VALUE) {\n                        light.range = babylonLight.range;\n                    }\n\n                    if (lightType === LightType.SPOT) {\n                        const babylonSpotLight = babylonLight as SpotLight;\n                        if (babylonSpotLight.angle !== Math.PI / 2.0) {\n                            if (light.spot == null) {\n                                light.spot = {};\n                            }\n                            light.spot.outerConeAngle = babylonSpotLight.angle / 2.0;\n                        }\n                        if (babylonSpotLight.innerAngle !== 0) {\n                            if (light.spot == null) {\n                                light.spot = {};\n                            }\n                            light.spot.innerConeAngle = babylonSpotLight.innerAngle / 2.0;\n                        }\n                    }\n\n                    if (this._lights == null) {\n                        this._lights = {\n                            lights: []\n                        };\n                    }\n\n                    this._lights.lights.push(light);\n\n                    const lightReference: ILightReference = {\n                        light: this._lights.lights.length - 1\n                    };\n\n                    // Avoid duplicating the Light's parent node if possible.\n                    let parentBabylonNode = babylonNode.parent;\n                    if (parentBabylonNode && parentBabylonNode.getChildren().length == 1) {\n                        let parentNode = this._exporter._nodes[nodeMap![parentBabylonNode.uniqueId]];\n                        if (parentNode) {\n                            let parentNodeLocalMatrix = TmpVectors.Matrix[0];\n                            let parentInvertNodeLocalMatrix = TmpVectors.Matrix[1];\n                            let parentNodeLocalTranslation = parentNode.translation ? new Vector3(parentNode.translation[0], parentNode.translation[1], parentNode.translation[2]) : Vector3.Zero();\n                            let parentNodeLocalRotation = parentNode.rotation ? new Quaternion(parentNode.rotation[0], parentNode.rotation[1], parentNode.rotation[2], parentNode.rotation[3]) : Quaternion.Identity();\n                            let parentNodeLocalScale = parentNode.scale ? new Vector3(parentNode.scale[0], parentNode.scale[1], parentNode.scale[2]) : Vector3.One();\n\n                            Matrix.ComposeToRef(parentNodeLocalScale, parentNodeLocalRotation, parentNodeLocalTranslation, parentNodeLocalMatrix);\n                            parentNodeLocalMatrix.invertToRef(parentInvertNodeLocalMatrix);\n\n                            // Convert light local matrix to local matrix relative to grandparent, facing -Z\n                            let lightLocalMatrix = TmpVectors.Matrix[2];\n                            let nodeLocalTranslation = node.translation ? new Vector3(node.translation[0], node.translation[1], node.translation[2]) : Vector3.Zero();\n\n                            // Undo directional light positional offset\n                            if (babylonLight instanceof DirectionalLight) {\n                                nodeLocalTranslation.subtractInPlace(this._exporter._babylonScene.useRightHandedSystem ? babylonLight.direction : _GLTFUtilities._GetRightHandedPositionVector3(babylonLight.direction));\n                            }\n                            let nodeLocalRotation = this._exporter._babylonScene.useRightHandedSystem ? Quaternion.Identity() : new Quaternion(0, 1, 0, 0);\n                            if (node.rotation) {\n                                nodeLocalRotation.multiplyInPlace(new Quaternion(node.rotation[0], node.rotation[1], node.rotation[2], node.rotation[3]));\n                            }\n                            let nodeLocalScale = node.scale ? new Vector3(node.scale[0], node.scale[1], node.scale[2]) : Vector3.One();\n\n                            Matrix.ComposeToRef(nodeLocalScale, nodeLocalRotation, nodeLocalTranslation, lightLocalMatrix);\n                            lightLocalMatrix.multiplyToRef(parentInvertNodeLocalMatrix, lightLocalMatrix);\n                            let parentNewScale = TmpVectors.Vector3[0];\n                            let parentNewRotationQuaternion = TmpVectors.Quaternion[0];\n                            let parentNewTranslation = TmpVectors.Vector3[1];\n\n                            lightLocalMatrix.decompose(parentNewScale, parentNewRotationQuaternion, parentNewTranslation);\n                            parentNode.scale = parentNewScale.asArray();\n                            parentNode.rotation = parentNewRotationQuaternion.asArray();\n                            parentNode.translation = parentNewTranslation.asArray();\n\n                            if (parentNode.extensions == null) {\n                                parentNode.extensions = {};\n                            }\n                            parentNode.extensions[NAME] = lightReference;\n\n                            // Do not export the original node\n                            resolve(undefined);\n                            return;\n                        }\n                    }\n\n                    if (node.extensions == null) {\n                        node.extensions = {};\n                    }\n\n                    node.extensions[NAME] = lightReference;\n                }\n            }\n            resolve(node);\n        });\n    }\n}\n\n_Exporter.RegisterExtension(NAME, (exporter) => new KHR_lights_punctual(exporter));"]}