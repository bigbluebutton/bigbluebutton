{"version":3,"file":"glTFAnimation.js","sourceRoot":"","sources":["../../../../sourceES6/serializers/src/glTF/2.0/glTFAnimation.ts"],"names":[],"mappings":"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","sourcesContent":["import { AnimationSamplerInterpolation, AnimationChannelTargetPath, AccessorType, IAnimation, INode, IBufferView, IAccessor, IAnimationSampler, IAnimationChannel, AccessorComponentType } from \"babylonjs-gltf2interface\";\r\nimport { Node } from \"@babylonjs/core/node\";\r\nimport { Nullable } from \"@babylonjs/core/types\";\r\nimport { Vector3, Quaternion } from \"@babylonjs/core/Maths/math.vector\";\r\nimport { Tools } from \"@babylonjs/core/Misc/tools\";\r\nimport { Animation } from \"@babylonjs/core/Animations/animation\";\r\nimport { TransformNode } from \"@babylonjs/core/Meshes/transformNode\";\r\nimport { Scene } from \"@babylonjs/core/scene\";\r\n\r\nimport { _BinaryWriter } from \"./glTFExporter\";\r\nimport { _GLTFUtilities } from \"./glTFUtilities\";\r\nimport { IAnimationKey, AnimationKeyInterpolation } from '@babylonjs/core/Animations/animationKey';\r\n\r\n/**\r\n * @hidden\r\n * Interface to store animation data.\r\n */\r\nexport interface _IAnimationData {\r\n    /**\r\n     * Keyframe data.\r\n     */\r\n    inputs: number[];\r\n    /**\r\n     * Value data.\r\n     */\r\n    outputs: number[][];\r\n    /**\r\n     * Animation interpolation data.\r\n     */\r\n    samplerInterpolation: AnimationSamplerInterpolation;\r\n    /**\r\n     * Minimum keyframe value.\r\n     */\r\n    inputsMin: number;\r\n    /**\r\n     * Maximum keyframe value.\r\n     */\r\n    inputsMax: number;\r\n}\r\n\r\n/**\r\n * @hidden\r\n */\r\nexport interface _IAnimationInfo {\r\n    /**\r\n     * The target channel for the animation\r\n     */\r\n    animationChannelTargetPath: AnimationChannelTargetPath;\r\n    /**\r\n     * The glTF accessor type for the data.\r\n     */\r\n    dataAccessorType: AccessorType.VEC3 | AccessorType.VEC4;\r\n    /**\r\n     * Specifies if quaternions should be used.\r\n     */\r\n    useQuaternion: boolean;\r\n}\r\n\r\n/**\r\n * @hidden\r\n * Enum for handling in tangent and out tangent.\r\n */\r\nenum _TangentType {\r\n    /**\r\n     * Specifies that input tangents are used.\r\n     */\r\n    INTANGENT,\r\n    /**\r\n     * Specifies that output tangents are used.\r\n     */\r\n    OUTTANGENT\r\n}\r\n/**\r\n * @hidden\r\n * Utility class for generating glTF animation data from BabylonJS.\r\n */\r\nexport class _GLTFAnimation {\r\n    /**\r\n     * @ignore\r\n     *\r\n     * Creates glTF channel animation from BabylonJS animation.\r\n     * @param babylonTransformNode - BabylonJS mesh.\r\n     * @param animation - animation.\r\n     * @param animationChannelTargetPath - The target animation channel.\r\n     * @param convertToRightHandedSystem - Specifies if the values should be converted to right-handed.\r\n     * @param useQuaternion - Specifies if quaternions are used.\r\n     * @returns nullable IAnimationData\r\n     */\r\n    public static _CreateNodeAnimation(babylonTransformNode: TransformNode, animation: Animation, animationChannelTargetPath: AnimationChannelTargetPath, convertToRightHandedSystem: boolean, useQuaternion: boolean, animationSampleRate: number): Nullable<_IAnimationData> {\r\n        const inputs: number[] = [];\r\n        const outputs: number[][] = [];\r\n        const keyFrames = animation.getKeys();\r\n        const minMaxKeyFrames = _GLTFAnimation.calculateMinMaxKeyFrames(keyFrames);\r\n        const interpolationOrBake = _GLTFAnimation._DeduceInterpolation(keyFrames, animationChannelTargetPath, useQuaternion);\r\n        const frameDelta = minMaxKeyFrames.max - minMaxKeyFrames.min;\r\n\r\n        const interpolation = interpolationOrBake.interpolationType;\r\n        const shouldBakeAnimation = interpolationOrBake.shouldBakeAnimation;\r\n\r\n        if (shouldBakeAnimation) {\r\n            _GLTFAnimation._CreateBakedAnimation(babylonTransformNode, animation, animationChannelTargetPath, minMaxKeyFrames.min, minMaxKeyFrames.max, animation.framePerSecond, animationSampleRate, inputs, outputs, minMaxKeyFrames, convertToRightHandedSystem, useQuaternion);\r\n        }\r\n        else {\r\n            if (interpolation === AnimationSamplerInterpolation.LINEAR || interpolation === AnimationSamplerInterpolation.STEP) {\r\n                _GLTFAnimation._CreateLinearOrStepAnimation(babylonTransformNode, animation, animationChannelTargetPath, frameDelta, inputs, outputs, convertToRightHandedSystem, useQuaternion);\r\n\r\n            }\r\n            else if (interpolation === AnimationSamplerInterpolation.CUBICSPLINE) {\r\n                _GLTFAnimation._CreateCubicSplineAnimation(babylonTransformNode, animation, animationChannelTargetPath, frameDelta, inputs, outputs, convertToRightHandedSystem, useQuaternion);\r\n            }\r\n            else {\r\n                _GLTFAnimation._CreateBakedAnimation(babylonTransformNode, animation, animationChannelTargetPath, minMaxKeyFrames.min, minMaxKeyFrames.max, animation.framePerSecond, animationSampleRate, inputs, outputs, minMaxKeyFrames, convertToRightHandedSystem, useQuaternion);\r\n            }\r\n        }\r\n\r\n        if (inputs.length && outputs.length) {\r\n            const result: _IAnimationData = {\r\n                inputs: inputs,\r\n                outputs: outputs,\r\n                samplerInterpolation: interpolation,\r\n                inputsMin: shouldBakeAnimation ? minMaxKeyFrames.min : Tools.FloatRound(minMaxKeyFrames.min / animation.framePerSecond),\r\n                inputsMax: shouldBakeAnimation ? minMaxKeyFrames.max : Tools.FloatRound(minMaxKeyFrames.max / animation.framePerSecond)\r\n            };\r\n\r\n            return result;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    private static _DeduceAnimationInfo(animation: Animation): Nullable<_IAnimationInfo> {\r\n        let animationChannelTargetPath: Nullable<AnimationChannelTargetPath> = null;\r\n        let dataAccessorType = AccessorType.VEC3;\r\n        let useQuaternion: boolean = false;\r\n        let property = animation.targetProperty.split('.');\r\n        switch (property[0]) {\r\n            case 'scaling': {\r\n                animationChannelTargetPath = AnimationChannelTargetPath.SCALE;\r\n                break;\r\n            }\r\n            case 'position': {\r\n                animationChannelTargetPath = AnimationChannelTargetPath.TRANSLATION;\r\n                break;\r\n            }\r\n            case 'rotation': {\r\n                dataAccessorType = AccessorType.VEC4;\r\n                animationChannelTargetPath = AnimationChannelTargetPath.ROTATION;\r\n                break;\r\n            }\r\n            case 'rotationQuaternion': {\r\n                dataAccessorType = AccessorType.VEC4;\r\n                useQuaternion = true;\r\n                animationChannelTargetPath = AnimationChannelTargetPath.ROTATION;\r\n                break;\r\n            }\r\n            default: {\r\n                Tools.Error(`Unsupported animatable property ${property[0]}`);\r\n            }\r\n        }\r\n        if (animationChannelTargetPath) {\r\n            return { animationChannelTargetPath: animationChannelTargetPath, dataAccessorType: dataAccessorType, useQuaternion: useQuaternion };\r\n        }\r\n        else {\r\n            Tools.Error('animation channel target path and data accessor type could be deduced');\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     * Create node animations from the transform node animations\r\n     * @param babylonNode\r\n     * @param runtimeGLTFAnimation\r\n     * @param idleGLTFAnimations\r\n     * @param nodeMap\r\n     * @param nodes\r\n     * @param binaryWriter\r\n     * @param bufferViews\r\n     * @param accessors\r\n     * @param convertToRightHandedSystem\r\n     * @param animationSampleRate\r\n     */\r\n    public static _CreateNodeAnimationFromNodeAnimations(babylonNode: Node, runtimeGLTFAnimation: IAnimation, idleGLTFAnimations: IAnimation[], nodeMap: { [key: number]: number }, nodes: INode[], binaryWriter: _BinaryWriter, bufferViews: IBufferView[], accessors: IAccessor[], convertToRightHandedSystem: boolean, animationSampleRate: number) {\r\n        let glTFAnimation: IAnimation;\r\n        if (babylonNode instanceof TransformNode) {\r\n            if (babylonNode.animations) {\r\n                for (let animation of babylonNode.animations) {\r\n                    let animationInfo = _GLTFAnimation._DeduceAnimationInfo(animation);\r\n                    if (animationInfo) {\r\n                        glTFAnimation = {\r\n                            name: animation.name,\r\n                            samplers: [],\r\n                            channels: []\r\n                        };\r\n                        _GLTFAnimation.AddAnimation(`${animation.name}`,\r\n                            animation.hasRunningRuntimeAnimations ? runtimeGLTFAnimation : glTFAnimation,\r\n                            babylonNode,\r\n                            animation,\r\n                            animationInfo.dataAccessorType,\r\n                            animationInfo.animationChannelTargetPath,\r\n                            nodeMap,\r\n                            binaryWriter,\r\n                            bufferViews,\r\n                            accessors,\r\n                            convertToRightHandedSystem,\r\n                            animationInfo.useQuaternion,\r\n                            animationSampleRate\r\n                        );\r\n                        if (glTFAnimation.samplers.length && glTFAnimation.channels.length) {\r\n                            idleGLTFAnimations.push(glTFAnimation);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     * Create node animations from the animation groups\r\n     * @param babylonScene\r\n     * @param glTFAnimations\r\n     * @param nodeMap\r\n     * @param nodes\r\n     * @param binaryWriter\r\n     * @param bufferViews\r\n     * @param accessors\r\n     * @param convertToRightHandedSystemMap\r\n     * @param animationSampleRate\r\n     */\r\n    public static _CreateNodeAnimationFromAnimationGroups(babylonScene: Scene, glTFAnimations: IAnimation[], nodeMap: { [key: number]: number }, nodes: INode[], binaryWriter: _BinaryWriter, bufferViews: IBufferView[], accessors: IAccessor[], convertToRightHandedSystemMap: { [nodeId: number]: boolean }, animationSampleRate: number) {\r\n        let glTFAnimation: IAnimation;\r\n        if (babylonScene.animationGroups) {\r\n            let animationGroups = babylonScene.animationGroups;\r\n\r\n            for (let animationGroup of animationGroups) {\r\n                glTFAnimation = {\r\n                    name: animationGroup.name,\r\n                    channels: [],\r\n                    samplers: []\r\n                };\r\n                for (let targetAnimation of animationGroup.targetedAnimations) {\r\n                    let target = targetAnimation.target;\r\n                    let animation = targetAnimation.animation;\r\n                    if (target instanceof TransformNode || target.length === 1 && target[0] instanceof TransformNode) {\r\n                        let animationInfo = _GLTFAnimation._DeduceAnimationInfo(targetAnimation.animation);\r\n                        if (animationInfo) {\r\n                            let babylonTransformNode = target instanceof TransformNode ? target as TransformNode : target[0] as TransformNode;\r\n                            let convertToRightHandedSystem = convertToRightHandedSystemMap[babylonTransformNode.uniqueId];\r\n                            _GLTFAnimation.AddAnimation(`${animation.name}`,\r\n                                glTFAnimation,\r\n                                babylonTransformNode,\r\n                                animation,\r\n                                animationInfo.dataAccessorType,\r\n                                animationInfo.animationChannelTargetPath,\r\n                                nodeMap,\r\n                                binaryWriter,\r\n                                bufferViews,\r\n                                accessors,\r\n                                convertToRightHandedSystem,\r\n                                animationInfo.useQuaternion,\r\n                                animationSampleRate\r\n                            );\r\n                        }\r\n                    }\r\n                }\r\n                if (glTFAnimation.channels.length && glTFAnimation.samplers.length) {\r\n                    glTFAnimations.push(glTFAnimation);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private static AddAnimation(name: string, glTFAnimation: IAnimation, babylonTransformNode: TransformNode, animation: Animation, dataAccessorType: AccessorType, animationChannelTargetPath: AnimationChannelTargetPath, nodeMap: { [key: number]: number }, binaryWriter: _BinaryWriter, bufferViews: IBufferView[], accessors: IAccessor[], convertToRightHandedSystem: boolean, useQuaternion: boolean, animationSampleRate: number) {\r\n        let animationData = _GLTFAnimation._CreateNodeAnimation(babylonTransformNode, animation, animationChannelTargetPath, convertToRightHandedSystem, useQuaternion, animationSampleRate);\r\n        let bufferView: IBufferView;\r\n        let accessor: IAccessor;\r\n        let keyframeAccessorIndex: number;\r\n        let dataAccessorIndex: number;\r\n        let outputLength: number;\r\n        let animationSampler: IAnimationSampler;\r\n        let animationChannel: IAnimationChannel;\r\n\r\n        if (animationData) {\r\n            let nodeIndex = nodeMap[babylonTransformNode.uniqueId];\r\n\r\n            // Creates buffer view and accessor for key frames.\r\n            let byteLength = animationData.inputs.length * 4;\r\n            bufferView = _GLTFUtilities._CreateBufferView(0, binaryWriter.getByteOffset(), byteLength, undefined, `${name}  keyframe data view`);\r\n            bufferViews.push(bufferView);\r\n            animationData.inputs.forEach(function(input) {\r\n                binaryWriter.setFloat32(input);\r\n            });\r\n\r\n            accessor = _GLTFUtilities._CreateAccessor(bufferViews.length - 1, `${name}  keyframes`, AccessorType.SCALAR, AccessorComponentType.FLOAT, animationData.inputs.length, null, [animationData.inputsMin], [animationData.inputsMax]);\r\n            accessors.push(accessor);\r\n            keyframeAccessorIndex = accessors.length - 1;\r\n\r\n            // create bufferview and accessor for keyed values.\r\n            outputLength = animationData.outputs.length;\r\n            byteLength = dataAccessorType === AccessorType.VEC3 ? animationData.outputs.length * 12 : animationData.outputs.length * 16;\r\n\r\n            // check for in and out tangents\r\n            bufferView = _GLTFUtilities._CreateBufferView(0, binaryWriter.getByteOffset(), byteLength, undefined, `${name}  data view`);\r\n            bufferViews.push(bufferView);\r\n\r\n            animationData.outputs.forEach(function(output) {\r\n                output.forEach(function(entry) {\r\n                    binaryWriter.setFloat32(entry);\r\n                });\r\n            });\r\n\r\n            accessor = _GLTFUtilities._CreateAccessor(bufferViews.length - 1, `${name}  data`, dataAccessorType, AccessorComponentType.FLOAT, outputLength, null, null, null);\r\n            accessors.push(accessor);\r\n            dataAccessorIndex = accessors.length - 1;\r\n\r\n            // create sampler\r\n            animationSampler = {\r\n                interpolation: animationData.samplerInterpolation,\r\n                input: keyframeAccessorIndex,\r\n                output: dataAccessorIndex\r\n            };\r\n            glTFAnimation.samplers.push(animationSampler);\r\n\r\n            // create channel\r\n            animationChannel = {\r\n                sampler: glTFAnimation.samplers.length - 1,\r\n                target: {\r\n                    node: nodeIndex,\r\n                    path: animationChannelTargetPath\r\n                }\r\n            };\r\n            glTFAnimation.channels.push(animationChannel);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a baked animation\r\n     * @param babylonTransformNode BabylonJS mesh\r\n     * @param animation BabylonJS animation corresponding to the BabylonJS mesh\r\n     * @param animationChannelTargetPath animation target channel\r\n     * @param minFrame minimum animation frame\r\n     * @param maxFrame maximum animation frame\r\n     * @param fps frames per second of the animation\r\n     * @param inputs input key frames of the animation\r\n     * @param outputs output key frame data of the animation\r\n     * @param convertToRightHandedSystem converts the values to right-handed\r\n     * @param useQuaternion specifies if quaternions should be used\r\n     */\r\n    private static _CreateBakedAnimation(babylonTransformNode: TransformNode, animation: Animation, animationChannelTargetPath: AnimationChannelTargetPath, minFrame: number, maxFrame: number, fps: number, sampleRate: number, inputs: number[], outputs: number[][], minMaxFrames: { min: number, max: number }, convertToRightHandedSystem: boolean, useQuaternion: boolean) {\r\n        let value: number | Vector3 | Quaternion;\r\n        let quaternionCache: Quaternion = Quaternion.Identity();\r\n        let previousTime: Nullable<number> = null;\r\n        let time: number;\r\n        let maxUsedFrame: Nullable<number> = null;\r\n        let currKeyFrame: Nullable<IAnimationKey> = null;\r\n        let nextKeyFrame: Nullable<IAnimationKey> = null;\r\n        let prevKeyFrame: Nullable<IAnimationKey> = null;\r\n        let endFrame: Nullable<number> = null;\r\n        minMaxFrames.min = Tools.FloatRound(minFrame / fps);\r\n\r\n        let keyFrames = animation.getKeys();\r\n\r\n        for (let i = 0, length = keyFrames.length; i < length; ++i) {\r\n            endFrame = null;\r\n            currKeyFrame = keyFrames[i];\r\n\r\n            if (i + 1 < length) {\r\n                nextKeyFrame = keyFrames[i + 1];\r\n                if (currKeyFrame.value.equals && currKeyFrame.value.equals(nextKeyFrame.value) || currKeyFrame.value === nextKeyFrame.value) {\r\n                    if (i === 0) { // set the first frame to itself\r\n                        endFrame = currKeyFrame.frame;\r\n                    }\r\n                    else {\r\n                        continue;\r\n                    }\r\n                }\r\n                else {\r\n                    endFrame = nextKeyFrame.frame;\r\n                }\r\n            }\r\n            else {\r\n                // at the last key frame\r\n                prevKeyFrame = keyFrames[i - 1];\r\n                if (currKeyFrame.value.equals && currKeyFrame.value.equals(prevKeyFrame.value) || currKeyFrame.value === prevKeyFrame.value) {\r\n                    continue;\r\n                }\r\n                else {\r\n                    endFrame = maxFrame;\r\n                }\r\n            }\r\n            if (endFrame) {\r\n                for (let f = currKeyFrame.frame; f <= endFrame; f += sampleRate) {\r\n                    time = Tools.FloatRound(f / fps);\r\n                    if (time === previousTime) {\r\n                        continue;\r\n                    }\r\n                    previousTime = time;\r\n                    maxUsedFrame = time;\r\n                    let state = {\r\n                        key: 0,\r\n                        repeatCount: 0,\r\n                        loopMode: animation.loopMode\r\n                    };\r\n                    value = animation._interpolate(f, state);\r\n\r\n                    _GLTFAnimation._SetInterpolatedValue(babylonTransformNode, value, time, animation, animationChannelTargetPath, quaternionCache, inputs, outputs, convertToRightHandedSystem, useQuaternion);\r\n                }\r\n            }\r\n        }\r\n        if (maxUsedFrame) {\r\n            minMaxFrames.max = maxUsedFrame;\r\n        }\r\n    }\r\n\r\n    private static _ConvertFactorToVector3OrQuaternion(factor: number, babylonTransformNode: TransformNode, animation: Animation, animationType: number, animationChannelTargetPath: AnimationChannelTargetPath, convertToRightHandedSystem: boolean, useQuaternion: boolean): Nullable<Vector3 | Quaternion> {\r\n        let property: string[];\r\n        let componentName: string;\r\n        let value: Nullable<Quaternion | Vector3> = null;\r\n        const basePositionRotationOrScale = _GLTFAnimation._GetBasePositionRotationOrScale(babylonTransformNode, animationChannelTargetPath, convertToRightHandedSystem, useQuaternion);\r\n        if (animationType === Animation.ANIMATIONTYPE_FLOAT) { // handles single component x, y, z or w component animation by using a base property and animating over a component.\r\n            property = animation.targetProperty.split('.');\r\n            componentName = property ? property[1] : ''; // x, y, or z component\r\n            value = useQuaternion ? Quaternion.FromArray(basePositionRotationOrScale).normalize() : Vector3.FromArray(basePositionRotationOrScale);\r\n\r\n            switch (componentName) {\r\n                case 'x': {\r\n                    value[componentName] = (convertToRightHandedSystem && useQuaternion && (animationChannelTargetPath !== AnimationChannelTargetPath.SCALE)) ? -factor : factor;\r\n                    break;\r\n                }\r\n                case 'y': {\r\n                    value[componentName] = (convertToRightHandedSystem && useQuaternion && (animationChannelTargetPath !== AnimationChannelTargetPath.SCALE)) ? -factor : factor;\r\n                    break;\r\n                }\r\n                case 'z': {\r\n                    value[componentName] = (convertToRightHandedSystem && !useQuaternion && (animationChannelTargetPath !== AnimationChannelTargetPath.SCALE)) ? -factor : factor;\r\n                    break;\r\n                }\r\n                case 'w': {\r\n                    (value as Quaternion).w = factor;\r\n                    break;\r\n                }\r\n                default: {\r\n                    Tools.Error(`glTFAnimation: Unsupported component type \"${componentName}\" for scale animation!`);\r\n                }\r\n            }\r\n        }\r\n\r\n        return value;\r\n    }\r\n\r\n    private static _SetInterpolatedValue(babylonTransformNode: TransformNode, value: Nullable<number | Vector3 | Quaternion>, time: number, animation: Animation, animationChannelTargetPath: AnimationChannelTargetPath, quaternionCache: Quaternion, inputs: number[], outputs: number[][], convertToRightHandedSystem: boolean, useQuaternion: boolean) {\r\n        const animationType = animation.dataType;\r\n        let cacheValue: Vector3 | Quaternion;\r\n        inputs.push(time);\r\n        if (typeof value === \"number\") {\r\n            value = this._ConvertFactorToVector3OrQuaternion(value as number, babylonTransformNode, animation, animationType, animationChannelTargetPath, convertToRightHandedSystem, useQuaternion);\r\n        }\r\n        if (value) {\r\n            if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION) {\r\n                if (useQuaternion) {\r\n                    quaternionCache = value as Quaternion;\r\n                }\r\n                else {\r\n                    cacheValue = value as Vector3;\r\n                    Quaternion.RotationYawPitchRollToRef(cacheValue.y, cacheValue.x, cacheValue.z, quaternionCache);\r\n                }\r\n                if (convertToRightHandedSystem) {\r\n                    _GLTFUtilities._GetRightHandedQuaternionFromRef(quaternionCache);\r\n\r\n                    if (!babylonTransformNode.parent) {\r\n                        quaternionCache = Quaternion.FromArray([0, 1, 0, 0]).multiply(quaternionCache);\r\n                    }\r\n                }\r\n                outputs.push(quaternionCache.asArray());\r\n            }\r\n            else {\r\n                cacheValue = value as Vector3;\r\n                if (convertToRightHandedSystem && (animationChannelTargetPath !== AnimationChannelTargetPath.SCALE)) {\r\n                    _GLTFUtilities._GetRightHandedPositionVector3FromRef(cacheValue);\r\n                    if (!babylonTransformNode.parent) {\r\n                        cacheValue.x *= -1;\r\n                        cacheValue.z *= -1;\r\n                    }\r\n                }\r\n\r\n                outputs.push(cacheValue.asArray());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates linear animation from the animation key frames\r\n     * @param babylonTransformNode BabylonJS mesh\r\n     * @param animation BabylonJS animation\r\n     * @param animationChannelTargetPath The target animation channel\r\n     * @param frameDelta The difference between the last and first frame of the animation\r\n     * @param inputs Array to store the key frame times\r\n     * @param outputs Array to store the key frame data\r\n     * @param convertToRightHandedSystem Specifies if the position data should be converted to right handed\r\n     * @param useQuaternion Specifies if quaternions are used in the animation\r\n     */\r\n    private static _CreateLinearOrStepAnimation(babylonTransformNode: TransformNode, animation: Animation, animationChannelTargetPath: AnimationChannelTargetPath, frameDelta: number, inputs: number[], outputs: number[][], convertToRightHandedSystem: boolean, useQuaternion: boolean) {\r\n        for (let keyFrame of animation.getKeys()) {\r\n            inputs.push(keyFrame.frame / animation.framePerSecond); // keyframes in seconds.\r\n            _GLTFAnimation._AddKeyframeValue(keyFrame, animation, outputs, animationChannelTargetPath, babylonTransformNode, convertToRightHandedSystem, useQuaternion);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates cubic spline animation from the animation key frames\r\n     * @param babylonTransformNode BabylonJS mesh\r\n     * @param animation BabylonJS animation\r\n     * @param animationChannelTargetPath The target animation channel\r\n     * @param frameDelta The difference between the last and first frame of the animation\r\n     * @param inputs Array to store the key frame times\r\n     * @param outputs Array to store the key frame data\r\n     * @param convertToRightHandedSystem Specifies if the position data should be converted to right handed\r\n     * @param useQuaternion Specifies if quaternions are used in the animation\r\n     */\r\n    private static _CreateCubicSplineAnimation(babylonTransformNode: TransformNode, animation: Animation, animationChannelTargetPath: AnimationChannelTargetPath, frameDelta: number, inputs: number[], outputs: number[][], convertToRightHandedSystem: boolean, useQuaternion: boolean) {\r\n        animation.getKeys().forEach(function(keyFrame) {\r\n            inputs.push(keyFrame.frame / animation.framePerSecond); // keyframes in seconds.\r\n            _GLTFAnimation.AddSplineTangent(\r\n                babylonTransformNode,\r\n                _TangentType.INTANGENT,\r\n                outputs,\r\n                animationChannelTargetPath,\r\n                AnimationSamplerInterpolation.CUBICSPLINE,\r\n                keyFrame,\r\n                frameDelta,\r\n                useQuaternion,\r\n                convertToRightHandedSystem\r\n            );\r\n            _GLTFAnimation._AddKeyframeValue(keyFrame, animation, outputs, animationChannelTargetPath, babylonTransformNode, convertToRightHandedSystem, useQuaternion);\r\n\r\n            _GLTFAnimation.AddSplineTangent(\r\n                babylonTransformNode,\r\n                _TangentType.OUTTANGENT,\r\n                outputs,\r\n                animationChannelTargetPath,\r\n                AnimationSamplerInterpolation.CUBICSPLINE,\r\n                keyFrame,\r\n                frameDelta,\r\n                useQuaternion,\r\n                convertToRightHandedSystem\r\n            );\r\n        });\r\n    }\r\n\r\n    private static _GetBasePositionRotationOrScale(babylonTransformNode: TransformNode, animationChannelTargetPath: AnimationChannelTargetPath, convertToRightHandedSystem: boolean, useQuaternion: boolean) {\r\n        let basePositionRotationOrScale: number[];\r\n        if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION) {\r\n            if (useQuaternion) {\r\n                if (babylonTransformNode.rotationQuaternion) {\r\n                    basePositionRotationOrScale = babylonTransformNode.rotationQuaternion.asArray();\r\n                    if (convertToRightHandedSystem) {\r\n                        _GLTFUtilities._GetRightHandedQuaternionArrayFromRef(basePositionRotationOrScale);\r\n                        if (!babylonTransformNode.parent) {\r\n                            basePositionRotationOrScale = Quaternion.FromArray([0, 1, 0, 0]).multiply(Quaternion.FromArray(basePositionRotationOrScale)).asArray();\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    basePositionRotationOrScale = Quaternion.Identity().asArray();\r\n                }\r\n            }\r\n            else {\r\n                basePositionRotationOrScale = babylonTransformNode.rotation.asArray();\r\n                _GLTFUtilities._GetRightHandedNormalArray3FromRef(basePositionRotationOrScale);\r\n            }\r\n        }\r\n        else if (animationChannelTargetPath === AnimationChannelTargetPath.TRANSLATION) {\r\n            basePositionRotationOrScale = babylonTransformNode.position.asArray();\r\n            if (convertToRightHandedSystem) {\r\n                _GLTFUtilities._GetRightHandedPositionArray3FromRef(basePositionRotationOrScale);\r\n            }\r\n        }\r\n        else { // scale\r\n            basePositionRotationOrScale = babylonTransformNode.scaling.asArray();\r\n        }\r\n        return basePositionRotationOrScale;\r\n    }\r\n\r\n    /**\r\n     * Adds a key frame value\r\n     * @param keyFrame\r\n     * @param animation\r\n     * @param outputs\r\n     * @param animationChannelTargetPath\r\n     * @param basePositionRotationOrScale\r\n     * @param convertToRightHandedSystem\r\n     * @param useQuaternion\r\n     */\r\n    private static _AddKeyframeValue(keyFrame: IAnimationKey, animation: Animation, outputs: number[][], animationChannelTargetPath: AnimationChannelTargetPath, babylonTransformNode: TransformNode, convertToRightHandedSystem: boolean, useQuaternion: boolean) {\r\n        let value: number[];\r\n        let newPositionRotationOrScale: Nullable<Vector3 | Quaternion>;\r\n        const animationType = animation.dataType;\r\n        if (animationType === Animation.ANIMATIONTYPE_VECTOR3) {\r\n            value = keyFrame.value.asArray();\r\n            if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION) {\r\n                const array = Vector3.FromArray(value);\r\n                let rotationQuaternion = Quaternion.RotationYawPitchRoll(array.y, array.x, array.z);\r\n                if (convertToRightHandedSystem) {\r\n                    _GLTFUtilities._GetRightHandedQuaternionFromRef(rotationQuaternion);\r\n\r\n                    if (!babylonTransformNode.parent) {\r\n                        rotationQuaternion = Quaternion.FromArray([0, 1, 0, 0]).multiply(rotationQuaternion);\r\n                    }\r\n                }\r\n                value = rotationQuaternion.asArray();\r\n            }\r\n            else if (animationChannelTargetPath === AnimationChannelTargetPath.TRANSLATION) {\r\n                if (convertToRightHandedSystem) {\r\n                    _GLTFUtilities._GetRightHandedNormalArray3FromRef(value);\r\n                    if (!babylonTransformNode.parent) {\r\n                        value[0] *= -1;\r\n                        value[2] *= -1;\r\n                    }\r\n                }\r\n            }\r\n            outputs.push(value); // scale  vector.\r\n\r\n        }\r\n        else if (animationType === Animation.ANIMATIONTYPE_FLOAT) { // handles single component x, y, z or w component animation by using a base property and animating over a component.\r\n            newPositionRotationOrScale = this._ConvertFactorToVector3OrQuaternion(keyFrame.value as number, babylonTransformNode, animation, animationType, animationChannelTargetPath, convertToRightHandedSystem, useQuaternion);\r\n            if (newPositionRotationOrScale) {\r\n                if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION) {\r\n                    let posRotScale = useQuaternion ? newPositionRotationOrScale as Quaternion : Quaternion.RotationYawPitchRoll(newPositionRotationOrScale.y, newPositionRotationOrScale.x, newPositionRotationOrScale.z).normalize();\r\n                    if (convertToRightHandedSystem) {\r\n                        _GLTFUtilities._GetRightHandedQuaternionFromRef(posRotScale);\r\n\r\n                        if (!babylonTransformNode.parent) {\r\n                            posRotScale = Quaternion.FromArray([0, 1, 0, 0]).multiply(posRotScale);\r\n                        }\r\n                    }\r\n                    outputs.push(posRotScale.asArray());\r\n                }\r\n                else if (animationChannelTargetPath === AnimationChannelTargetPath.TRANSLATION) {\r\n                    if (convertToRightHandedSystem) {\r\n                        _GLTFUtilities._GetRightHandedNormalVector3FromRef(newPositionRotationOrScale as Vector3);\r\n\r\n                        if (!babylonTransformNode.parent) {\r\n                            newPositionRotationOrScale.x *= -1;\r\n                            newPositionRotationOrScale.z *= -1;\r\n                        }\r\n                    }\r\n                }\r\n                outputs.push(newPositionRotationOrScale.asArray());\r\n            }\r\n        }\r\n        else if (animationType === Animation.ANIMATIONTYPE_QUATERNION) {\r\n            value = (keyFrame.value as Quaternion).normalize().asArray();\r\n\r\n            if (convertToRightHandedSystem) {\r\n                _GLTFUtilities._GetRightHandedQuaternionArrayFromRef(value);\r\n\r\n                if (!babylonTransformNode.parent) {\r\n                    value = Quaternion.FromArray([0, 1, 0, 0]).multiply(Quaternion.FromArray(value)).asArray();\r\n                }\r\n            }\r\n\r\n            outputs.push(value);\r\n        }\r\n        else {\r\n            Tools.Error('glTFAnimation: Unsupported key frame values for animation!');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Determine the interpolation based on the key frames\r\n     * @param keyFrames\r\n     * @param animationChannelTargetPath\r\n     * @param useQuaternion\r\n     */\r\n    private static _DeduceInterpolation(keyFrames: IAnimationKey[], animationChannelTargetPath: AnimationChannelTargetPath, useQuaternion: boolean): { interpolationType: AnimationSamplerInterpolation, shouldBakeAnimation: boolean } {\r\n        let interpolationType: AnimationSamplerInterpolation | undefined;\r\n        let shouldBakeAnimation = false;\r\n        let key: IAnimationKey;\r\n\r\n        if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION && !useQuaternion) {\r\n            return { interpolationType: AnimationSamplerInterpolation.LINEAR, shouldBakeAnimation: true };\r\n        }\r\n\r\n        for (let i = 0, length = keyFrames.length; i < length; ++i) {\r\n            key = keyFrames[i];\r\n            if (key.inTangent || key.outTangent) {\r\n                if (interpolationType) {\r\n                    if (interpolationType !== AnimationSamplerInterpolation.CUBICSPLINE) {\r\n                        interpolationType = AnimationSamplerInterpolation.LINEAR;\r\n                        shouldBakeAnimation = true;\r\n                        break;\r\n                    }\r\n                }\r\n                else {\r\n                    interpolationType = AnimationSamplerInterpolation.CUBICSPLINE;\r\n                }\r\n            }\r\n            else {\r\n                if (interpolationType) {\r\n                    if (interpolationType === AnimationSamplerInterpolation.CUBICSPLINE ||\r\n                        (key.interpolation && (key.interpolation === AnimationKeyInterpolation.STEP) && interpolationType !== AnimationSamplerInterpolation.STEP)) {\r\n                        interpolationType = AnimationSamplerInterpolation.LINEAR;\r\n                        shouldBakeAnimation = true;\r\n                        break;\r\n                    }\r\n                }\r\n                else {\r\n                    if (key.interpolation && (key.interpolation === AnimationKeyInterpolation.STEP)) {\r\n                        interpolationType = AnimationSamplerInterpolation.STEP;\r\n                    }\r\n                    else {\r\n                        interpolationType = AnimationSamplerInterpolation.LINEAR;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (!interpolationType) {\r\n            interpolationType = AnimationSamplerInterpolation.LINEAR;\r\n        }\r\n\r\n        return { interpolationType: interpolationType, shouldBakeAnimation: shouldBakeAnimation };\r\n    }\r\n\r\n    /**\r\n     * Adds an input tangent or output tangent to the output data\r\n     * If an input tangent or output tangent is missing, it uses the zero vector or zero quaternion\r\n     * @param tangentType Specifies which type of tangent to handle (inTangent or outTangent)\r\n     * @param outputs The animation data by keyframe\r\n     * @param animationChannelTargetPath The target animation channel\r\n     * @param interpolation The interpolation type\r\n     * @param keyFrame The key frame with the animation data\r\n     * @param frameDelta Time difference between two frames used to scale the tangent by the frame delta\r\n     * @param useQuaternion Specifies if quaternions are used\r\n     * @param convertToRightHandedSystem Specifies if the values should be converted to right-handed\r\n     */\r\n    private static AddSplineTangent(babylonTransformNode: TransformNode, tangentType: _TangentType, outputs: number[][], animationChannelTargetPath: AnimationChannelTargetPath, interpolation: AnimationSamplerInterpolation, keyFrame: IAnimationKey, frameDelta: number, useQuaternion: boolean, convertToRightHandedSystem: boolean) {\r\n        let tangent: number[];\r\n        let tangentValue: Vector3 | Quaternion = tangentType === _TangentType.INTANGENT ? keyFrame.inTangent : keyFrame.outTangent;\r\n        if (interpolation === AnimationSamplerInterpolation.CUBICSPLINE) {\r\n            if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION) {\r\n                if (tangentValue) {\r\n                    if (useQuaternion) {\r\n                        tangent = (tangentValue as Quaternion).scale(frameDelta).asArray();\r\n                    }\r\n                    else {\r\n                        const array = (tangentValue as Vector3).scale(frameDelta);\r\n                        tangent = Quaternion.RotationYawPitchRoll(array.y, array.x, array.z).asArray();\r\n                    }\r\n\r\n                    if (convertToRightHandedSystem) {\r\n                        _GLTFUtilities._GetRightHandedQuaternionArrayFromRef(tangent);\r\n                        if (!babylonTransformNode.parent) {\r\n                            tangent = Quaternion.FromArray([0, 1, 0, 0]).multiply(Quaternion.FromArray(tangent)).asArray();\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    tangent = [0, 0, 0, 0];\r\n                }\r\n            }\r\n            else {\r\n                if (tangentValue) {\r\n                    tangent = (tangentValue as Vector3).scale(frameDelta).asArray();\r\n                    if (convertToRightHandedSystem) {\r\n                        if (animationChannelTargetPath === AnimationChannelTargetPath.TRANSLATION) {\r\n                            _GLTFUtilities._GetRightHandedPositionArray3FromRef(tangent);\r\n                            if (!babylonTransformNode.parent) {\r\n                                tangent[0] *= -1; // x\r\n                                tangent[2] *= -1; // z\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    tangent = [0, 0, 0];\r\n                }\r\n            }\r\n\r\n            outputs.push(tangent);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the minimum and maximum key frames' frame values\r\n     * @param keyFrames animation key frames\r\n     * @returns the minimum and maximum key frame value\r\n     */\r\n    private static calculateMinMaxKeyFrames(keyFrames: IAnimationKey[]): { min: number, max: number } {\r\n        let min: number = Infinity;\r\n        let max: number = -Infinity;\r\n        keyFrames.forEach(function(keyFrame) {\r\n            min = Math.min(min, keyFrame.frame);\r\n            max = Math.max(max, keyFrame.frame);\r\n        });\r\n\r\n        return { min: min, max: max };\r\n\r\n    }\r\n}"]}