{"version":3,"file":"glTFLoader.js","sourceRoot":"","sources":["../../../../sourceES6/loaders/src/glTF/1.0/glTFLoader.ts"],"names":[],"mappings":"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","sourcesContent":["import { IGLTFRuntime, IGLTFTechniqueParameter, IGLTFAnimation, IGLTFAnimationSampler, IGLTFNode, IGLTFSkins, INodeToRoot, IJointNode, IGLTFMesh, IGLTFAccessor, IGLTFLight, IGLTFAmbienLight, IGLTFDirectionalLight, IGLTFPointLight, IGLTFSpotLight, IGLTFCamera, IGLTFCameraPerspective, IGLTFScene, IGLTFTechnique, IGLTFMaterial, EParameterType, IGLTFProgram, IGLTFBuffer, IGLTFTexture, IGLTFImage, IGLTFSampler, ETextureFilterType, IGLTFShader, IGLTFTechniqueStates, ECullingType, EBlendingFunction, EShaderType } from \"./glTFLoaderInterfaces\";\r\n\r\nimport { FloatArray, Nullable } from \"@babylonjs/core/types\";\r\nimport { Quaternion, Vector3, Matrix } from \"@babylonjs/core/Maths/math.vector\";\r\nimport { Color3 } from '@babylonjs/core/Maths/math.color';\r\nimport { Tools } from \"@babylonjs/core/Misc/tools\";\r\nimport { Camera } from \"@babylonjs/core/Cameras/camera\";\r\nimport { FreeCamera } from \"@babylonjs/core/Cameras/freeCamera\";\r\nimport { Animation } from \"@babylonjs/core/Animations/animation\";\r\nimport { Bone } from \"@babylonjs/core/Bones/bone\";\r\nimport { Skeleton } from \"@babylonjs/core/Bones/skeleton\";\r\nimport { Effect } from \"@babylonjs/core/Materials/effect\";\r\nimport { Material } from \"@babylonjs/core/Materials/material\";\r\nimport { MultiMaterial } from \"@babylonjs/core/Materials/multiMaterial\";\r\nimport { StandardMaterial } from \"@babylonjs/core/Materials/standardMaterial\";\r\nimport { ShaderMaterial } from \"@babylonjs/core/Materials/shaderMaterial\";\r\nimport { Texture } from \"@babylonjs/core/Materials/Textures/texture\";\r\nimport { Node } from \"@babylonjs/core/node\";\r\nimport { VertexData } from \"@babylonjs/core/Meshes/mesh.vertexData\";\r\nimport { VertexBuffer } from \"@babylonjs/core/Meshes/buffer\";\r\nimport { Geometry } from \"@babylonjs/core/Meshes/geometry\";\r\nimport { SubMesh } from \"@babylonjs/core/Meshes/subMesh\";\r\nimport { AbstractMesh } from \"@babylonjs/core/Meshes/abstractMesh\";\r\nimport { Mesh } from \"@babylonjs/core/Meshes/mesh\";\r\nimport { HemisphericLight } from \"@babylonjs/core/Lights/hemisphericLight\";\r\nimport { DirectionalLight } from \"@babylonjs/core/Lights/directionalLight\";\r\nimport { PointLight } from \"@babylonjs/core/Lights/pointLight\";\r\nimport { SpotLight } from \"@babylonjs/core/Lights/spotLight\";\r\nimport { SceneLoaderProgressEvent } from \"@babylonjs/core/Loading/sceneLoader\";\r\nimport { Scene } from \"@babylonjs/core/scene\";\r\n\r\nimport { GLTFUtils } from \"./glTFLoaderUtils\";\r\nimport { GLTFFileLoader, IGLTFLoader, GLTFLoaderState, IGLTFLoaderData, IImportMeshAsyncOutput } from \"../glTFFileLoader\";\r\nimport { Constants } from '@babylonjs/core/Engines/constants';\r\n\r\n/**\r\n* Tokenizer. Used for shaders compatibility\r\n* Automatically map world, view, projection, worldViewProjection, attributes and so on\r\n*/\r\nenum ETokenType {\r\n    IDENTIFIER = 1,\r\n\r\n    UNKNOWN = 2,\r\n    END_OF_INPUT = 3\r\n}\r\n\r\nclass Tokenizer {\r\n    private _toParse: string;\r\n    private _pos: number = 0;\r\n    private _maxPos: number;\r\n\r\n    public currentToken: ETokenType = ETokenType.UNKNOWN;\r\n    public currentIdentifier: string = \"\";\r\n    public currentString: string = \"\";\r\n    public isLetterOrDigitPattern: RegExp = /^[a-zA-Z0-9]+$/;\r\n\r\n    constructor(toParse: string) {\r\n        this._toParse = toParse;\r\n        this._maxPos = toParse.length;\r\n    }\r\n\r\n    public getNextToken(): ETokenType {\r\n        if (this.isEnd()) { return ETokenType.END_OF_INPUT; }\r\n\r\n        this.currentString = this.read();\r\n        this.currentToken = ETokenType.UNKNOWN;\r\n\r\n        if (this.currentString === \"_\" || this.isLetterOrDigitPattern.test(this.currentString)) {\r\n            this.currentToken = ETokenType.IDENTIFIER;\r\n            this.currentIdentifier = this.currentString;\r\n            while (!this.isEnd() && (this.isLetterOrDigitPattern.test(this.currentString = this.peek()) || this.currentString === \"_\")) {\r\n                this.currentIdentifier += this.currentString;\r\n                this.forward();\r\n            }\r\n        }\r\n\r\n        return this.currentToken;\r\n    }\r\n\r\n    public peek(): string {\r\n        return this._toParse[this._pos];\r\n    }\r\n\r\n    public read(): string {\r\n        return this._toParse[this._pos++];\r\n    }\r\n\r\n    public forward(): void {\r\n        this._pos++;\r\n    }\r\n\r\n    public isEnd(): boolean {\r\n        return this._pos >= this._maxPos;\r\n    }\r\n}\r\n\r\n/**\r\n* Values\r\n*/\r\nvar glTFTransforms = [\"MODEL\", \"VIEW\", \"PROJECTION\", \"MODELVIEW\", \"MODELVIEWPROJECTION\", \"JOINTMATRIX\"];\r\nvar babylonTransforms = [\"world\", \"view\", \"projection\", \"worldView\", \"worldViewProjection\", \"mBones\"];\r\n\r\nvar glTFAnimationPaths = [\"translation\", \"rotation\", \"scale\"];\r\nvar babylonAnimationPaths = [\"position\", \"rotationQuaternion\", \"scaling\"];\r\n\r\n/**\r\n* Parse\r\n*/\r\nvar parseBuffers = (parsedBuffers: any, gltfRuntime: IGLTFRuntime) => {\r\n    for (var buf in parsedBuffers) {\r\n        var parsedBuffer = parsedBuffers[buf];\r\n        gltfRuntime.buffers[buf] = parsedBuffer;\r\n        gltfRuntime.buffersCount++;\r\n    }\r\n};\r\n\r\nvar parseShaders = (parsedShaders: any, gltfRuntime: IGLTFRuntime) => {\r\n    for (var sha in parsedShaders) {\r\n        var parsedShader = parsedShaders[sha];\r\n        gltfRuntime.shaders[sha] = parsedShader;\r\n        gltfRuntime.shaderscount++;\r\n    }\r\n};\r\n\r\nvar parseObject = (parsedObjects: any, runtimeProperty: string, gltfRuntime: IGLTFRuntime) => {\r\n    for (var object in parsedObjects) {\r\n        var parsedObject = parsedObjects[object];\r\n        (<any>gltfRuntime)[runtimeProperty][object] = parsedObject;\r\n    }\r\n};\r\n\r\n/**\r\n* Utils\r\n*/\r\nvar normalizeUVs = (buffer: any) => {\r\n    if (!buffer) {\r\n        return;\r\n    }\r\n\r\n    for (var i = 0; i < buffer.length / 2; i++) {\r\n        buffer[i * 2 + 1] = 1.0 - buffer[i * 2 + 1];\r\n    }\r\n};\r\n\r\nvar getAttribute = (attributeParameter: IGLTFTechniqueParameter): Nullable<string> => {\r\n    if (attributeParameter.semantic === \"NORMAL\") {\r\n        return \"normal\";\r\n    } else if (attributeParameter.semantic === \"POSITION\") {\r\n        return \"position\";\r\n    } else if (attributeParameter.semantic === \"JOINT\") {\r\n        return \"matricesIndices\";\r\n    } else if (attributeParameter.semantic === \"WEIGHT\") {\r\n        return \"matricesWeights\";\r\n    } else if (attributeParameter.semantic === \"COLOR\") {\r\n        return \"color\";\r\n    } else if (attributeParameter.semantic && attributeParameter.semantic.indexOf(\"TEXCOORD_\") !== -1) {\r\n        var channel = Number(attributeParameter.semantic.split(\"_\")[1]);\r\n        return \"uv\" + (channel === 0 ? \"\" : channel + 1);\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n* Loads and creates animations\r\n*/\r\nvar loadAnimations = (gltfRuntime: IGLTFRuntime) => {\r\n    for (var anim in gltfRuntime.animations) {\r\n        var animation: IGLTFAnimation = gltfRuntime.animations[anim];\r\n\r\n        if (!animation.channels || !animation.samplers) {\r\n            continue;\r\n        }\r\n\r\n        var lastAnimation: Nullable<Animation> = null;\r\n\r\n        for (var i = 0; i < animation.channels.length; i++) {\r\n            // Get parameters and load buffers\r\n            var channel = animation.channels[i];\r\n            var sampler: IGLTFAnimationSampler = animation.samplers[channel.sampler];\r\n\r\n            if (!sampler) {\r\n                continue;\r\n            }\r\n\r\n            var inputData: Nullable<string> = null;\r\n            var outputData: Nullable<string> = null;\r\n\r\n            if (animation.parameters) {\r\n                inputData = animation.parameters[sampler.input];\r\n                outputData = animation.parameters[sampler.output];\r\n            }\r\n            else {\r\n                inputData = sampler.input;\r\n                outputData = sampler.output;\r\n            }\r\n\r\n            var bufferInput = GLTFUtils.GetBufferFromAccessor(gltfRuntime, gltfRuntime.accessors[inputData]);\r\n            var bufferOutput = GLTFUtils.GetBufferFromAccessor(gltfRuntime, gltfRuntime.accessors[outputData]);\r\n\r\n            var targetID = channel.target.id;\r\n            var targetNode: any = gltfRuntime.scene.getNodeByID(targetID);\r\n\r\n            if (targetNode === null) {\r\n                targetNode = gltfRuntime.scene.getNodeByName(targetID);\r\n            }\r\n\r\n            if (targetNode === null) {\r\n                Tools.Warn(\"Creating animation named \" + anim + \". But cannot find node named \" + targetID + \" to attach to\");\r\n                continue;\r\n            }\r\n\r\n            var isBone = targetNode instanceof Bone;\r\n\r\n            // Get target path (position, rotation or scaling)\r\n            var targetPath = channel.target.path;\r\n            var targetPathIndex = glTFAnimationPaths.indexOf(targetPath);\r\n\r\n            if (targetPathIndex !== -1) {\r\n                targetPath = babylonAnimationPaths[targetPathIndex];\r\n            }\r\n\r\n            // Determine animation type\r\n            var animationType = Animation.ANIMATIONTYPE_MATRIX;\r\n\r\n            if (!isBone) {\r\n                if (targetPath === \"rotationQuaternion\") {\r\n                    animationType = Animation.ANIMATIONTYPE_QUATERNION;\r\n                    targetNode.rotationQuaternion = new Quaternion();\r\n                }\r\n                else {\r\n                    animationType = Animation.ANIMATIONTYPE_VECTOR3;\r\n                }\r\n            }\r\n\r\n            // Create animation and key frames\r\n            var babylonAnimation: Nullable<Animation> = null;\r\n            var keys = [];\r\n            var arrayOffset = 0;\r\n            var modifyKey = false;\r\n\r\n            if (isBone && lastAnimation && lastAnimation.getKeys().length === bufferInput.length) {\r\n                babylonAnimation = lastAnimation;\r\n                modifyKey = true;\r\n            }\r\n\r\n            if (!modifyKey) {\r\n                gltfRuntime.scene._blockEntityCollection = gltfRuntime.forAssetContainer;\r\n                babylonAnimation = new Animation(anim, isBone ? \"_matrix\" : targetPath, 1, animationType, Animation.ANIMATIONLOOPMODE_CYCLE);\r\n                gltfRuntime.scene._blockEntityCollection = false;\r\n            }\r\n\r\n            // For each frame\r\n            for (var j = 0; j < bufferInput.length; j++) {\r\n                var value: any = null;\r\n\r\n                if (targetPath === \"rotationQuaternion\") { // VEC4\r\n                    value = Quaternion.FromArray([bufferOutput[arrayOffset], bufferOutput[arrayOffset + 1], bufferOutput[arrayOffset + 2], bufferOutput[arrayOffset + 3]]);\r\n                    arrayOffset += 4;\r\n                }\r\n                else { // Position and scaling are VEC3\r\n                    value = Vector3.FromArray([bufferOutput[arrayOffset], bufferOutput[arrayOffset + 1], bufferOutput[arrayOffset + 2]]);\r\n                    arrayOffset += 3;\r\n                }\r\n\r\n                if (isBone) {\r\n                    var bone = <Bone>targetNode;\r\n                    var translation = Vector3.Zero();\r\n                    var rotationQuaternion = new Quaternion();\r\n                    var scaling = Vector3.Zero();\r\n\r\n                    // Warning on decompose\r\n                    var mat = bone.getBaseMatrix();\r\n\r\n                    if (modifyKey && lastAnimation) {\r\n                        mat = lastAnimation.getKeys()[j].value;\r\n                    }\r\n\r\n                    mat.decompose(scaling, rotationQuaternion, translation);\r\n\r\n                    if (targetPath === \"position\") {\r\n                        translation = value;\r\n                    }\r\n                    else if (targetPath === \"rotationQuaternion\") {\r\n                        rotationQuaternion = value;\r\n                    }\r\n                    else {\r\n                        scaling = value;\r\n                    }\r\n\r\n                    value = Matrix.Compose(scaling, rotationQuaternion, translation);\r\n                }\r\n\r\n                if (!modifyKey) {\r\n                    keys.push({\r\n                        frame: bufferInput[j],\r\n                        value: value\r\n                    });\r\n                }\r\n                else if (lastAnimation) {\r\n                    lastAnimation.getKeys()[j].value = value;\r\n                }\r\n            }\r\n\r\n            // Finish\r\n            if (!modifyKey && babylonAnimation) {\r\n                babylonAnimation.setKeys(keys);\r\n                targetNode.animations.push(babylonAnimation);\r\n            }\r\n\r\n            lastAnimation = babylonAnimation;\r\n\r\n            gltfRuntime.scene.stopAnimation(targetNode);\r\n            gltfRuntime.scene.beginAnimation(targetNode, 0, bufferInput[bufferInput.length - 1], true, 1.0);\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n* Returns the bones transformation matrix\r\n*/\r\nvar configureBoneTransformation = (node: IGLTFNode): Matrix => {\r\n    var mat: Nullable<Matrix> = null;\r\n\r\n    if (node.translation || node.rotation || node.scale) {\r\n        var scale = Vector3.FromArray(node.scale || [1, 1, 1]);\r\n        var rotation = Quaternion.FromArray(node.rotation || [0, 0, 0, 1]);\r\n        var position = Vector3.FromArray(node.translation || [0, 0, 0]);\r\n\r\n        mat = Matrix.Compose(scale, rotation, position);\r\n    }\r\n    else {\r\n        mat = Matrix.FromArray(node.matrix);\r\n    }\r\n\r\n    return mat;\r\n};\r\n\r\n/**\r\n* Returns the parent bone\r\n*/\r\nvar getParentBone = (gltfRuntime: IGLTFRuntime, skins: IGLTFSkins, jointName: string, newSkeleton: Skeleton): Nullable<Bone> => {\r\n    // Try to find\r\n    for (var i = 0; i < newSkeleton.bones.length; i++) {\r\n        if (newSkeleton.bones[i].name === jointName) {\r\n            return newSkeleton.bones[i];\r\n        }\r\n    }\r\n\r\n    // Not found, search in gltf nodes\r\n    var nodes = gltfRuntime.nodes;\r\n    for (var nde in nodes) {\r\n        var node: IGLTFNode = nodes[nde];\r\n\r\n        if (!node.jointName) {\r\n            continue;\r\n        }\r\n\r\n        var children = node.children;\r\n        for (var i = 0; i < children.length; i++) {\r\n            var child: IGLTFNode = gltfRuntime.nodes[children[i]];\r\n            if (!child.jointName) {\r\n                continue;\r\n            }\r\n\r\n            if (child.jointName === jointName) {\r\n                var mat = configureBoneTransformation(node);\r\n                var bone = new Bone(node.name || \"\", newSkeleton, getParentBone(gltfRuntime, skins, node.jointName, newSkeleton), mat);\r\n                bone.id = nde;\r\n                return bone;\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n* Returns the appropriate root node\r\n*/\r\nvar getNodeToRoot = (nodesToRoot: INodeToRoot[], id: string): Nullable<Bone> => {\r\n    for (var i = 0; i < nodesToRoot.length; i++) {\r\n        var nodeToRoot = nodesToRoot[i];\r\n\r\n        for (var j = 0; j < nodeToRoot.node.children.length; j++) {\r\n            var child = nodeToRoot.node.children[j];\r\n            if (child === id) {\r\n                return nodeToRoot.bone;\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n* Returns the node with the joint name\r\n*/\r\nvar getJointNode = (gltfRuntime: IGLTFRuntime, jointName: string): Nullable<IJointNode> => {\r\n    var nodes = gltfRuntime.nodes;\r\n    var node: IGLTFNode = nodes[jointName];\r\n    if (node) {\r\n        return {\r\n            node: node,\r\n            id: jointName\r\n        };\r\n    }\r\n\r\n    for (var nde in nodes) {\r\n        node = nodes[nde];\r\n        if (node.jointName === jointName) {\r\n            return {\r\n                node: node,\r\n                id: nde\r\n            };\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n* Checks if a nodes is in joints\r\n*/\r\nvar nodeIsInJoints = (skins: IGLTFSkins, id: string): boolean => {\r\n    for (var i = 0; i < skins.jointNames.length; i++) {\r\n        if (skins.jointNames[i] === id) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n};\r\n\r\n/**\r\n* Fills the nodes to root for bones and builds hierarchy\r\n*/\r\nvar getNodesToRoot = (gltfRuntime: IGLTFRuntime, newSkeleton: Skeleton, skins: IGLTFSkins, nodesToRoot: INodeToRoot[]) => {\r\n    // Creates nodes for root\r\n    for (var nde in gltfRuntime.nodes) {\r\n        var node: IGLTFNode = gltfRuntime.nodes[nde];\r\n        var id = nde;\r\n\r\n        if (!node.jointName || nodeIsInJoints(skins, node.jointName)) {\r\n            continue;\r\n        }\r\n\r\n        // Create node to root bone\r\n        var mat = configureBoneTransformation(node);\r\n        var bone = new Bone(node.name || \"\", newSkeleton, null, mat);\r\n        bone.id = id;\r\n        nodesToRoot.push({ bone: bone, node: node, id: id });\r\n    }\r\n\r\n    // Parenting\r\n    for (var i = 0; i < nodesToRoot.length; i++) {\r\n        var nodeToRoot = nodesToRoot[i];\r\n        var children = nodeToRoot.node.children;\r\n\r\n        for (var j = 0; j < children.length; j++) {\r\n            var child: Nullable<INodeToRoot> = null;\r\n\r\n            for (var k = 0; k < nodesToRoot.length; k++) {\r\n                if (nodesToRoot[k].id === children[j]) {\r\n                    child = nodesToRoot[k];\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (child) {\r\n                (<any>child.bone)._parent = nodeToRoot.bone;\r\n                nodeToRoot.bone.children.push(child.bone);\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n* Imports a skeleton\r\n*/\r\nvar importSkeleton = (gltfRuntime: IGLTFRuntime, skins: IGLTFSkins, mesh: Mesh, newSkeleton: Skeleton | undefined, id: string): Skeleton => {\r\n\r\n    if (!newSkeleton) {\r\n        newSkeleton = new Skeleton(skins.name || \"\", \"\", gltfRuntime.scene);\r\n    }\r\n\r\n    if (!skins.babylonSkeleton) {\r\n        return newSkeleton;\r\n    }\r\n\r\n    // Find the root bones\r\n    var nodesToRoot: INodeToRoot[] = [];\r\n    var nodesToRootToAdd: Bone[] = [];\r\n\r\n    getNodesToRoot(gltfRuntime, newSkeleton, skins, nodesToRoot);\r\n    newSkeleton.bones = [];\r\n\r\n    // Joints\r\n    for (var i = 0; i < skins.jointNames.length; i++) {\r\n        var jointNode = getJointNode(gltfRuntime, skins.jointNames[i]);\r\n\r\n        if (!jointNode) {\r\n            continue;\r\n        }\r\n\r\n        var node = jointNode.node;\r\n\r\n        if (!node) {\r\n            Tools.Warn(\"Joint named \" + skins.jointNames[i] + \" does not exist\");\r\n            continue;\r\n        }\r\n\r\n        var id = jointNode.id;\r\n\r\n        // Optimize, if the bone already exists...\r\n        var existingBone = gltfRuntime.scene.getBoneByID(id);\r\n        if (existingBone) {\r\n            newSkeleton.bones.push(existingBone);\r\n            continue;\r\n        }\r\n\r\n        // Search for parent bone\r\n        var foundBone = false;\r\n        var parentBone: Nullable<Bone> = null;\r\n\r\n        for (var j = 0; j < i; j++) {\r\n            let jointNode = getJointNode(gltfRuntime, skins.jointNames[j]);\r\n\r\n            if (!jointNode) {\r\n                continue;\r\n            }\r\n\r\n            var joint: IGLTFNode = jointNode.node;\r\n\r\n            if (!joint) {\r\n                Tools.Warn(\"Joint named \" + skins.jointNames[j] + \" does not exist when looking for parent\");\r\n                continue;\r\n            }\r\n\r\n            var children = joint.children;\r\n            if (!children) {\r\n                continue;\r\n            }\r\n            foundBone = false;\r\n\r\n            for (var k = 0; k < children.length; k++) {\r\n                if (children[k] === id) {\r\n                    parentBone = getParentBone(gltfRuntime, skins, skins.jointNames[j], newSkeleton);\r\n                    foundBone = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (foundBone) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Create bone\r\n        var mat = configureBoneTransformation(node);\r\n\r\n        if (!parentBone && nodesToRoot.length > 0) {\r\n            parentBone = getNodeToRoot(nodesToRoot, id);\r\n\r\n            if (parentBone) {\r\n                if (nodesToRootToAdd.indexOf(parentBone) === -1) {\r\n                    nodesToRootToAdd.push(parentBone);\r\n                }\r\n            }\r\n        }\r\n\r\n        var bone = new Bone(node.jointName || \"\", newSkeleton, parentBone, mat);\r\n        bone.id = id;\r\n    }\r\n\r\n    // Polish\r\n    var bones = newSkeleton.bones;\r\n    newSkeleton.bones = [];\r\n\r\n    for (var i = 0; i < skins.jointNames.length; i++) {\r\n        var jointNode = getJointNode(gltfRuntime, skins.jointNames[i]);\r\n\r\n        if (!jointNode) {\r\n            continue;\r\n        }\r\n\r\n        for (var j = 0; j < bones.length; j++) {\r\n            if (bones[j].id === jointNode.id) {\r\n                newSkeleton.bones.push(bones[j]);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    newSkeleton.prepare();\r\n\r\n    // Finish\r\n    for (var i = 0; i < nodesToRootToAdd.length; i++) {\r\n        newSkeleton.bones.push(nodesToRootToAdd[i]);\r\n    }\r\n\r\n    return newSkeleton;\r\n};\r\n\r\n/**\r\n* Imports a mesh and its geometries\r\n*/\r\nvar importMesh = (gltfRuntime: IGLTFRuntime, node: IGLTFNode, meshes: string[], id: string, newMesh: Mesh): Mesh => {\r\n    if (!newMesh) {\r\n        gltfRuntime.scene._blockEntityCollection = gltfRuntime.forAssetContainer;\r\n        newMesh = new Mesh(node.name || \"\", gltfRuntime.scene);\r\n        gltfRuntime.scene._blockEntityCollection = false;\r\n        newMesh.id = id;\r\n    }\r\n\r\n    if (!node.babylonNode) {\r\n        return newMesh;\r\n    }\r\n\r\n    const subMaterials: Material[] = [];\r\n\r\n    var vertexData: Nullable<VertexData> = null;\r\n    var verticesStarts = new Array<number>();\r\n    var verticesCounts = new Array<number>();\r\n    var indexStarts = new Array<number>();\r\n    var indexCounts = new Array<number>();\r\n\r\n    for (var meshIndex = 0; meshIndex < meshes.length; meshIndex++) {\r\n        var meshID = meshes[meshIndex];\r\n        var mesh: IGLTFMesh = gltfRuntime.meshes[meshID];\r\n\r\n        if (!mesh) {\r\n            continue;\r\n        }\r\n\r\n        // Positions, normals and UVs\r\n        for (var i = 0; i < mesh.primitives.length; i++) {\r\n            // Temporary vertex data\r\n            var tempVertexData = new VertexData();\r\n\r\n            var primitive = mesh.primitives[i];\r\n            if (primitive.mode !== 4) {\r\n                // continue;\r\n            }\r\n\r\n            var attributes = primitive.attributes;\r\n            var accessor: Nullable<IGLTFAccessor> = null;\r\n            var buffer: any = null;\r\n\r\n            // Set positions, normal and uvs\r\n            for (var semantic in attributes) {\r\n\r\n                // Link accessor and buffer view\r\n                accessor = gltfRuntime.accessors[attributes[semantic]];\r\n                buffer = GLTFUtils.GetBufferFromAccessor(gltfRuntime, accessor);\r\n\r\n                if (semantic === \"NORMAL\") {\r\n                    tempVertexData.normals = new Float32Array(buffer.length);\r\n                    (<Float32Array>tempVertexData.normals).set(buffer);\r\n                }\r\n                else if (semantic === \"POSITION\") {\r\n                    if (GLTFFileLoader.HomogeneousCoordinates) {\r\n                        tempVertexData.positions = new Float32Array(buffer.length - buffer.length / 4);\r\n\r\n                        for (var j = 0; j < buffer.length; j += 4) {\r\n                            tempVertexData.positions[j] = buffer[j];\r\n                            tempVertexData.positions[j + 1] = buffer[j + 1];\r\n                            tempVertexData.positions[j + 2] = buffer[j + 2];\r\n                        }\r\n                    }\r\n                    else {\r\n                        tempVertexData.positions = new Float32Array(buffer.length);\r\n                        (<Float32Array>tempVertexData.positions).set(buffer);\r\n                    }\r\n\r\n                    verticesCounts.push(tempVertexData.positions.length);\r\n                }\r\n                else if (semantic.indexOf(\"TEXCOORD_\") !== -1) {\r\n                    var channel = Number(semantic.split(\"_\")[1]);\r\n                    var uvKind = VertexBuffer.UVKind + (channel === 0 ? \"\" : (channel + 1));\r\n                    var uvs = new Float32Array(buffer.length);\r\n                    (<Float32Array>uvs).set(buffer);\r\n                    normalizeUVs(uvs);\r\n                    tempVertexData.set(uvs, uvKind);\r\n                }\r\n                else if (semantic === \"JOINT\") {\r\n                    tempVertexData.matricesIndices = new Float32Array(buffer.length);\r\n                    (<Float32Array>tempVertexData.matricesIndices).set(buffer);\r\n                }\r\n                else if (semantic === \"WEIGHT\") {\r\n                    tempVertexData.matricesWeights = new Float32Array(buffer.length);\r\n                    (<Float32Array>tempVertexData.matricesWeights).set(buffer);\r\n                }\r\n                else if (semantic === \"COLOR\") {\r\n                    tempVertexData.colors = new Float32Array(buffer.length);\r\n                    (<Float32Array>tempVertexData.colors).set(buffer);\r\n                }\r\n            }\r\n\r\n            // Indices\r\n            accessor = gltfRuntime.accessors[primitive.indices];\r\n            if (accessor) {\r\n                buffer = GLTFUtils.GetBufferFromAccessor(gltfRuntime, accessor);\r\n\r\n                tempVertexData.indices = new Int32Array(buffer.length);\r\n                tempVertexData.indices.set(buffer);\r\n                indexCounts.push(tempVertexData.indices.length);\r\n            }\r\n            else {\r\n                // Set indices on the fly\r\n                var indices: number[] = [];\r\n                for (var j = 0; j < (<FloatArray>tempVertexData.positions).length / 3; j++) {\r\n                    indices.push(j);\r\n                }\r\n\r\n                tempVertexData.indices = new Int32Array(indices);\r\n                indexCounts.push(tempVertexData.indices.length);\r\n            }\r\n\r\n            if (!vertexData) {\r\n                vertexData = tempVertexData;\r\n            }\r\n            else {\r\n                vertexData.merge(tempVertexData);\r\n            }\r\n\r\n            // Sub material\r\n            let material = gltfRuntime.scene.getMaterialByID(primitive.material);\r\n\r\n            subMaterials.push(material === null ? GLTFUtils.GetDefaultMaterial(gltfRuntime.scene) : material);\r\n\r\n            // Update vertices start and index start\r\n            verticesStarts.push(verticesStarts.length === 0 ? 0 : verticesStarts[verticesStarts.length - 1] + verticesCounts[verticesCounts.length - 2]);\r\n            indexStarts.push(indexStarts.length === 0 ? 0 : indexStarts[indexStarts.length - 1] + indexCounts[indexCounts.length - 2]);\r\n        }\r\n    }\r\n    let material: StandardMaterial | MultiMaterial;\r\n    gltfRuntime.scene._blockEntityCollection = gltfRuntime.forAssetContainer;\r\n    if (subMaterials.length > 1) {\r\n        material = new MultiMaterial(\"multimat\" + id, gltfRuntime.scene);\r\n        (material as MultiMaterial).subMaterials = subMaterials;\r\n    }\r\n    else {\r\n        material = new StandardMaterial(\"multimat\" + id, gltfRuntime.scene);\r\n    }\r\n\r\n    if (subMaterials.length === 1) {\r\n        material = (subMaterials[0] as StandardMaterial);\r\n    }\r\n\r\n    if (!newMesh.material) {\r\n        newMesh.material = material;\r\n    }\r\n\r\n    // Apply geometry\r\n    new Geometry(id, gltfRuntime.scene, vertexData!, false, newMesh);\r\n    newMesh.computeWorldMatrix(true);\r\n\r\n    gltfRuntime.scene._blockEntityCollection = false;\r\n\r\n    // Apply submeshes\r\n    newMesh.subMeshes = [];\r\n    var index = 0;\r\n    for (var meshIndex = 0; meshIndex < meshes.length; meshIndex++) {\r\n        var meshID = meshes[meshIndex];\r\n        var mesh: IGLTFMesh = gltfRuntime.meshes[meshID];\r\n\r\n        if (!mesh) {\r\n            continue;\r\n        }\r\n\r\n        for (var i = 0; i < mesh.primitives.length; i++) {\r\n            if (mesh.primitives[i].mode !== 4) {\r\n                //continue;\r\n            }\r\n\r\n            SubMesh.AddToMesh(index, verticesStarts[index], verticesCounts[index], indexStarts[index], indexCounts[index], newMesh, newMesh, true);\r\n            index++;\r\n        }\r\n    }\r\n\r\n    // Finish\r\n    return newMesh;\r\n};\r\n\r\n/**\r\n* Configure node transformation from position, rotation and scaling\r\n*/\r\nvar configureNode = (newNode: any, position: Vector3, rotation: Quaternion, scaling: Vector3) => {\r\n    if (newNode.position) {\r\n        newNode.position = position;\r\n    }\r\n\r\n    if (newNode.rotationQuaternion || newNode.rotation) {\r\n        newNode.rotationQuaternion = rotation;\r\n    }\r\n\r\n    if (newNode.scaling) {\r\n        newNode.scaling = scaling;\r\n    }\r\n};\r\n\r\n/**\r\n* Configures node from transformation matrix\r\n*/\r\nvar configureNodeFromMatrix = (newNode: Mesh, node: IGLTFNode, parent: Nullable<Node>) => {\r\n    if (node.matrix) {\r\n        var position = new Vector3(0, 0, 0);\r\n        var rotation = new Quaternion();\r\n        var scaling = new Vector3(0, 0, 0);\r\n        var mat = Matrix.FromArray(node.matrix);\r\n        mat.decompose(scaling, rotation, position);\r\n\r\n        configureNode(newNode, position, rotation, scaling);\r\n    }\r\n    else if (node.translation && node.rotation && node.scale) {\r\n        configureNode(newNode, Vector3.FromArray(node.translation), Quaternion.FromArray(node.rotation), Vector3.FromArray(node.scale));\r\n    }\r\n\r\n    newNode.computeWorldMatrix(true);\r\n};\r\n\r\n/**\r\n* Imports a node\r\n*/\r\nvar importNode = (gltfRuntime: IGLTFRuntime, node: IGLTFNode, id: string, parent: Nullable<Node>): Nullable<Node> => {\r\n    var lastNode: Nullable<Node> = null;\r\n\r\n    if (gltfRuntime.importOnlyMeshes && (node.skin || node.meshes)) {\r\n        if (gltfRuntime.importMeshesNames && gltfRuntime.importMeshesNames.length > 0 && gltfRuntime.importMeshesNames.indexOf(node.name || \"\") === -1) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // Meshes\r\n    if (node.skin) {\r\n        if (node.meshes) {\r\n            var skin: IGLTFSkins = gltfRuntime.skins[node.skin];\r\n\r\n            var newMesh = importMesh(gltfRuntime, node, node.meshes, id, <Mesh>node.babylonNode);\r\n            newMesh.skeleton = gltfRuntime.scene.getLastSkeletonByID(node.skin);\r\n\r\n            if (newMesh.skeleton === null) {\r\n                newMesh.skeleton = importSkeleton(gltfRuntime, skin, newMesh, skin.babylonSkeleton, node.skin);\r\n\r\n                if (!skin.babylonSkeleton) {\r\n                    skin.babylonSkeleton = newMesh.skeleton;\r\n                }\r\n            }\r\n\r\n            lastNode = newMesh;\r\n        }\r\n    }\r\n    else if (node.meshes) {\r\n        /**\r\n        * Improve meshes property\r\n        */\r\n        var newMesh = importMesh(gltfRuntime, node, node.mesh ? [node.mesh] : node.meshes, id, <Mesh>node.babylonNode);\r\n        lastNode = newMesh;\r\n    }\r\n    // Lights\r\n    else if (node.light && !node.babylonNode && !gltfRuntime.importOnlyMeshes) {\r\n        var light: IGLTFLight = gltfRuntime.lights[node.light];\r\n\r\n        if (light) {\r\n            if (light.type === \"ambient\") {\r\n                var ambienLight: IGLTFAmbienLight = (<any>light)[light.type];\r\n                var hemiLight = new HemisphericLight(node.light, Vector3.Zero(), gltfRuntime.scene);\r\n                hemiLight.name = node.name || \"\";\r\n\r\n                if (ambienLight.color) {\r\n                    hemiLight.diffuse = Color3.FromArray(ambienLight.color);\r\n                }\r\n\r\n                lastNode = hemiLight;\r\n            }\r\n            else if (light.type === \"directional\") {\r\n                var directionalLight: IGLTFDirectionalLight = (<any>light)[light.type];\r\n                var dirLight = new DirectionalLight(node.light, Vector3.Zero(), gltfRuntime.scene);\r\n                dirLight.name = node.name || \"\";\r\n\r\n                if (directionalLight.color) {\r\n                    dirLight.diffuse = Color3.FromArray(directionalLight.color);\r\n                }\r\n\r\n                lastNode = dirLight;\r\n            }\r\n            else if (light.type === \"point\") {\r\n                var pointLight: IGLTFPointLight = (<any>light)[light.type];\r\n                var ptLight = new PointLight(node.light, Vector3.Zero(), gltfRuntime.scene);\r\n                ptLight.name = node.name || \"\";\r\n\r\n                if (pointLight.color) {\r\n                    ptLight.diffuse = Color3.FromArray(pointLight.color);\r\n                }\r\n\r\n                lastNode = ptLight;\r\n            }\r\n            else if (light.type === \"spot\") {\r\n                var spotLight: IGLTFSpotLight = (<any>light)[light.type];\r\n                var spLight = new SpotLight(node.light, Vector3.Zero(), Vector3.Zero(), 0, 0, gltfRuntime.scene);\r\n                spLight.name = node.name || \"\";\r\n\r\n                if (spotLight.color) {\r\n                    spLight.diffuse = Color3.FromArray(spotLight.color);\r\n                }\r\n\r\n                if (spotLight.fallOfAngle) {\r\n                    spLight.angle = spotLight.fallOfAngle;\r\n                }\r\n\r\n                if (spotLight.fallOffExponent) {\r\n                    spLight.exponent = spotLight.fallOffExponent;\r\n                }\r\n\r\n                lastNode = spLight;\r\n            }\r\n        }\r\n    }\r\n    // Cameras\r\n    else if (node.camera && !node.babylonNode && !gltfRuntime.importOnlyMeshes) {\r\n        var camera: IGLTFCamera = gltfRuntime.cameras[node.camera];\r\n\r\n        if (camera) {\r\n\r\n            gltfRuntime.scene._blockEntityCollection = gltfRuntime.forAssetContainer;\r\n            if (camera.type === \"orthographic\") {\r\n                var orthoCamera = new FreeCamera(node.camera, Vector3.Zero(), gltfRuntime.scene, false);\r\n\r\n                orthoCamera.name = node.name || \"\";\r\n                orthoCamera.mode = Camera.ORTHOGRAPHIC_CAMERA;\r\n                orthoCamera.attachControl(<HTMLElement>gltfRuntime.scene.getEngine().getInputElement());\r\n\r\n                lastNode = orthoCamera;\r\n            }\r\n            else if (camera.type === \"perspective\") {\r\n                var perspectiveCamera: IGLTFCameraPerspective = (<any>camera)[camera.type];\r\n                var persCamera = new FreeCamera(node.camera, Vector3.Zero(), gltfRuntime.scene, false);\r\n\r\n                persCamera.name = node.name || \"\";\r\n                persCamera.attachControl(<HTMLElement>gltfRuntime.scene.getEngine().getInputElement());\r\n\r\n                if (!perspectiveCamera.aspectRatio) {\r\n                    perspectiveCamera.aspectRatio = gltfRuntime.scene.getEngine().getRenderWidth() / gltfRuntime.scene.getEngine().getRenderHeight();\r\n                }\r\n\r\n                if (perspectiveCamera.znear && perspectiveCamera.zfar) {\r\n                    persCamera.maxZ = perspectiveCamera.zfar;\r\n                    persCamera.minZ = perspectiveCamera.znear;\r\n                }\r\n\r\n                lastNode = persCamera;\r\n            }\r\n\r\n            gltfRuntime.scene._blockEntityCollection = false;\r\n        }\r\n    }\r\n\r\n    // Empty node\r\n    if (!node.jointName) {\r\n        if (node.babylonNode) {\r\n            return node.babylonNode;\r\n        }\r\n        else if (lastNode === null) {\r\n            gltfRuntime.scene._blockEntityCollection = gltfRuntime.forAssetContainer;\r\n            var dummy = new Mesh(node.name || \"\", gltfRuntime.scene);\r\n            gltfRuntime.scene._blockEntityCollection = false;\r\n            node.babylonNode = dummy;\r\n            lastNode = dummy;\r\n        }\r\n    }\r\n\r\n    if (lastNode !== null) {\r\n        if (node.matrix && lastNode instanceof Mesh) {\r\n            configureNodeFromMatrix(lastNode, node, parent);\r\n        }\r\n        else {\r\n            var translation = node.translation || [0, 0, 0];\r\n            var rotation = node.rotation || [0, 0, 0, 1];\r\n            var scale = node.scale || [1, 1, 1];\r\n            configureNode(lastNode, Vector3.FromArray(translation), Quaternion.FromArray(rotation), Vector3.FromArray(scale));\r\n        }\r\n\r\n        lastNode.updateCache(true);\r\n        node.babylonNode = lastNode;\r\n    }\r\n\r\n    return lastNode;\r\n};\r\n\r\n/**\r\n* Traverses nodes and creates them\r\n*/\r\nvar traverseNodes = (gltfRuntime: IGLTFRuntime, id: string, parent: Nullable<Node>, meshIncluded: boolean = false) => {\r\n    var node: IGLTFNode = gltfRuntime.nodes[id];\r\n    var newNode: Nullable<Node> = null;\r\n\r\n    if (gltfRuntime.importOnlyMeshes && !meshIncluded && gltfRuntime.importMeshesNames) {\r\n        if (gltfRuntime.importMeshesNames.indexOf(node.name || \"\") !== -1 || gltfRuntime.importMeshesNames.length === 0) {\r\n            meshIncluded = true;\r\n        }\r\n        else {\r\n            meshIncluded = false;\r\n        }\r\n    }\r\n    else {\r\n        meshIncluded = true;\r\n    }\r\n\r\n    if (!node.jointName && meshIncluded) {\r\n        newNode = importNode(gltfRuntime, node, id, parent);\r\n\r\n        if (newNode !== null) {\r\n            newNode.id = id;\r\n            newNode.parent = parent;\r\n        }\r\n    }\r\n\r\n    if (node.children) {\r\n        for (var i = 0; i < node.children.length; i++) {\r\n            traverseNodes(gltfRuntime, node.children[i], newNode, meshIncluded);\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n* do stuff after buffers, shaders are loaded (e.g. hook up materials, load animations, etc.)\r\n*/\r\nvar postLoad = (gltfRuntime: IGLTFRuntime) => {\r\n    // Nodes\r\n    var currentScene: IGLTFScene = <IGLTFScene>gltfRuntime.currentScene;\r\n\r\n    if (currentScene) {\r\n        for (var i = 0; i < currentScene.nodes.length; i++) {\r\n            traverseNodes(gltfRuntime, currentScene.nodes[i], null);\r\n        }\r\n    }\r\n    else {\r\n        for (var thing in gltfRuntime.scenes) {\r\n            currentScene = <IGLTFScene>gltfRuntime.scenes[thing];\r\n\r\n            for (var i = 0; i < currentScene.nodes.length; i++) {\r\n                traverseNodes(gltfRuntime, currentScene.nodes[i], null);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Set animations\r\n    loadAnimations(gltfRuntime);\r\n\r\n    for (var i = 0; i < gltfRuntime.scene.skeletons.length; i++) {\r\n        var skeleton = gltfRuntime.scene.skeletons[i];\r\n        gltfRuntime.scene.beginAnimation(skeleton, 0, Number.MAX_VALUE, true, 1.0);\r\n    }\r\n};\r\n\r\n/**\r\n* onBind shaderrs callback to set uniforms and matrices\r\n*/\r\nvar onBindShaderMaterial = (mesh: AbstractMesh, gltfRuntime: IGLTFRuntime, unTreatedUniforms: { [key: string]: IGLTFTechniqueParameter }, shaderMaterial: ShaderMaterial, technique: IGLTFTechnique, material: IGLTFMaterial, onSuccess: (shaderMaterial: ShaderMaterial) => void) => {\r\n    var materialValues = material.values || technique.parameters;\r\n\r\n    for (var unif in unTreatedUniforms) {\r\n        var uniform: IGLTFTechniqueParameter = unTreatedUniforms[unif];\r\n        var type = uniform.type;\r\n\r\n        if (type === EParameterType.FLOAT_MAT2 || type === EParameterType.FLOAT_MAT3 || type === EParameterType.FLOAT_MAT4) {\r\n            if (uniform.semantic && !uniform.source && !uniform.node) {\r\n                GLTFUtils.SetMatrix(gltfRuntime.scene, mesh, uniform, unif, <Effect>shaderMaterial.getEffect());\r\n            }\r\n            else if (uniform.semantic && (uniform.source || uniform.node)) {\r\n                var source = gltfRuntime.scene.getNodeByName(uniform.source || uniform.node || \"\");\r\n                if (source === null) {\r\n                    source = gltfRuntime.scene.getNodeByID(uniform.source || uniform.node || \"\");\r\n                }\r\n                if (source === null) {\r\n                    continue;\r\n                }\r\n\r\n                GLTFUtils.SetMatrix(gltfRuntime.scene, source, uniform, unif, <Effect>shaderMaterial.getEffect());\r\n            }\r\n        }\r\n        else {\r\n            var value = (<any>materialValues)[technique.uniforms[unif]];\r\n            if (!value) {\r\n                continue;\r\n            }\r\n\r\n            if (type === EParameterType.SAMPLER_2D) {\r\n                var texture = gltfRuntime.textures[material.values ? value : uniform.value].babylonTexture;\r\n\r\n                if (texture === null || texture === undefined) {\r\n                    continue;\r\n                }\r\n\r\n                (<Effect>shaderMaterial.getEffect()).setTexture(unif, texture);\r\n            }\r\n            else {\r\n                GLTFUtils.SetUniform(<Effect>(shaderMaterial.getEffect()), unif, value, type);\r\n            }\r\n        }\r\n    }\r\n\r\n    onSuccess(shaderMaterial);\r\n};\r\n\r\n/**\r\n* Prepare uniforms to send the only one time\r\n* Loads the appropriate textures\r\n*/\r\nvar prepareShaderMaterialUniforms = (gltfRuntime: IGLTFRuntime, shaderMaterial: ShaderMaterial, technique: IGLTFTechnique, material: IGLTFMaterial, unTreatedUniforms: { [key: string]: IGLTFTechniqueParameter }) => {\r\n    var materialValues = material.values || technique.parameters;\r\n    var techniqueUniforms = technique.uniforms;\r\n\r\n    /**\r\n    * Prepare values here (not matrices)\r\n    */\r\n    for (var unif in unTreatedUniforms) {\r\n        var uniform: IGLTFTechniqueParameter = unTreatedUniforms[unif];\r\n        var type = uniform.type;\r\n        var value = (<any>materialValues)[techniqueUniforms[unif]];\r\n\r\n        if (value === undefined) {\r\n            // In case the value is the same for all materials\r\n            value = <any>uniform.value;\r\n        }\r\n\r\n        if (!value) {\r\n            continue;\r\n        }\r\n\r\n        var onLoadTexture = (uniformName: Nullable<string>) => {\r\n            return (texture: Texture) => {\r\n                if (uniform.value && uniformName) {\r\n                    // Static uniform\r\n                    shaderMaterial.setTexture(uniformName, texture);\r\n                    delete unTreatedUniforms[uniformName];\r\n                }\r\n            };\r\n        };\r\n\r\n        // Texture (sampler2D)\r\n        if (type === EParameterType.SAMPLER_2D) {\r\n            GLTFLoaderExtension.LoadTextureAsync(gltfRuntime, material.values ? value : uniform.value, onLoadTexture(unif), () => onLoadTexture(null));\r\n        }\r\n        // Others\r\n        else {\r\n            if (uniform.value && GLTFUtils.SetUniform(shaderMaterial, unif, material.values ? value : uniform.value, type)) {\r\n                // Static uniform\r\n                delete unTreatedUniforms[unif];\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n* Shader compilation failed\r\n*/\r\nvar onShaderCompileError = (program: IGLTFProgram, shaderMaterial: ShaderMaterial, onError: (message: string) => void) => {\r\n    return (effect: Effect, error: string) => {\r\n        shaderMaterial.dispose(true);\r\n        onError(\"Cannot compile program named \" + program.name + \". Error: \" + error + \". Default material will be applied\");\r\n    };\r\n};\r\n\r\n/**\r\n* Shader compilation success\r\n*/\r\nvar onShaderCompileSuccess = (gltfRuntime: IGLTFRuntime, shaderMaterial: ShaderMaterial, technique: IGLTFTechnique, material: IGLTFMaterial, unTreatedUniforms: { [key: string]: IGLTFTechniqueParameter }, onSuccess: (shaderMaterial: ShaderMaterial) => void) => {\r\n    return (_: Effect) => {\r\n        prepareShaderMaterialUniforms(gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms);\r\n\r\n        shaderMaterial.onBind = (mesh: AbstractMesh) => {\r\n            onBindShaderMaterial(mesh, gltfRuntime, unTreatedUniforms, shaderMaterial, technique, material, onSuccess);\r\n        };\r\n    };\r\n};\r\n\r\n/**\r\n* Returns the appropriate uniform if already handled by babylon\r\n*/\r\nvar parseShaderUniforms = (tokenizer: Tokenizer, technique: IGLTFTechnique, unTreatedUniforms: { [key: string]: IGLTFTechniqueParameter }): string => {\r\n    for (var unif in technique.uniforms) {\r\n        var uniform = technique.uniforms[unif];\r\n        var uniformParameter: IGLTFTechniqueParameter = technique.parameters[uniform];\r\n\r\n        if (tokenizer.currentIdentifier === unif) {\r\n            if (uniformParameter.semantic && !uniformParameter.source && !uniformParameter.node) {\r\n                var transformIndex = glTFTransforms.indexOf(uniformParameter.semantic);\r\n\r\n                if (transformIndex !== -1) {\r\n                    delete unTreatedUniforms[unif];\r\n                    return babylonTransforms[transformIndex];\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return tokenizer.currentIdentifier;\r\n};\r\n\r\n/**\r\n* All shaders loaded. Create materials one by one\r\n*/\r\nvar importMaterials = (gltfRuntime: IGLTFRuntime) => {\r\n    // Create materials\r\n    for (var mat in gltfRuntime.materials) {\r\n        GLTFLoaderExtension.LoadMaterialAsync(gltfRuntime, mat, (material: Material) => { }, () => { });\r\n    }\r\n};\r\n\r\n/**\r\n* Implementation of the base glTF spec\r\n* @hidden\r\n*/\r\nexport class GLTFLoaderBase {\r\n    public static CreateRuntime(parsedData: any, scene: Scene, rootUrl: string): IGLTFRuntime {\r\n        var gltfRuntime: IGLTFRuntime = {\r\n            extensions: {},\r\n            accessors: {},\r\n            buffers: {},\r\n            bufferViews: {},\r\n            meshes: {},\r\n            lights: {},\r\n            cameras: {},\r\n            nodes: {},\r\n            images: {},\r\n            textures: {},\r\n            shaders: {},\r\n            programs: {},\r\n            samplers: {},\r\n            techniques: {},\r\n            materials: {},\r\n            animations: {},\r\n            skins: {},\r\n            extensionsUsed: [],\r\n\r\n            scenes: {},\r\n\r\n            buffersCount: 0,\r\n            shaderscount: 0,\r\n\r\n            scene: scene,\r\n            rootUrl: rootUrl,\r\n\r\n            loadedBufferCount: 0,\r\n            loadedBufferViews: {},\r\n\r\n            loadedShaderCount: 0,\r\n\r\n            importOnlyMeshes: false,\r\n\r\n            dummyNodes: [],\r\n\r\n            forAssetContainer: false\r\n        };\r\n\r\n        // Parse\r\n        if (parsedData.extensions) {\r\n            parseObject(parsedData.extensions, \"extensions\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.extensionsUsed) {\r\n            parseObject(parsedData.extensionsUsed, \"extensionsUsed\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.buffers) {\r\n            parseBuffers(parsedData.buffers, gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.bufferViews) {\r\n            parseObject(parsedData.bufferViews, \"bufferViews\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.accessors) {\r\n            parseObject(parsedData.accessors, \"accessors\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.meshes) {\r\n            parseObject(parsedData.meshes, \"meshes\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.lights) {\r\n            parseObject(parsedData.lights, \"lights\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.cameras) {\r\n            parseObject(parsedData.cameras, \"cameras\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.nodes) {\r\n            parseObject(parsedData.nodes, \"nodes\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.images) {\r\n            parseObject(parsedData.images, \"images\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.textures) {\r\n            parseObject(parsedData.textures, \"textures\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.shaders) {\r\n            parseShaders(parsedData.shaders, gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.programs) {\r\n            parseObject(parsedData.programs, \"programs\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.samplers) {\r\n            parseObject(parsedData.samplers, \"samplers\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.techniques) {\r\n            parseObject(parsedData.techniques, \"techniques\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.materials) {\r\n            parseObject(parsedData.materials, \"materials\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.animations) {\r\n            parseObject(parsedData.animations, \"animations\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.skins) {\r\n            parseObject(parsedData.skins, \"skins\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.scenes) {\r\n            gltfRuntime.scenes = parsedData.scenes;\r\n        }\r\n\r\n        if (parsedData.scene && parsedData.scenes) {\r\n            gltfRuntime.currentScene = parsedData.scenes[parsedData.scene];\r\n        }\r\n\r\n        return gltfRuntime;\r\n    }\r\n\r\n    public static LoadBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (buffer: ArrayBufferView) => void, onError: (message: string) => void, onProgress?: () => void): void {\r\n        var buffer: IGLTFBuffer = gltfRuntime.buffers[id];\r\n\r\n        if (Tools.IsBase64(buffer.uri)) {\r\n            setTimeout(() => onSuccess(new Uint8Array(Tools.DecodeBase64(buffer.uri))));\r\n        }\r\n        else {\r\n            Tools.LoadFile(gltfRuntime.rootUrl + buffer.uri, (data) => onSuccess(new Uint8Array(data as ArrayBuffer)), onProgress, undefined, true, (request) => {\r\n                if (request) {\r\n                    onError(request.status + \" \" + request.statusText);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    public static LoadTextureBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (buffer: Nullable<ArrayBufferView>) => void, onError: (message: string) => void): void {\r\n        var texture: IGLTFTexture = gltfRuntime.textures[id];\r\n\r\n        if (!texture || !texture.source) {\r\n            onError(\"\");\r\n            return;\r\n        }\r\n\r\n        if (texture.babylonTexture) {\r\n            onSuccess(null);\r\n            return;\r\n        }\r\n\r\n        var source: IGLTFImage = gltfRuntime.images[texture.source];\r\n\r\n        if (Tools.IsBase64(source.uri)) {\r\n            setTimeout(() => onSuccess(new Uint8Array(Tools.DecodeBase64(source.uri))));\r\n        }\r\n        else {\r\n            Tools.LoadFile(gltfRuntime.rootUrl + source.uri, (data) => onSuccess(new Uint8Array(data as ArrayBuffer)), undefined, undefined, true, (request) => {\r\n                if (request) {\r\n                    onError(request.status + \" \" + request.statusText);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    public static CreateTextureAsync(gltfRuntime: IGLTFRuntime, id: string, buffer: Nullable<ArrayBufferView>, onSuccess: (texture: Texture) => void, onError: (message: string) => void): void {\r\n        var texture: IGLTFTexture = gltfRuntime.textures[id];\r\n\r\n        if (texture.babylonTexture) {\r\n            onSuccess(texture.babylonTexture);\r\n            return;\r\n        }\r\n\r\n        var sampler: IGLTFSampler = gltfRuntime.samplers[texture.sampler];\r\n\r\n        var createMipMaps =\r\n            (sampler.minFilter === ETextureFilterType.NEAREST_MIPMAP_NEAREST) ||\r\n            (sampler.minFilter === ETextureFilterType.NEAREST_MIPMAP_LINEAR) ||\r\n            (sampler.minFilter === ETextureFilterType.LINEAR_MIPMAP_NEAREST) ||\r\n            (sampler.minFilter === ETextureFilterType.LINEAR_MIPMAP_LINEAR);\r\n\r\n        var samplingMode = Texture.BILINEAR_SAMPLINGMODE;\r\n\r\n        var blob = buffer == null ? new Blob() : new Blob([buffer]);\r\n        var blobURL = URL.createObjectURL(blob);\r\n        var revokeBlobURL = () => URL.revokeObjectURL(blobURL);\r\n        var newTexture = new Texture(blobURL, gltfRuntime.scene, !createMipMaps, true, samplingMode, revokeBlobURL, revokeBlobURL);\r\n        if (sampler.wrapS !== undefined) {\r\n            newTexture.wrapU = GLTFUtils.GetWrapMode(sampler.wrapS);\r\n        }\r\n        if (sampler.wrapT !== undefined) {\r\n            newTexture.wrapV = GLTFUtils.GetWrapMode(sampler.wrapT);\r\n        }\r\n        newTexture.name = id;\r\n\r\n        texture.babylonTexture = newTexture;\r\n        onSuccess(newTexture);\r\n    }\r\n\r\n    public static LoadShaderStringAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (shaderString: string | ArrayBuffer) => void, onError?: (message: string) => void): void {\r\n        var shader: IGLTFShader = gltfRuntime.shaders[id];\r\n\r\n        if (Tools.IsBase64(shader.uri)) {\r\n            var shaderString = atob(shader.uri.split(\",\")[1]);\r\n            if (onSuccess) {\r\n                onSuccess(shaderString);\r\n            }\r\n        }\r\n        else {\r\n            Tools.LoadFile(gltfRuntime.rootUrl + shader.uri, onSuccess, undefined, undefined, false, (request) => {\r\n                if (request && onError) {\r\n                    onError(request.status + \" \" + request.statusText);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    public static LoadMaterialAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (material: Material) => void, onError: (message: string) => void): void {\r\n        var material: IGLTFMaterial = gltfRuntime.materials[id];\r\n        if (!material.technique) {\r\n            if (onError) {\r\n                onError(\"No technique found.\");\r\n            }\r\n            return;\r\n        }\r\n\r\n        var technique: IGLTFTechnique = gltfRuntime.techniques[material.technique];\r\n        if (!technique) {\r\n            gltfRuntime.scene._blockEntityCollection = gltfRuntime.forAssetContainer;\r\n            var defaultMaterial = new StandardMaterial(id, gltfRuntime.scene);\r\n            gltfRuntime.scene._blockEntityCollection = false;\r\n            defaultMaterial.diffuseColor = new Color3(0.5, 0.5, 0.5);\r\n            defaultMaterial.sideOrientation = Material.CounterClockWiseSideOrientation;\r\n            onSuccess(defaultMaterial);\r\n            return;\r\n        }\r\n\r\n        var program: IGLTFProgram = gltfRuntime.programs[technique.program];\r\n        var states: IGLTFTechniqueStates = technique.states;\r\n\r\n        var vertexShader: string = Effect.ShadersStore[program.vertexShader + \"VertexShader\"];\r\n        var pixelShader: string = Effect.ShadersStore[program.fragmentShader + \"PixelShader\"];\r\n        var newVertexShader = \"\";\r\n        var newPixelShader = \"\";\r\n\r\n        var vertexTokenizer = new Tokenizer(vertexShader);\r\n        var pixelTokenizer = new Tokenizer(pixelShader);\r\n\r\n        var unTreatedUniforms: { [key: string]: IGLTFTechniqueParameter } = {};\r\n        var uniforms: string[] = [];\r\n        var attributes: string[] = [];\r\n        var samplers: string[] = [];\r\n\r\n        // Fill uniform, sampler2D and attributes\r\n        for (var unif in technique.uniforms) {\r\n            var uniform = technique.uniforms[unif];\r\n            var uniformParameter: IGLTFTechniqueParameter = technique.parameters[uniform];\r\n\r\n            unTreatedUniforms[unif] = uniformParameter;\r\n\r\n            if (uniformParameter.semantic && !uniformParameter.node && !uniformParameter.source) {\r\n                var transformIndex = glTFTransforms.indexOf(uniformParameter.semantic);\r\n                if (transformIndex !== -1) {\r\n                    uniforms.push(babylonTransforms[transformIndex]);\r\n                    delete unTreatedUniforms[unif];\r\n                }\r\n                else {\r\n                    uniforms.push(unif);\r\n                }\r\n            }\r\n            else if (uniformParameter.type === EParameterType.SAMPLER_2D) {\r\n                samplers.push(unif);\r\n            }\r\n            else {\r\n                uniforms.push(unif);\r\n            }\r\n        }\r\n\r\n        for (var attr in technique.attributes) {\r\n            var attribute = technique.attributes[attr];\r\n            var attributeParameter: IGLTFTechniqueParameter = technique.parameters[attribute];\r\n\r\n            if (attributeParameter.semantic) {\r\n                let name = getAttribute(attributeParameter);\r\n                if (name) {\r\n                    attributes.push(name);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Configure vertex shader\r\n        while (!vertexTokenizer.isEnd() && vertexTokenizer.getNextToken()) {\r\n            var tokenType = vertexTokenizer.currentToken;\r\n\r\n            if (tokenType !== ETokenType.IDENTIFIER) {\r\n                newVertexShader += vertexTokenizer.currentString;\r\n                continue;\r\n            }\r\n\r\n            var foundAttribute = false;\r\n\r\n            for (var attr in technique.attributes) {\r\n                var attribute = technique.attributes[attr];\r\n                var attributeParameter: IGLTFTechniqueParameter = technique.parameters[attribute];\r\n\r\n                if (vertexTokenizer.currentIdentifier === attr && attributeParameter.semantic) {\r\n                    newVertexShader += getAttribute(attributeParameter);\r\n                    foundAttribute = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (foundAttribute) {\r\n                continue;\r\n            }\r\n\r\n            newVertexShader += parseShaderUniforms(vertexTokenizer, technique, unTreatedUniforms);\r\n        }\r\n\r\n        // Configure pixel shader\r\n        while (!pixelTokenizer.isEnd() && pixelTokenizer.getNextToken()) {\r\n            var tokenType = pixelTokenizer.currentToken;\r\n\r\n            if (tokenType !== ETokenType.IDENTIFIER) {\r\n                newPixelShader += pixelTokenizer.currentString;\r\n                continue;\r\n            }\r\n\r\n            newPixelShader += parseShaderUniforms(pixelTokenizer, technique, unTreatedUniforms);\r\n        }\r\n\r\n        // Create shader material\r\n        var shaderPath = {\r\n            vertex: program.vertexShader + id,\r\n            fragment: program.fragmentShader + id\r\n        };\r\n\r\n        var options = {\r\n            attributes: attributes,\r\n            uniforms: uniforms,\r\n            samplers: samplers,\r\n            needAlphaBlending: states && states.enable && states.enable.indexOf(3042) !== -1\r\n        };\r\n\r\n        Effect.ShadersStore[program.vertexShader + id + \"VertexShader\"] = newVertexShader;\r\n        Effect.ShadersStore[program.fragmentShader + id + \"PixelShader\"] = newPixelShader;\r\n\r\n        var shaderMaterial = new ShaderMaterial(id, gltfRuntime.scene, shaderPath, options);\r\n        shaderMaterial.onError = onShaderCompileError(program, shaderMaterial, onError);\r\n        shaderMaterial.onCompiled = onShaderCompileSuccess(gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms, onSuccess);\r\n        shaderMaterial.sideOrientation = Material.CounterClockWiseSideOrientation;\r\n\r\n        if (states && states.functions) {\r\n            var functions = states.functions;\r\n            if (functions.cullFace && functions.cullFace[0] !== ECullingType.BACK) {\r\n                shaderMaterial.backFaceCulling = false;\r\n            }\r\n\r\n            var blendFunc = functions.blendFuncSeparate;\r\n            if (blendFunc) {\r\n                if (blendFunc[0] === EBlendingFunction.SRC_ALPHA && blendFunc[1] === EBlendingFunction.ONE_MINUS_SRC_ALPHA && blendFunc[2] === EBlendingFunction.ONE && blendFunc[3] === EBlendingFunction.ONE) {\r\n                    shaderMaterial.alphaMode = Constants.ALPHA_COMBINE;\r\n                }\r\n                else if (blendFunc[0] === EBlendingFunction.ONE && blendFunc[1] === EBlendingFunction.ONE && blendFunc[2] === EBlendingFunction.ZERO && blendFunc[3] === EBlendingFunction.ONE) {\r\n                    shaderMaterial.alphaMode = Constants.ALPHA_ONEONE;\r\n                }\r\n                else if (blendFunc[0] === EBlendingFunction.SRC_ALPHA && blendFunc[1] === EBlendingFunction.ONE && blendFunc[2] === EBlendingFunction.ZERO && blendFunc[3] === EBlendingFunction.ONE) {\r\n                    shaderMaterial.alphaMode = Constants.ALPHA_ADD;\r\n                }\r\n                else if (blendFunc[0] === EBlendingFunction.ZERO && blendFunc[1] === EBlendingFunction.ONE_MINUS_SRC_COLOR && blendFunc[2] === EBlendingFunction.ONE && blendFunc[3] === EBlendingFunction.ONE) {\r\n                    shaderMaterial.alphaMode = Constants.ALPHA_SUBTRACT;\r\n                }\r\n                else if (blendFunc[0] === EBlendingFunction.DST_COLOR && blendFunc[1] === EBlendingFunction.ZERO && blendFunc[2] === EBlendingFunction.ONE && blendFunc[3] === EBlendingFunction.ONE) {\r\n                    shaderMaterial.alphaMode = Constants.ALPHA_MULTIPLY;\r\n                }\r\n                else if (blendFunc[0] === EBlendingFunction.SRC_ALPHA && blendFunc[1] === EBlendingFunction.ONE_MINUS_SRC_COLOR && blendFunc[2] === EBlendingFunction.ONE && blendFunc[3] === EBlendingFunction.ONE) {\r\n                    shaderMaterial.alphaMode = Constants.ALPHA_MAXIMIZED;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n* glTF V1 Loader\r\n* @hidden\r\n*/\r\nexport class GLTFLoader implements IGLTFLoader {\r\n    public static Extensions: { [name: string]: GLTFLoaderExtension } = {};\r\n\r\n    public static RegisterExtension(extension: GLTFLoaderExtension): void {\r\n        if (GLTFLoader.Extensions[extension.name]) {\r\n            Tools.Error(\"Tool with the same name \\\"\" + extension.name + \"\\\" already exists\");\r\n            return;\r\n        }\r\n\r\n        GLTFLoader.Extensions[extension.name] = extension;\r\n    }\r\n\r\n    public state: Nullable<GLTFLoaderState> = null;\r\n\r\n    public dispose(): void {\r\n        // do nothing\r\n    }\r\n\r\n    private _importMeshAsync(meshesNames: any, scene: Scene, data: IGLTFLoaderData, rootUrl: string, forAssetContainer: boolean, onSuccess: (meshes: AbstractMesh[], skeletons: Skeleton[]) => void, onProgress?: (event: SceneLoaderProgressEvent) => void, onError?: (message: string) => void): boolean {\r\n        scene.useRightHandedSystem = true;\r\n\r\n        GLTFLoaderExtension.LoadRuntimeAsync(scene, data, rootUrl, (gltfRuntime) => {\r\n            gltfRuntime.forAssetContainer = forAssetContainer;\r\n            gltfRuntime.importOnlyMeshes = true;\r\n\r\n            if (meshesNames === \"\") {\r\n                gltfRuntime.importMeshesNames = [];\r\n            }\r\n            else if (typeof meshesNames === \"string\") {\r\n                gltfRuntime.importMeshesNames = [meshesNames];\r\n            }\r\n            else if (meshesNames && !(meshesNames instanceof Array)) {\r\n                gltfRuntime.importMeshesNames = [meshesNames];\r\n            }\r\n            else {\r\n                gltfRuntime.importMeshesNames = [];\r\n                Tools.Warn(\"Argument meshesNames must be of type string or string[]\");\r\n            }\r\n\r\n            // Create nodes\r\n            this._createNodes(gltfRuntime);\r\n\r\n            var meshes = new Array<AbstractMesh>();\r\n            var skeletons = new Array<Skeleton>();\r\n\r\n            // Fill arrays of meshes and skeletons\r\n            for (var nde in gltfRuntime.nodes) {\r\n                var node: IGLTFNode = gltfRuntime.nodes[nde];\r\n\r\n                if (node.babylonNode instanceof AbstractMesh) {\r\n                    meshes.push(<AbstractMesh>node.babylonNode);\r\n                }\r\n            }\r\n\r\n            for (var skl in gltfRuntime.skins) {\r\n                var skin: IGLTFSkins = gltfRuntime.skins[skl];\r\n\r\n                if (skin.babylonSkeleton instanceof Skeleton) {\r\n                    skeletons.push(skin.babylonSkeleton);\r\n                }\r\n            }\r\n\r\n            // Load buffers, shaders, materials, etc.\r\n            this._loadBuffersAsync(gltfRuntime, () => {\r\n                this._loadShadersAsync(gltfRuntime, () => {\r\n                    importMaterials(gltfRuntime);\r\n                    postLoad(gltfRuntime);\r\n\r\n                    if (!GLTFFileLoader.IncrementalLoading && onSuccess) {\r\n                        onSuccess(meshes, skeletons);\r\n                    }\r\n                });\r\n            }, onProgress);\r\n\r\n            if (GLTFFileLoader.IncrementalLoading && onSuccess) {\r\n                onSuccess(meshes, skeletons);\r\n            }\r\n        }, onError);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * Imports one or more meshes from a loaded gltf file and adds them to the scene\r\n    * @param meshesNames a string or array of strings of the mesh names that should be loaded from the file\r\n    * @param scene the scene the meshes should be added to\r\n    * @param forAssetContainer defines if the entities must be stored in the scene\r\n    * @param data gltf data containing information of the meshes in a loaded file\r\n    * @param rootUrl root url to load from\r\n    * @param onProgress event that fires when loading progress has occured\r\n    * @returns a promise containg the loaded meshes, particles, skeletons and animations\r\n    */\r\n    public importMeshAsync(meshesNames: any, scene: Scene, forAssetContainer: boolean, data: IGLTFLoaderData, rootUrl: string, onProgress?: (event: SceneLoaderProgressEvent) => void): Promise<IImportMeshAsyncOutput> {\r\n        return new Promise((resolve, reject) => {\r\n            this._importMeshAsync(meshesNames, scene, data, rootUrl, forAssetContainer, (meshes, skeletons) => {\r\n                resolve({\r\n                    meshes: meshes,\r\n                    particleSystems: [],\r\n                    skeletons: skeletons,\r\n                    animationGroups: [],\r\n                    lights: [],\r\n                    transformNodes: []\r\n                });\r\n            }, onProgress, (message) => {\r\n                reject(new Error(message));\r\n            });\r\n        });\r\n    }\r\n\r\n    private _loadAsync(scene: Scene, data: IGLTFLoaderData, rootUrl: string, forAssetContainer: boolean, onSuccess: () => void, onProgress?: (event: SceneLoaderProgressEvent) => void, onError?: (message: string) => void): void {\r\n        scene.useRightHandedSystem = true;\r\n\r\n        GLTFLoaderExtension.LoadRuntimeAsync(scene, data, rootUrl, (gltfRuntime) => {\r\n            // Load runtime extensios\r\n            GLTFLoaderExtension.LoadRuntimeExtensionsAsync(gltfRuntime, () => {\r\n                // Create nodes\r\n                this._createNodes(gltfRuntime);\r\n\r\n                // Load buffers, shaders, materials, etc.\r\n                this._loadBuffersAsync(gltfRuntime, () => {\r\n                    this._loadShadersAsync(gltfRuntime, () => {\r\n                        importMaterials(gltfRuntime);\r\n                        postLoad(gltfRuntime);\r\n\r\n                        if (!GLTFFileLoader.IncrementalLoading) {\r\n                            onSuccess();\r\n                        }\r\n                    });\r\n                });\r\n\r\n                if (GLTFFileLoader.IncrementalLoading) {\r\n                    onSuccess();\r\n                }\r\n            }, onError);\r\n        }, onError);\r\n    }\r\n\r\n    /**\r\n    * Imports all objects from a loaded gltf file and adds them to the scene\r\n    * @param scene the scene the objects should be added to\r\n    * @param data gltf data containing information of the meshes in a loaded file\r\n    * @param rootUrl root url to load from\r\n    * @param onProgress event that fires when loading progress has occured\r\n    * @returns a promise which completes when objects have been loaded to the scene\r\n    */\r\n    public loadAsync(scene: Scene, data: IGLTFLoaderData, rootUrl: string, onProgress?: (event: SceneLoaderProgressEvent) => void): Promise<void> {\r\n        return new Promise((resolve, reject) => {\r\n            this._loadAsync(scene, data, rootUrl, false, () => {\r\n                resolve();\r\n            }, onProgress, (message) => {\r\n                reject(new Error(message));\r\n            });\r\n        });\r\n    }\r\n\r\n    private _loadShadersAsync(gltfRuntime: IGLTFRuntime, onload: () => void): void {\r\n        var hasShaders = false;\r\n\r\n        var processShader = (sha: string, shader: IGLTFShader) => {\r\n            GLTFLoaderExtension.LoadShaderStringAsync(gltfRuntime, sha, (shaderString) => {\r\n                if (shaderString instanceof ArrayBuffer) {\r\n                    return;\r\n                }\r\n\r\n                gltfRuntime.loadedShaderCount++;\r\n\r\n                if (shaderString) {\r\n                    Effect.ShadersStore[sha + (shader.type === EShaderType.VERTEX ? \"VertexShader\" : \"PixelShader\")] = shaderString;\r\n                }\r\n\r\n                if (gltfRuntime.loadedShaderCount === gltfRuntime.shaderscount) {\r\n                    onload();\r\n                }\r\n            }, () => {\r\n                Tools.Error(\"Error when loading shader program named \" + sha + \" located at \" + shader.uri);\r\n            });\r\n        };\r\n\r\n        for (var sha in gltfRuntime.shaders) {\r\n            hasShaders = true;\r\n\r\n            var shader: IGLTFShader = gltfRuntime.shaders[sha];\r\n            if (shader) {\r\n                processShader.bind(this, sha, shader)();\r\n            }\r\n            else {\r\n                Tools.Error(\"No shader named: \" + sha);\r\n            }\r\n        }\r\n\r\n        if (!hasShaders) {\r\n            onload();\r\n        }\r\n    }\r\n\r\n    private _loadBuffersAsync(gltfRuntime: IGLTFRuntime, onLoad: () => void, onProgress?: (event: SceneLoaderProgressEvent) => void): void {\r\n        var hasBuffers = false;\r\n\r\n        var processBuffer = (buf: string, buffer: IGLTFBuffer) => {\r\n            GLTFLoaderExtension.LoadBufferAsync(gltfRuntime, buf, (bufferView) => {\r\n                gltfRuntime.loadedBufferCount++;\r\n\r\n                if (bufferView) {\r\n                    if (bufferView.byteLength != gltfRuntime.buffers[buf].byteLength) {\r\n                        Tools.Error(\"Buffer named \" + buf + \" is length \" + bufferView.byteLength + \". Expected: \" + buffer.byteLength); // Improve error message\r\n                    }\r\n\r\n                    gltfRuntime.loadedBufferViews[buf] = bufferView;\r\n                }\r\n\r\n                if (gltfRuntime.loadedBufferCount === gltfRuntime.buffersCount) {\r\n                    onLoad();\r\n                }\r\n            }, () => {\r\n                Tools.Error(\"Error when loading buffer named \" + buf + \" located at \" + buffer.uri);\r\n            });\r\n        };\r\n\r\n        for (var buf in gltfRuntime.buffers) {\r\n            hasBuffers = true;\r\n\r\n            var buffer: IGLTFBuffer = gltfRuntime.buffers[buf];\r\n            if (buffer) {\r\n                processBuffer.bind(this, buf, buffer)();\r\n            }\r\n            else {\r\n                Tools.Error(\"No buffer named: \" + buf);\r\n            }\r\n        }\r\n\r\n        if (!hasBuffers) {\r\n            onLoad();\r\n        }\r\n    }\r\n\r\n    private _createNodes(gltfRuntime: IGLTFRuntime): void {\r\n        var currentScene = <IGLTFScene>gltfRuntime.currentScene;\r\n\r\n        if (currentScene) {\r\n            // Only one scene even if multiple scenes are defined\r\n            for (var i = 0; i < currentScene.nodes.length; i++) {\r\n                traverseNodes(gltfRuntime, currentScene.nodes[i], null);\r\n            }\r\n        }\r\n        else {\r\n            // Load all scenes\r\n            for (var thing in gltfRuntime.scenes) {\r\n                currentScene = <IGLTFScene>gltfRuntime.scenes[thing];\r\n\r\n                for (var i = 0; i < currentScene.nodes.length; i++) {\r\n                    traverseNodes(gltfRuntime, currentScene.nodes[i], null);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/** @hidden */\r\nexport abstract class GLTFLoaderExtension {\r\n    private _name: string;\r\n\r\n    public constructor(name: string) {\r\n        this._name = name;\r\n    }\r\n\r\n    public get name(): string {\r\n        return this._name;\r\n    }\r\n\r\n    /**\r\n    * Defines an override for loading the runtime\r\n    * Return true to stop further extensions from loading the runtime\r\n    */\r\n    public loadRuntimeAsync(scene: Scene, data: IGLTFLoaderData, rootUrl: string, onSuccess?: (gltfRuntime: IGLTFRuntime) => void, onError?: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Defines an onverride for creating gltf runtime\r\n     * Return true to stop further extensions from creating the runtime\r\n     */\r\n    public loadRuntimeExtensionsAsync(gltfRuntime: IGLTFRuntime, onSuccess: () => void, onError?: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n    * Defines an override for loading buffers\r\n    * Return true to stop further extensions from loading this buffer\r\n    */\r\n    public loadBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (buffer: ArrayBufferView) => void, onError: (message: string) => void, onProgress?: () => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n    * Defines an override for loading texture buffers\r\n    * Return true to stop further extensions from loading this texture data\r\n    */\r\n    public loadTextureBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (buffer: ArrayBufferView) => void, onError: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n    * Defines an override for creating textures\r\n    * Return true to stop further extensions from loading this texture\r\n    */\r\n    public createTextureAsync(gltfRuntime: IGLTFRuntime, id: string, buffer: ArrayBufferView, onSuccess: (texture: Texture) => void, onError: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n    * Defines an override for loading shader strings\r\n    * Return true to stop further extensions from loading this shader data\r\n    */\r\n    public loadShaderStringAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (shaderString: string) => void, onError: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n    * Defines an override for loading materials\r\n    * Return true to stop further extensions from loading this material\r\n    */\r\n    public loadMaterialAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (material: Material) => void, onError: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    // ---------\r\n    // Utilities\r\n    // ---------\r\n\r\n    public static LoadRuntimeAsync(scene: Scene, data: IGLTFLoaderData, rootUrl: string, onSuccess?: (gltfRuntime: IGLTFRuntime) => void, onError?: (message: string) => void): void {\r\n        GLTFLoaderExtension.ApplyExtensions((loaderExtension) => {\r\n            return loaderExtension.loadRuntimeAsync(scene, data, rootUrl, onSuccess, onError);\r\n        }, () => {\r\n            setTimeout(() => {\r\n                if (!onSuccess) {\r\n                    return;\r\n                }\r\n                onSuccess(GLTFLoaderBase.CreateRuntime(data.json, scene, rootUrl));\r\n            });\r\n        });\r\n    }\r\n\r\n    public static LoadRuntimeExtensionsAsync(gltfRuntime: IGLTFRuntime, onSuccess: () => void, onError?: (message: string) => void): void {\r\n        GLTFLoaderExtension.ApplyExtensions((loaderExtension) => {\r\n            return loaderExtension.loadRuntimeExtensionsAsync(gltfRuntime, onSuccess, onError);\r\n        }, () => {\r\n            setTimeout(() => {\r\n                onSuccess();\r\n            });\r\n        });\r\n    }\r\n\r\n    public static LoadBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (bufferView: ArrayBufferView) => void, onError: (message: string) => void, onProgress?: () => void): void {\r\n        GLTFLoaderExtension.ApplyExtensions((loaderExtension) => {\r\n            return loaderExtension.loadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress);\r\n        }, () => {\r\n            GLTFLoaderBase.LoadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress);\r\n        });\r\n    }\r\n\r\n    public static LoadTextureAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (texture: Texture) => void, onError: (message: string) => void): void {\r\n        GLTFLoaderExtension.LoadTextureBufferAsync(gltfRuntime, id,\r\n            (buffer) => {\r\n                if (buffer) {\r\n                    GLTFLoaderExtension.CreateTextureAsync(gltfRuntime, id, buffer, onSuccess, onError);\r\n                }\r\n            }, onError);\r\n    }\r\n\r\n    public static LoadShaderStringAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (shaderData: string | ArrayBuffer) => void, onError: (message: string) => void): void {\r\n        GLTFLoaderExtension.ApplyExtensions((loaderExtension) => {\r\n            return loaderExtension.loadShaderStringAsync(gltfRuntime, id, onSuccess, onError);\r\n        }, () => {\r\n            GLTFLoaderBase.LoadShaderStringAsync(gltfRuntime, id, onSuccess, onError);\r\n        });\r\n    }\r\n\r\n    public static LoadMaterialAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (material: Material) => void, onError: (message: string) => void): void {\r\n        GLTFLoaderExtension.ApplyExtensions((loaderExtension) => {\r\n            return loaderExtension.loadMaterialAsync(gltfRuntime, id, onSuccess, onError);\r\n        }, () => {\r\n            GLTFLoaderBase.LoadMaterialAsync(gltfRuntime, id, onSuccess, onError);\r\n        });\r\n    }\r\n\r\n    private static LoadTextureBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (buffer: Nullable<ArrayBufferView>) => void, onError: (message: string) => void): void {\r\n        GLTFLoaderExtension.ApplyExtensions((loaderExtension) => {\r\n            return loaderExtension.loadTextureBufferAsync(gltfRuntime, id, onSuccess, onError);\r\n        }, () => {\r\n            GLTFLoaderBase.LoadTextureBufferAsync(gltfRuntime, id, onSuccess, onError);\r\n        });\r\n    }\r\n\r\n    private static CreateTextureAsync(gltfRuntime: IGLTFRuntime, id: string, buffer: ArrayBufferView, onSuccess: (texture: Texture) => void, onError: (message: string) => void): void {\r\n        GLTFLoaderExtension.ApplyExtensions((loaderExtension) => {\r\n            return loaderExtension.createTextureAsync(gltfRuntime, id, buffer, onSuccess, onError);\r\n        }, () => {\r\n            GLTFLoaderBase.CreateTextureAsync(gltfRuntime, id, buffer, onSuccess, onError);\r\n        });\r\n    }\r\n\r\n    private static ApplyExtensions(func: (loaderExtension: GLTFLoaderExtension) => boolean, defaultFunc: () => void): void {\r\n        for (var extensionName in GLTFLoader.Extensions) {\r\n            var loaderExtension = GLTFLoader.Extensions[extensionName];\r\n            if (func(loaderExtension)) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        defaultFunc();\r\n    }\r\n}\r\n\r\nGLTFFileLoader._CreateGLTF1Loader = () => new GLTFLoader();\r\n"]}