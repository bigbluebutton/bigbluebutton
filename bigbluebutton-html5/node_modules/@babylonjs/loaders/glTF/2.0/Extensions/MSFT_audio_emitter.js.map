{"version":3,"file":"MSFT_audio_emitter.js","sourceRoot":"","sources":["../../../../../sourceES6/loaders/src/glTF/2.0/Extensions/MSFT_audio_emitter.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"@babylonjs/core/types\";\nimport { Vector3 } from \"@babylonjs/core/Maths/math.vector\";\nimport { Tools } from \"@babylonjs/core/Misc/tools\";\nimport { AnimationGroup } from \"@babylonjs/core/Animations/animationGroup\";\nimport { AnimationEvent } from \"@babylonjs/core/Animations/animationEvent\";\nimport { TransformNode } from \"@babylonjs/core/Meshes/transformNode\";\nimport { Sound } from \"@babylonjs/core/Audio/sound\";\nimport { WeightedSound } from \"@babylonjs/core/Audio/weightedsound\";\n\nimport { IArrayItem, IScene, INode, IAnimation } from \"../glTFLoaderInterfaces\";\nimport { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\nimport { IProperty } from 'babylonjs-gltf2interface';\n\nconst NAME = \"MSFT_audio_emitter\";\n\ninterface IClipReference {\n    clip: number;\n    weight?: number;\n}\n\ninterface IEmittersReference {\n    emitters: number[];\n}\n\nconst enum DistanceModel {\n    linear = \"linear\",\n    inverse = \"inverse\",\n    exponential = \"exponential\",\n}\n\ninterface IEmitter {\n    name?: string;\n    distanceModel?: DistanceModel;\n    refDistance?: number;\n    maxDistance?: number;\n    rolloffFactor?: number;\n    innerAngle?: number;\n    outerAngle?: number;\n    loop?: boolean;\n    volume?: number;\n    clips: IClipReference[];\n}\n\nconst enum AudioMimeType {\n    WAV = \"audio/wav\",\n}\n\ninterface IClip extends IProperty {\n    uri?: string;\n    bufferView?: number;\n    mimeType?: AudioMimeType;\n}\n\ninterface ILoaderClip extends IClip, IArrayItem {\n    _objectURL?: Promise<string>;\n}\n\ninterface ILoaderEmitter extends IEmitter, IArrayItem {\n    _babylonData?: {\n        sound?: WeightedSound;\n        loaded: Promise<void>;\n    };\n    _babylonSounds: Sound[];\n}\n\ninterface IMSFTAudioEmitter {\n    clips: ILoaderClip[];\n    emitters: ILoaderEmitter[];\n}\n\nconst enum AnimationEventAction {\n    play = \"play\",\n    pause = \"pause\",\n    stop = \"stop\",\n}\n\ninterface IAnimationEvent {\n    action: AnimationEventAction;\n    emitter: number;\n    time: number;\n    startOffset?: number;\n}\n\ninterface ILoaderAnimationEvent extends IAnimationEvent, IArrayItem {\n}\n\ninterface ILoaderAnimationEvents {\n    events: ILoaderAnimationEvent[];\n}\n\n/**\n * [Specification](https://github.com/najadojo/glTF/tree/MSFT_audio_emitter/extensions/2.0/Vendor/MSFT_audio_emitter)\n */\nexport class MSFT_audio_emitter implements IGLTFLoaderExtension {\n    /**\n     * The name of this extension.\n     */\n    public readonly name = NAME;\n\n    /**\n     * Defines whether this extension is enabled.\n     */\n    public enabled: boolean;\n\n    private _loader: GLTFLoader;\n    private _clips: Array<ILoaderClip>;\n    private _emitters: Array<ILoaderEmitter>;\n\n    /** @hidden */\n    constructor(loader: GLTFLoader) {\n        this._loader = loader;\n        this.enabled = this._loader.isExtensionUsed(NAME);\n    }\n\n    /** @hidden */\n    public dispose() {\n        delete this._loader;\n        delete this._clips;\n        delete this._emitters;\n    }\n\n    /** @hidden */\n    public onLoading(): void {\n        const extensions = this._loader.gltf.extensions;\n        if (extensions && extensions[this.name]) {\n            const extension = extensions[this.name] as IMSFTAudioEmitter;\n\n            this._clips = extension.clips;\n            this._emitters = extension.emitters;\n\n            ArrayItem.Assign(this._clips);\n            ArrayItem.Assign(this._emitters);\n        }\n    }\n\n    /** @hidden */\n    public loadSceneAsync(context: string, scene: IScene): Nullable<Promise<void>> {\n        return GLTFLoader.LoadExtensionAsync<IEmittersReference>(context, scene, this.name, (extensionContext, extension) => {\n            const promises = new Array<Promise<any>>();\n\n            promises.push(this._loader.loadSceneAsync(context, scene));\n\n            for (const emitterIndex of extension.emitters) {\n                const emitter = ArrayItem.Get(`${extensionContext}/emitters`, this._emitters, emitterIndex);\n                if (emitter.refDistance != undefined || emitter.maxDistance != undefined || emitter.rolloffFactor != undefined ||\n                    emitter.distanceModel != undefined || emitter.innerAngle != undefined || emitter.outerAngle != undefined) {\n                    throw new Error(`${extensionContext}: Direction or Distance properties are not allowed on emitters attached to a scene`);\n                }\n\n                promises.push(this._loadEmitterAsync(`${extensionContext}/emitters/${emitter.index}`, emitter));\n            }\n\n            return Promise.all(promises).then(() => { });\n        });\n    }\n\n    /** @hidden */\n    public loadNodeAsync(context: string, node: INode, assign: (babylonTransformNode: TransformNode) => void): Nullable<Promise<TransformNode>> {\n        return GLTFLoader.LoadExtensionAsync<IEmittersReference, TransformNode>(context, node, this.name, (extensionContext, extension) => {\n            const promises = new Array<Promise<any>>();\n\n            return this._loader.loadNodeAsync(extensionContext, node, (babylonMesh) => {\n                for (const emitterIndex of extension.emitters) {\n                    const emitter = ArrayItem.Get(`${extensionContext}/emitters`, this._emitters, emitterIndex);\n                    promises.push(this._loadEmitterAsync(`${extensionContext}/emitters/${emitter.index}`, emitter).then(() => {\n                        for (const sound of emitter._babylonSounds) {\n                            sound.attachToMesh(babylonMesh);\n                            if (emitter.innerAngle != undefined || emitter.outerAngle != undefined) {\n                                sound.setLocalDirectionToMesh(Vector3.Forward());\n                                sound.setDirectionalCone(\n                                    2 * Tools.ToDegrees(emitter.innerAngle == undefined ? Math.PI : emitter.innerAngle),\n                                    2 * Tools.ToDegrees(emitter.outerAngle == undefined ? Math.PI : emitter.outerAngle),\n                                    0);\n                            }\n                        }\n                    }));\n                }\n\n                assign(babylonMesh);\n            }).then((babylonMesh) => {\n                return Promise.all(promises).then(() => {\n                    return babylonMesh;\n                });\n            });\n        });\n    }\n\n    /** @hidden */\n    public loadAnimationAsync(context: string, animation: IAnimation): Nullable<Promise<AnimationGroup>> {\n        return GLTFLoader.LoadExtensionAsync<ILoaderAnimationEvents, AnimationGroup>(context, animation, this.name, (extensionContext, extension) => {\n            return this._loader.loadAnimationAsync(context, animation).then((babylonAnimationGroup) => {\n                const promises = new Array<Promise<any>>();\n\n                ArrayItem.Assign(extension.events);\n                for (const event of extension.events) {\n                    promises.push(this._loadAnimationEventAsync(`${extensionContext}/events/${event.index}`, context, animation, event, babylonAnimationGroup));\n                }\n\n                return Promise.all(promises).then(() => {\n                    return babylonAnimationGroup;\n                });\n            });\n        });\n    }\n\n    private _loadClipAsync(context: string, clip: ILoaderClip): Promise<string> {\n        if (clip._objectURL) {\n            return clip._objectURL;\n        }\n\n        let promise: Promise<ArrayBufferView>;\n        if (clip.uri) {\n            promise = this._loader.loadUriAsync(context, clip, clip.uri);\n        }\n        else {\n            const bufferView = ArrayItem.Get(`${context}/bufferView`, this._loader.gltf.bufferViews, clip.bufferView);\n            promise = this._loader.loadBufferViewAsync(`#/bufferViews/${bufferView.index}`, bufferView);\n        }\n\n        clip._objectURL = promise.then((data) => {\n            return URL.createObjectURL(new Blob([data], { type: clip.mimeType }));\n        });\n\n        return clip._objectURL;\n    }\n\n    private _loadEmitterAsync(context: string, emitter: ILoaderEmitter): Promise<void> {\n        emitter._babylonSounds = emitter._babylonSounds || [];\n        if (!emitter._babylonData) {\n            const clipPromises = new Array<Promise<any>>();\n            const name = emitter.name || `emitter${emitter.index}`;\n            const options = {\n                loop: false,\n                autoplay: false,\n                volume: emitter.volume == undefined ? 1 : emitter.volume,\n            };\n\n            for (let i = 0; i < emitter.clips.length; i++) {\n                const clipContext = `#/extensions/${this.name}/clips`;\n                const clip = ArrayItem.Get(clipContext, this._clips, emitter.clips[i].clip);\n                clipPromises.push(this._loadClipAsync(`${clipContext}/${emitter.clips[i].clip}`, clip).then((objectURL: string) => {\n                    const sound = emitter._babylonSounds[i] = new Sound(name, objectURL, this._loader.babylonScene, null, options);\n                    sound.refDistance = emitter.refDistance || 1;\n                    sound.maxDistance = emitter.maxDistance || 256;\n                    sound.rolloffFactor = emitter.rolloffFactor || 1;\n                    sound.distanceModel = emitter.distanceModel || 'exponential';\n                    sound._positionInEmitterSpace = true;\n                }));\n            }\n\n            const promise = Promise.all(clipPromises).then(() => {\n                const weights = emitter.clips.map((clip) => { return clip.weight || 1; });\n                const weightedSound = new WeightedSound(emitter.loop || false, emitter._babylonSounds, weights);\n                if (emitter.innerAngle) { weightedSound.directionalConeInnerAngle = 2 * Tools.ToDegrees(emitter.innerAngle); }\n                if (emitter.outerAngle) { weightedSound.directionalConeOuterAngle = 2 * Tools.ToDegrees(emitter.outerAngle); }\n                if (emitter.volume) { weightedSound.volume = emitter.volume; }\n                emitter._babylonData!.sound = weightedSound;\n            });\n\n            emitter._babylonData = {\n                loaded: promise\n            };\n        }\n\n        return emitter._babylonData.loaded;\n    }\n\n    private _getEventAction(context: string, sound: WeightedSound, action: AnimationEventAction, time: number, startOffset?: number): (currentFrame: number) => void {\n        switch (action) {\n            case AnimationEventAction.play: {\n                return (currentFrame: number) => {\n                    const frameOffset = (startOffset || 0) + (currentFrame - time);\n                    sound.play(frameOffset);\n                };\n            }\n            case AnimationEventAction.stop: {\n                return (currentFrame: number) => {\n                    sound.stop();\n                };\n            }\n            case AnimationEventAction.pause: {\n                return (currentFrame: number) => {\n                    sound.pause();\n                };\n            }\n            default: {\n                throw new Error(`${context}: Unsupported action ${action}`);\n            }\n        }\n    }\n\n    private _loadAnimationEventAsync(context: string, animationContext: string, animation: IAnimation, event: ILoaderAnimationEvent, babylonAnimationGroup: AnimationGroup): Promise<void> {\n        if (babylonAnimationGroup.targetedAnimations.length == 0) {\n            return Promise.resolve();\n        }\n        const babylonAnimation = babylonAnimationGroup.targetedAnimations[0];\n        const emitterIndex = event.emitter;\n        const emitter = ArrayItem.Get(`#/extensions/${this.name}/emitters`, this._emitters, emitterIndex);\n        return this._loadEmitterAsync(context, emitter).then(() => {\n            const sound = emitter._babylonData!.sound;\n            if (sound) {\n                var babylonAnimationEvent = new AnimationEvent(event.time, this._getEventAction(context, sound, event.action, event.time, event.startOffset));\n                babylonAnimation.animation.addEvent(babylonAnimationEvent);\n                // Make sure all started audio stops when this animation is terminated.\n                babylonAnimationGroup.onAnimationGroupEndObservable.add(() => {\n                    sound.stop();\n                });\n                babylonAnimationGroup.onAnimationGroupPauseObservable.add(() => {\n                    sound.pause();\n                });\n            }\n        });\n    }\n}\n\nGLTFLoader.RegisterExtension(NAME, (loader) => new MSFT_audio_emitter(loader));"]}