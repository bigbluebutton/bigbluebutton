{"version":3,"file":"BaseCameraPointersInput.js","sourceRoot":"","sources":["../../../../sourceES6/core/Cameras/Inputs/BaseCameraPointersInput.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../../types\";\nimport { serialize } from \"../../Misc/decorators\";\nimport { EventState, Observer } from \"../../Misc/observable\";\nimport { Tools } from \"../../Misc/tools\";\nimport { Camera } from \"../../Cameras/camera\";\nimport { ICameraInput } from \"../../Cameras/cameraInputsManager\";\nimport { PointerInfo, PointerEventTypes, PointerTouch } from \"../../Events/pointerEvents\";\n\n/**\n * Base class for Camera Pointer Inputs.\n * See FollowCameraPointersInput in src/Cameras/Inputs/followCameraPointersInput.ts\n * for example usage.\n */\nexport abstract class BaseCameraPointersInput implements ICameraInput<Camera> {\n    /**\n     * Defines the camera the input is attached to.\n     */\n    public abstract camera: Camera;\n\n    /**\n     * Whether keyboard modifier keys are pressed at time of last mouse event.\n     */\n    protected _altKey: boolean;\n    protected _ctrlKey: boolean;\n    protected _metaKey: boolean;\n    protected _shiftKey: boolean;\n\n    /**\n     * Which mouse buttons were pressed at time of last mouse event.\n     * https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\n     */\n    protected _buttonsPressed: number;\n\n    /**\n     * Defines the buttons associated with the input to handle camera move.\n     */\n    @serialize()\n    public buttons = [0, 1, 2];\n\n    /**\n     * Attach the input controls to a specific dom element to get the input from.\n     * @param element Defines the element the controls should be listened from\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\n     */\n    public attachControl(element: HTMLElement, noPreventDefault?: boolean): void {\n        var engine = this.camera.getEngine();\n        var previousPinchSquaredDistance = 0;\n        var previousMultiTouchPanPosition: Nullable<PointerTouch> = null;\n\n        this.pointA = null;\n        this.pointB = null;\n\n        this._altKey = false;\n        this._ctrlKey = false;\n        this._metaKey = false;\n        this._shiftKey = false;\n        this._buttonsPressed = 0;\n\n        this._pointerInput = (p, s) => {\n            var evt = <PointerEvent>p.event;\n            let isTouch = evt.pointerType === \"touch\";\n\n            if (engine.isInVRExclusivePointerMode) {\n                return;\n            }\n\n            if (p.type !== PointerEventTypes.POINTERMOVE &&\n                this.buttons.indexOf(evt.button) === -1) {\n                return;\n            }\n\n            let srcElement = <HTMLElement>(evt.srcElement || evt.target);\n\n            this._altKey = evt.altKey;\n            this._ctrlKey = evt.ctrlKey;\n            this._metaKey = evt.metaKey;\n            this._shiftKey = evt.shiftKey;\n            this._buttonsPressed = evt.buttons;\n\n            if (engine.isPointerLock) {\n                var offsetX = evt.movementX ||\n                              evt.mozMovementX ||\n                              evt.webkitMovementX ||\n                              evt.msMovementX ||\n                              0;\n                var offsetY = evt.movementY ||\n                              evt.mozMovementY ||\n                              evt.webkitMovementY ||\n                              evt.msMovementY ||\n                              0;\n\n                this.onTouch(null, offsetX, offsetY);\n                this.pointA = null;\n                this.pointB = null;\n            } else if (p.type === PointerEventTypes.POINTERDOWN && srcElement) {\n                try {\n                    srcElement.setPointerCapture(evt.pointerId);\n                } catch (e) {\n                    //Nothing to do with the error. Execution will continue.\n                }\n\n                if (this.pointA === null) {\n                    this.pointA = {x: evt.clientX,\n                              y: evt.clientY,\n                              pointerId: evt.pointerId,\n                              type: evt.pointerType };\n                } else if (this.pointB === null) {\n                    this.pointB = {x: evt.clientX,\n                              y: evt.clientY,\n                              pointerId: evt.pointerId,\n                              type: evt.pointerType };\n                }\n\n                this.onButtonDown(evt);\n\n                if (!noPreventDefault) {\n                    evt.preventDefault();\n                    element.focus();\n                }\n            } else if (p.type === PointerEventTypes.POINTERDOUBLETAP) {\n                this.onDoubleTap(evt.pointerType);\n            } else if (p.type === PointerEventTypes.POINTERUP && srcElement) {\n                try {\n                    srcElement.releasePointerCapture(evt.pointerId);\n                } catch (e) {\n                    //Nothing to do with the error.\n                }\n\n                if (!isTouch) {\n                    this.pointB = null; // Mouse and pen are mono pointer\n                }\n\n                //would be better to use pointers.remove(evt.pointerId) for multitouch gestures,\n                //but emptying completely pointers collection is required to fix a bug on iPhone :\n                //when changing orientation while pinching camera,\n                //one pointer stay pressed forever if we don't release all pointers\n                //will be ok to put back pointers.remove(evt.pointerId); when iPhone bug corrected\n                if (engine._badOS) {\n                    this.pointA = this.pointB = null;\n                } else {\n                    //only remove the impacted pointer in case of multitouch allowing on most\n                    //platforms switching from rotate to zoom and pan seamlessly.\n                    if (this.pointB && this.pointA && this.pointA.pointerId == evt.pointerId) {\n                        this.pointA = this.pointB;\n                        this.pointB = null;\n                    } else if (this.pointA && this.pointB &&\n                               this.pointB.pointerId == evt.pointerId) {\n                        this.pointB = null;\n                    } else {\n                        this.pointA = this.pointB = null;\n                    }\n                }\n\n                if (previousPinchSquaredDistance !== 0 || previousMultiTouchPanPosition) {\n                    // Previous pinch data is populated but a button has been lifted\n                    // so pinch has ended.\n                    this.onMultiTouch(\n                      this.pointA,\n                      this.pointB,\n                      previousPinchSquaredDistance,\n                      0,  // pinchSquaredDistance\n                      previousMultiTouchPanPosition,\n                      null  // multiTouchPanPosition\n                    );\n                  previousPinchSquaredDistance = 0;\n                  previousMultiTouchPanPosition = null;\n                }\n\n                this.onButtonUp(evt);\n\n                if (!noPreventDefault) {\n                    evt.preventDefault();\n                }\n            } else if (p.type === PointerEventTypes.POINTERMOVE) {\n                if (!noPreventDefault) {\n                    evt.preventDefault();\n                }\n\n                // One button down\n                if (this.pointA && this.pointB === null) {\n                    var offsetX = evt.clientX - this.pointA.x;\n                    var offsetY = evt.clientY - this.pointA.y;\n                    this.onTouch(this.pointA, offsetX, offsetY);\n\n                    this.pointA.x = evt.clientX;\n                    this.pointA.y = evt.clientY;\n                }\n                // Two buttons down: pinch\n                else if (this.pointA && this.pointB) {\n                    var ed = (this.pointA.pointerId === evt.pointerId) ?\n                             this.pointA : this.pointB;\n                    ed.x = evt.clientX;\n                    ed.y = evt.clientY;\n                    var distX = this.pointA.x - this.pointB.x;\n                    var distY = this.pointA.y - this.pointB.y;\n                    var pinchSquaredDistance = (distX * distX) + (distY * distY);\n                    var multiTouchPanPosition = {x: (this.pointA.x + this.pointB.x) / 2,\n                                                 y: (this.pointA.y + this.pointB.y) / 2,\n                                                 pointerId: evt.pointerId,\n                                                 type: p.type};\n\n                    this.onMultiTouch(\n                      this.pointA,\n                      this.pointB,\n                      previousPinchSquaredDistance,\n                      pinchSquaredDistance,\n                      previousMultiTouchPanPosition,\n                      multiTouchPanPosition);\n\n                    previousMultiTouchPanPosition = multiTouchPanPosition;\n                    previousPinchSquaredDistance = pinchSquaredDistance;\n                }\n            }\n        };\n\n        this._observer = this.camera.getScene().onPointerObservable.add(\n            this._pointerInput,\n            PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP |\n            PointerEventTypes.POINTERMOVE);\n\n        this._onLostFocus = () => {\n            this.pointA = this.pointB = null;\n            previousPinchSquaredDistance = 0;\n            previousMultiTouchPanPosition = null;\n            this.onLostFocus();\n        };\n\n        element.addEventListener(\"contextmenu\",\n            <EventListener>this.onContextMenu.bind(this), false);\n\n        let hostWindow = this.camera.getScene().getEngine().getHostWindow();\n\n        if (hostWindow) {\n            Tools.RegisterTopRootEvents(hostWindow, [\n                { name: \"blur\", handler: this._onLostFocus }\n            ]);\n        }\n    }\n\n    /**\n     * Detach the current controls from the specified dom element.\n     * @param element Defines the element to stop listening the inputs from\n     */\n    public detachControl(element: Nullable<HTMLElement>): void {\n        if (this._onLostFocus) {\n            let hostWindow = this.camera.getScene().getEngine().getHostWindow();\n            if (hostWindow) {\n                Tools.UnregisterTopRootEvents(hostWindow, [\n                    { name: \"blur\", handler: this._onLostFocus }\n                ]);\n            }\n        }\n\n        if (element && this._observer) {\n            this.camera.getScene().onPointerObservable.remove(this._observer);\n            this._observer = null;\n\n            if (this.onContextMenu) {\n                element.removeEventListener(\"contextmenu\", <EventListener>this.onContextMenu);\n            }\n\n            this._onLostFocus = null;\n        }\n\n        this._altKey = false;\n        this._ctrlKey = false;\n        this._metaKey = false;\n        this._shiftKey = false;\n        this._buttonsPressed = 0;\n    }\n\n    /**\n     * Gets the class name of the current input.\n     * @returns the class name\n     */\n    public getClassName(): string {\n        return \"BaseCameraPointersInput\";\n    }\n\n    /**\n     * Get the friendly name associated with the input class.\n     * @returns the input friendly name\n     */\n    public getSimpleName(): string {\n        return \"pointers\";\n    }\n\n    /**\n     * Called on pointer POINTERDOUBLETAP event.\n     * Override this method to provide functionality on POINTERDOUBLETAP event.\n     */\n    protected onDoubleTap(type: string) {\n    }\n\n    /**\n     * Called on pointer POINTERMOVE event if only a single touch is active.\n     * Override this method to provide functionality.\n     */\n    protected onTouch(point: Nullable<PointerTouch>,\n                      offsetX: number,\n                      offsetY: number): void {\n    }\n\n    /**\n     * Called on pointer POINTERMOVE event if multiple touches are active.\n     * Override this method to provide functionality.\n     */\n    protected onMultiTouch(pointA: Nullable<PointerTouch>,\n                           pointB: Nullable<PointerTouch>,\n                           previousPinchSquaredDistance: number,\n                           pinchSquaredDistance: number,\n                           previousMultiTouchPanPosition: Nullable<PointerTouch>,\n                           multiTouchPanPosition: Nullable<PointerTouch>): void {\n    }\n\n    /**\n     * Called on JS contextmenu event.\n     * Override this method to provide functionality.\n     */\n    protected onContextMenu(evt: PointerEvent): void {\n        evt.preventDefault();\n    }\n\n    /**\n     * Called each time a new POINTERDOWN event occurs. Ie, for each button\n     * press.\n     * Override this method to provide functionality.\n     */\n    protected onButtonDown(evt: PointerEvent): void {\n    }\n\n    /**\n     * Called each time a new POINTERUP event occurs. Ie, for each button\n     * release.\n     * Override this method to provide functionality.\n     */\n    protected onButtonUp(evt: PointerEvent): void {\n    }\n\n    /**\n     * Called when window becomes inactive.\n     * Override this method to provide functionality.\n     */\n    protected onLostFocus(): void {\n    }\n\n    private _pointerInput: (p: PointerInfo, s: EventState) => void;\n    private _observer: Nullable<Observer<PointerInfo>>;\n    private _onLostFocus: Nullable<(e: FocusEvent) => any>;\n    private pointA: Nullable<PointerTouch>;\n    private pointB: Nullable<PointerTouch>;\n}\n"]}