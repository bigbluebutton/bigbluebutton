import { __extends } from "tslib";
import { Engine } from "../Engines/engine";
import { InternalTexture, InternalTextureSource } from "../Materials/Textures/internalTexture";
import { Texture } from "../Materials/Textures/texture";
import { DataBuffer } from '../Meshes/dataBuffer';
import { Tools } from "../Misc/tools";
import { EnvironmentTextureTools } from "../Misc/environmentTextureTools";
import { RenderTargetCreationOptions } from "../Materials/Textures/renderTargetCreationOptions";
import { NativeShaderProcessor } from './Native/nativeShaderProcessor';
import { Logger } from "../Misc/logger";
import { ThinEngine } from './thinEngine';
var NativePipelineContext = /** @class */ (function () {
    function NativePipelineContext() {
        // TODO: async should be true?
        this.isAsync = false;
        this.isReady = false;
    }
    // TODO: what should this do?
    NativePipelineContext.prototype._handlesSpectorRebuildCallback = function (onCompiled) {
        throw new Error("Not implemented");
    };
    return NativePipelineContext;
}());
/**
 * Container for accessors for natively-stored mesh data buffers.
 */
var NativeDataBuffer = /** @class */ (function (_super) {
    __extends(NativeDataBuffer, _super);
    function NativeDataBuffer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return NativeDataBuffer;
}(DataBuffer));
// TODO: change this to match bgfx.
// Must match Filter enum in SpectreEngine.h.
var NativeFilter = /** @class */ (function () {
    function NativeFilter() {
    }
    NativeFilter.POINT = 0;
    NativeFilter.MINPOINT_MAGPOINT_MIPPOINT = NativeFilter.POINT;
    NativeFilter.BILINEAR = 1;
    NativeFilter.MINLINEAR_MAGLINEAR_MIPPOINT = NativeFilter.BILINEAR;
    NativeFilter.TRILINEAR = 2;
    NativeFilter.MINLINEAR_MAGLINEAR_MIPLINEAR = NativeFilter.TRILINEAR;
    NativeFilter.ANISOTROPIC = 3;
    NativeFilter.POINT_COMPARE = 4;
    NativeFilter.TRILINEAR_COMPARE = 5;
    NativeFilter.MINBILINEAR_MAGPOINT = 6;
    NativeFilter.MINLINEAR_MAGPOINT_MIPLINEAR = NativeFilter.MINBILINEAR_MAGPOINT;
    NativeFilter.MINPOINT_MAGPOINT_MIPLINEAR = 7;
    NativeFilter.MINPOINT_MAGLINEAR_MIPPOINT = 8;
    NativeFilter.MINPOINT_MAGLINEAR_MIPLINEAR = 9;
    NativeFilter.MINLINEAR_MAGPOINT_MIPPOINT = 10;
    return NativeFilter;
}());
// these flags match bgfx.
var NativeClearFlags = /** @class */ (function () {
    function NativeClearFlags() {
    }
    NativeClearFlags.CLEAR_COLOR = 1;
    NativeClearFlags.CLEAR_DEPTH = 2;
    NativeClearFlags.CLEAR_STENCIL = 4;
    return NativeClearFlags;
}());
// TODO: change this to match bgfx.
// Must match AddressMode enum in SpectreEngine.h.
var NativeAddressMode = /** @class */ (function () {
    function NativeAddressMode() {
    }
    NativeAddressMode.WRAP = 0;
    NativeAddressMode.MIRROR = 1;
    NativeAddressMode.CLAMP = 2;
    NativeAddressMode.BORDER = 3;
    NativeAddressMode.MIRROR_ONCE = 4;
    return NativeAddressMode;
}());
var NativeTextureFormat = /** @class */ (function () {
    function NativeTextureFormat() {
    }
    NativeTextureFormat.RGBA8 = 0;
    NativeTextureFormat.RGBA32F = 1;
    return NativeTextureFormat;
}());
/** @hidden */
var NativeTexture = /** @class */ (function (_super) {
    __extends(NativeTexture, _super);
    function NativeTexture() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NativeTexture.prototype.getInternalTexture = function () {
        return this;
    };
    NativeTexture.prototype.getViewCount = function () {
        return 1;
    };
    return NativeTexture;
}(InternalTexture));
/** @hidden */
var NativeEngine = /** @class */ (function (_super) {
    __extends(NativeEngine, _super);
    function NativeEngine() {
        var _this = _super.call(this, null) || this;
        _this._native = new _native.Engine();
        /** Defines the invalid handle returned by bgfx when resource creation goes wrong */
        _this.INVALID_HANDLE = 65535;
        _this._webGLVersion = 2;
        _this.disableUniformBuffers = true;
        // TODO: Initialize this more correctly based on the hardware capabilities.
        // Init caps
        _this._caps = {
            maxTexturesImageUnits: 16,
            maxVertexTextureImageUnits: 16,
            maxCombinedTexturesImageUnits: 32,
            maxTextureSize: 512,
            maxCubemapTextureSize: 512,
            maxRenderTextureSize: 512,
            maxVertexAttribs: 16,
            maxVaryingVectors: 16,
            maxFragmentUniformVectors: 16,
            maxVertexUniformVectors: 16,
            standardDerivatives: true,
            astc: null,
            pvrtc: null,
            etc1: null,
            etc2: null,
            maxAnisotropy: 16,
            uintIndices: false,
            fragmentDepthSupported: false,
            highPrecisionShaderSupported: true,
            colorBufferFloat: false,
            textureFloat: false,
            textureFloatLinearFiltering: false,
            textureFloatRender: false,
            textureHalfFloat: false,
            textureHalfFloatLinearFiltering: false,
            textureHalfFloatRender: false,
            textureLOD: true,
            drawBuffersExtension: false,
            depthTextureExtension: false,
            vertexArrayObject: true,
            instancedArrays: false,
            canUseTimestampForTimerQuery: false,
            blendMinMax: false,
            maxMSAASamples: 1
        };
        Tools.Log("Babylon Native (v" + Engine.Version + ") launched");
        // Wrappers
        if (typeof URL === "undefined") {
            window.URL = {
                createObjectURL: function () { },
                revokeObjectURL: function () { }
            };
        }
        if (typeof Blob === "undefined") {
            window.Blob = function () { };
        }
        // Shader processor
        _this._shaderProcessor = new NativeShaderProcessor();
        return _this;
    }
    NativeEngine.prototype.getHardwareScalingLevel = function () {
        return 1.0;
    };
    /**
     * Can be used to override the current requestAnimationFrame requester.
     * @hidden
     */
    NativeEngine.prototype._queueNewFrame = function (bindedRenderFunction, requester) {
        if (requester.requestAnimationFrame) {
            requester.requestAnimationFrame(bindedRenderFunction);
        }
        else {
            this._native.requestAnimationFrame(bindedRenderFunction);
        }
        return 0;
    };
    /**
     * Override default engine behavior.
     * @param color
     * @param backBuffer
     * @param depth
     * @param stencil
     */
    NativeEngine.prototype._bindUnboundFramebuffer = function (framebuffer) {
        if (this._currentFramebuffer !== framebuffer) {
            if (this._currentFramebuffer) {
                this._native.unbindFramebuffer(this._currentFramebuffer);
            }
            if (framebuffer) {
                this._native.bindFramebuffer(framebuffer);
            }
            this._currentFramebuffer = framebuffer;
        }
    };
    /**
     * Gets host document
     * @returns the host document object
     */
    NativeEngine.prototype.getHostDocument = function () {
        return null;
    };
    NativeEngine.prototype.clear = function (color, backBuffer, depth, stencil) {
        if (stencil === void 0) { stencil = false; }
        var mode = 0;
        if (backBuffer && color) {
            this._native.clearColor(color.r, color.g, color.b, color.a !== undefined ? color.a : 1.0);
            mode |= NativeClearFlags.CLEAR_COLOR;
        }
        if (depth) {
            this._native.clearDepth(1.0);
            mode |= NativeClearFlags.CLEAR_DEPTH;
        }
        if (stencil) {
            this._native.clearStencil(0);
            mode |= NativeClearFlags.CLEAR_STENCIL;
        }
        this._native.clear(mode);
    };
    NativeEngine.prototype.createIndexBuffer = function (indices) {
        var data = this._normalizeIndexData(indices);
        var buffer = new NativeDataBuffer();
        buffer.references = 1;
        buffer.is32Bits = (data.BYTES_PER_ELEMENT === 4);
        buffer.nativeIndexBuffer = this._native.createIndexBuffer(data);
        if (buffer.nativeVertexBuffer === this.INVALID_HANDLE) {
            throw new Error("Could not create a native index buffer.");
        }
        return buffer;
    };
    NativeEngine.prototype.createVertexBuffer = function (data) {
        var buffer = new NativeDataBuffer();
        buffer.references = 1;
        buffer.nativeVertexBuffer = this._native.createVertexBuffer(ArrayBuffer.isView(data) ? data : new Float32Array(data));
        if (buffer.nativeVertexBuffer === this.INVALID_HANDLE) {
            throw new Error("Could not create a native vertex buffer.");
        }
        return buffer;
    };
    NativeEngine.prototype.recordVertexArrayObject = function (vertexBuffers, indexBuffer, effect) {
        var vertexArray = this._native.createVertexArray();
        if (indexBuffer) {
            this._native.recordIndexBuffer(vertexArray, indexBuffer.nativeIndexBuffer);
        }
        var attributes = effect.getAttributesNames();
        for (var index = 0; index < attributes.length; index++) {
            var location_1 = effect.getAttributeLocation(index);
            if (location_1 >= 0) {
                var kind = attributes[index];
                var vertexBuffer = vertexBuffers[kind];
                if (vertexBuffer) {
                    var buffer = vertexBuffer.getBuffer();
                    if (buffer) {
                        this._native.recordVertexBuffer(vertexArray, buffer.nativeVertexBuffer, location_1, vertexBuffer.byteOffset, vertexBuffer.byteStride, vertexBuffer.getSize(), vertexBuffer.type, vertexBuffer.normalized);
                    }
                }
            }
        }
        return vertexArray;
    };
    NativeEngine.prototype.bindVertexArrayObject = function (vertexArray) {
        this._native.bindVertexArray(vertexArray);
    };
    NativeEngine.prototype.releaseVertexArrayObject = function (vertexArray) {
        this._native.deleteVertexArray(vertexArray);
    };
    NativeEngine.prototype.getAttributes = function (pipelineContext, attributesNames) {
        var nativePipelineContext = pipelineContext;
        return this._native.getAttributes(nativePipelineContext.nativeProgram, attributesNames);
    };
    /**
     * Draw a list of indexed primitives
     * @param fillMode defines the primitive to use
     * @param indexStart defines the starting index
     * @param indexCount defines the number of index to draw
     * @param instancesCount defines the number of instances to draw (if instanciation is enabled)
     */
    NativeEngine.prototype.drawElementsType = function (fillMode, indexStart, indexCount, instancesCount) {
        // Apply states
        this._drawCalls.addCount(1, false);
        // TODO: Make this implementation more robust like core Engine version.
        // Render
        //var indexFormat = this._uintIndicesCurrentlySet ? this._gl.UNSIGNED_INT : this._gl.UNSIGNED_SHORT;
        //var mult = this._uintIndicesCurrentlySet ? 4 : 2;
        // if (instancesCount) {
        //     this._gl.drawElementsInstanced(drawMode, indexCount, indexFormat, indexStart * mult, instancesCount);
        // } else {
        this._native.drawIndexed(fillMode, indexStart, indexCount);
        // }
    };
    /**
     * Draw a list of unindexed primitives
     * @param fillMode defines the primitive to use
     * @param verticesStart defines the index of first vertex to draw
     * @param verticesCount defines the count of vertices to draw
     * @param instancesCount defines the number of instances to draw (if instanciation is enabled)
     */
    NativeEngine.prototype.drawArraysType = function (fillMode, verticesStart, verticesCount, instancesCount) {
        // Apply states
        this._drawCalls.addCount(1, false);
        // TODO: Make this implementation more robust like core Engine version.
        // if (instancesCount) {
        //     this._gl.drawArraysInstanced(drawMode, verticesStart, verticesCount, instancesCount);
        // } else {
        this._native.draw(fillMode, verticesStart, verticesCount);
        // }
    };
    NativeEngine.prototype.createPipelineContext = function () {
        return new NativePipelineContext();
    };
    NativeEngine.prototype._preparePipelineContext = function (pipelineContext, vertexSourceCode, fragmentSourceCode, createAsRaw, rebuildRebind, defines, transformFeedbackVaryings) {
        var nativePipelineContext = pipelineContext;
        if (createAsRaw) {
            nativePipelineContext.nativeProgram = this.createRawShaderProgram(pipelineContext, vertexSourceCode, fragmentSourceCode, undefined, transformFeedbackVaryings);
        }
        else {
            nativePipelineContext.nativeProgram = this.createShaderProgram(pipelineContext, vertexSourceCode, fragmentSourceCode, defines, undefined, transformFeedbackVaryings);
        }
    };
    /** @hidden */
    NativeEngine.prototype._isRenderingStateCompiled = function (pipelineContext) {
        // TODO: support async shader compilcation
        return true;
    };
    /** @hidden */
    NativeEngine.prototype._executeWhenRenderingStateIsCompiled = function (pipelineContext, action) {
        // TODO: support async shader compilcation
        action();
    };
    NativeEngine.prototype.createRawShaderProgram = function (pipelineContext, vertexCode, fragmentCode, context, transformFeedbackVaryings) {
        if (transformFeedbackVaryings === void 0) { transformFeedbackVaryings = null; }
        throw new Error("Not Supported");
    };
    NativeEngine.prototype.createShaderProgram = function (pipelineContext, vertexCode, fragmentCode, defines, context, transformFeedbackVaryings) {
        if (transformFeedbackVaryings === void 0) { transformFeedbackVaryings = null; }
        this.onBeforeShaderCompilationObservable.notifyObservers(this);
        var program = this._native.createProgram(ThinEngine._ConcatenateShader(vertexCode, defines), ThinEngine._ConcatenateShader(fragmentCode, defines));
        this.onAfterShaderCompilationObservable.notifyObservers(this);
        return program;
    };
    NativeEngine.prototype._setProgram = function (program) {
        if (this._currentProgram !== program) {
            this._native.setProgram(program);
            this._currentProgram = program;
        }
    };
    NativeEngine.prototype._releaseEffect = function (effect) {
        // TODO
    };
    NativeEngine.prototype._deletePipelineContext = function (pipelineContext) {
        // TODO
    };
    NativeEngine.prototype.getUniforms = function (pipelineContext, uniformsNames) {
        var nativePipelineContext = pipelineContext;
        return this._native.getUniforms(nativePipelineContext.nativeProgram, uniformsNames);
    };
    NativeEngine.prototype.bindUniformBlock = function (pipelineContext, blockName, index) {
        // TODO
        throw new Error("Not Implemented");
    };
    NativeEngine.prototype.bindSamplers = function (effect) {
        var nativePipelineContext = effect.getPipelineContext();
        this._setProgram(nativePipelineContext.nativeProgram);
        // TODO: share this with engine?
        var samplers = effect.getSamplers();
        for (var index = 0; index < samplers.length; index++) {
            var uniform = effect.getUniform(samplers[index]);
            if (uniform) {
                this._boundUniforms[index] = uniform;
            }
        }
        this._currentEffect = null;
    };
    NativeEngine.prototype.setMatrix = function (uniform, matrix) {
        if (!uniform) {
            return;
        }
        this._native.setMatrix(uniform, matrix.toArray());
    };
    NativeEngine.prototype.getRenderWidth = function (useScreen) {
        if (useScreen === void 0) { useScreen = false; }
        if (!useScreen && this._currentRenderTarget) {
            return this._currentRenderTarget.width;
        }
        return this._native.getRenderWidth();
    };
    NativeEngine.prototype.getRenderHeight = function (useScreen) {
        if (useScreen === void 0) { useScreen = false; }
        if (!useScreen && this._currentRenderTarget) {
            return this._currentRenderTarget.height;
        }
        return this._native.getRenderHeight();
    };
    NativeEngine.prototype.setViewport = function (viewport, requiredWidth, requiredHeight) {
        this._cachedViewport = viewport;
        this._native.setViewPort(viewport.x, viewport.y, viewport.width, viewport.height);
    };
    NativeEngine.prototype.setState = function (culling, zOffset, force, reverseSide) {
        if (zOffset === void 0) { zOffset = 0; }
        if (reverseSide === void 0) { reverseSide = false; }
        this._native.setState(culling, zOffset, reverseSide);
    };
    /**
     * Set the z offset to apply to current rendering
     * @param value defines the offset to apply
     */
    NativeEngine.prototype.setZOffset = function (value) {
        this._native.setZOffset(value);
    };
    /**
     * Gets the current value of the zOffset
     * @returns the current zOffset state
     */
    NativeEngine.prototype.getZOffset = function () {
        return this._native.getZOffset();
    };
    /**
     * Enable or disable depth buffering
     * @param enable defines the state to set
     */
    NativeEngine.prototype.setDepthBuffer = function (enable) {
        this._native.setDepthTest(enable);
    };
    /**
     * Gets a boolean indicating if depth writing is enabled
     * @returns the current depth writing state
     */
    NativeEngine.prototype.getDepthWrite = function () {
        return this._native.getDepthWrite();
    };
    /**
     * Enable or disable depth writing
     * @param enable defines the state to set
     */
    NativeEngine.prototype.setDepthWrite = function (enable) {
        this._native.setDepthWrite(enable);
    };
    /**
     * Enable or disable color writing
     * @param enable defines the state to set
     */
    NativeEngine.prototype.setColorWrite = function (enable) {
        this._native.setColorWrite(enable);
        this._colorWrite = enable;
    };
    /**
     * Gets a boolean indicating if color writing is enabled
     * @returns the current color writing state
     */
    NativeEngine.prototype.getColorWrite = function () {
        return this._colorWrite;
    };
    /**
     * Sets alpha constants used by some alpha blending modes
     * @param r defines the red component
     * @param g defines the green component
     * @param b defines the blue component
     * @param a defines the alpha component
     */
    NativeEngine.prototype.setAlphaConstants = function (r, g, b, a) {
        throw new Error("Setting alpha blend constant color not yet implemented.");
    };
    /**
     * Sets the current alpha mode
     * @param mode defines the mode to use (one of the BABYLON.undefined)
     * @param noDepthWriteChange defines if depth writing state should remains unchanged (false by default)
     * @see http://doc.babylonjs.com/resources/transparency_and_how_meshes_are_rendered
     */
    NativeEngine.prototype.setAlphaMode = function (mode, noDepthWriteChange) {
        if (noDepthWriteChange === void 0) { noDepthWriteChange = false; }
        if (this._alphaMode === mode) {
            return;
        }
        this._native.setBlendMode(mode);
        if (!noDepthWriteChange) {
            this.setDepthWrite(mode === 0);
        }
        this._alphaMode = mode;
    };
    /**
     * Gets the current alpha mode
     * @see http://doc.babylonjs.com/resources/transparency_and_how_meshes_are_rendered
     * @returns the current alpha mode
     */
    NativeEngine.prototype.getAlphaMode = function () {
        return this._alphaMode;
    };
    NativeEngine.prototype.setInt = function (uniform, int) {
        if (!uniform) {
            return;
        }
        this._native.setInt(uniform, int);
    };
    NativeEngine.prototype.setIntArray = function (uniform, array) {
        if (!uniform) {
            return;
        }
        this._native.setIntArray(uniform, array);
    };
    NativeEngine.prototype.setIntArray2 = function (uniform, array) {
        if (!uniform) {
            return;
        }
        this._native.setIntArray2(uniform, array);
    };
    NativeEngine.prototype.setIntArray3 = function (uniform, array) {
        if (!uniform) {
            return;
        }
        this._native.setIntArray3(uniform, array);
    };
    NativeEngine.prototype.setIntArray4 = function (uniform, array) {
        if (!uniform) {
            return;
        }
        this._native.setIntArray4(uniform, array);
    };
    NativeEngine.prototype.setFloatArray = function (uniform, array) {
        if (!uniform) {
            return;
        }
        this._native.setFloatArray(uniform, array);
    };
    NativeEngine.prototype.setFloatArray2 = function (uniform, array) {
        if (!uniform) {
            return;
        }
        this._native.setFloatArray2(uniform, array);
    };
    NativeEngine.prototype.setFloatArray3 = function (uniform, array) {
        if (!uniform) {
            return;
        }
        this._native.setFloatArray3(uniform, array);
    };
    NativeEngine.prototype.setFloatArray4 = function (uniform, array) {
        if (!uniform) {
            return;
        }
        this._native.setFloatArray4(uniform, array);
    };
    NativeEngine.prototype.setArray = function (uniform, array) {
        if (!uniform) {
            return;
        }
        this._native.setFloatArray(uniform, array);
    };
    NativeEngine.prototype.setArray2 = function (uniform, array) {
        if (!uniform) {
            return;
        }
        this._native.setFloatArray2(uniform, array);
    };
    NativeEngine.prototype.setArray3 = function (uniform, array) {
        if (!uniform) {
            return;
        }
        this._native.setFloatArray3(uniform, array);
    };
    NativeEngine.prototype.setArray4 = function (uniform, array) {
        if (!uniform) {
            return;
        }
        this._native.setFloatArray4(uniform, array);
    };
    NativeEngine.prototype.setMatrices = function (uniform, matrices) {
        if (!uniform) {
            return;
        }
        this._native.setMatrices(uniform, matrices);
    };
    NativeEngine.prototype.setMatrix3x3 = function (uniform, matrix) {
        if (!uniform) {
            return;
        }
        this._native.setMatrix3x3(uniform, matrix);
    };
    NativeEngine.prototype.setMatrix2x2 = function (uniform, matrix) {
        if (!uniform) {
            return;
        }
        this._native.setMatrix2x2(uniform, matrix);
    };
    NativeEngine.prototype.setFloat = function (uniform, value) {
        if (!uniform) {
            return;
        }
        this._native.setFloat(uniform, value);
    };
    NativeEngine.prototype.setFloat2 = function (uniform, x, y) {
        if (!uniform) {
            return;
        }
        this._native.setFloat2(uniform, x, y);
    };
    NativeEngine.prototype.setFloat3 = function (uniform, x, y, z) {
        if (!uniform) {
            return;
        }
        this._native.setFloat3(uniform, x, y, z);
    };
    NativeEngine.prototype.setFloat4 = function (uniform, x, y, z, w) {
        if (!uniform) {
            return;
        }
        this._native.setFloat4(uniform, x, y, z, w);
    };
    NativeEngine.prototype.setColor3 = function (uniform, color3) {
        if (!uniform) {
            return;
        }
        this._native.setFloat3(uniform, color3.r, color3.g, color3.b);
    };
    NativeEngine.prototype.setColor4 = function (uniform, color3, alpha) {
        if (!uniform) {
            return;
        }
        this._native.setFloat4(uniform, color3.r, color3.g, color3.b, alpha);
    };
    NativeEngine.prototype.wipeCaches = function (bruteForce) {
        if (this.preventCacheWipeBetweenFrames) {
            return;
        }
        this.resetTextureCache();
        this._currentEffect = null;
        if (bruteForce) {
            this._currentProgram = null;
            this._stencilState.reset();
            this._depthCullingState.reset();
            this._alphaState.reset();
        }
        this._cachedVertexBuffers = null;
        this._cachedIndexBuffer = null;
        this._cachedEffectForVertexBuffers = null;
    };
    NativeEngine.prototype._createTexture = function () {
        return this._native.createTexture();
    };
    NativeEngine.prototype._deleteTexture = function (texture) {
        this._native.deleteTexture(texture);
    };
    // TODO: Refactor to share more logic with babylon.engine.ts version.
    /**
     * Usually called from Texture.ts.
     * Passed information to create a WebGLTexture
     * @param urlArg defines a value which contains one of the following:
     * * A conventional http URL, e.g. 'http://...' or 'file://...'
     * * A base64 string of in-line texture data, e.g. 'data:image/jpg;base64,/...'
     * * An indicator that data being passed using the buffer parameter, e.g. 'data:mytexture.jpg'
     * @param noMipmap defines a boolean indicating that no mipmaps shall be generated.  Ignored for compressed textures.  They must be in the file
     * @param invertY when true, image is flipped when loaded.  You probably want true. Certain compressed textures may invert this if their default is inverted (eg. ktx)
     * @param scene needed for loading to the correct scene
     * @param samplingMode mode with should be used sample / access the texture (Default: Texture.TRILINEAR_SAMPLINGMODE)
     * @param onLoad optional callback to be called upon successful completion
     * @param onError optional callback to be called upon failure
     * @param buffer a source of a file previously fetched as either a base64 string, an ArrayBuffer (compressed or image format), HTMLImageElement (image format), or a Blob
     * @param fallback an internal argument in case the function must be called again, due to etc1 not having alpha capabilities
     * @param format internal format.  Default: RGB when extension is '.jpg' else RGBA.  Ignored for compressed textures
     * @param forcedExtension defines the extension to use to pick the right loader
     * @param mimeType defines an optional mime type
     * @returns a InternalTexture for assignment back into BABYLON.Texture
     */
    NativeEngine.prototype.createTexture = function (urlArg, noMipmap, invertY, scene, samplingMode, onLoad, onError, buffer, fallback, format, forcedExtension, mimeType) {
        var _this = this;
        if (samplingMode === void 0) { samplingMode = 3; }
        if (onLoad === void 0) { onLoad = null; }
        if (onError === void 0) { onError = null; }
        if (buffer === void 0) { buffer = null; }
        if (fallback === void 0) { fallback = null; }
        if (format === void 0) { format = null; }
        if (forcedExtension === void 0) { forcedExtension = null; }
        var url = String(urlArg); // assign a new string, so that the original is still available in case of fallback
        var fromData = url.substr(0, 5) === "data:";
        var fromBlob = url.substr(0, 5) === "blob:";
        var texture = fallback ? fallback : new InternalTexture(this, InternalTextureSource.Url);
        // establish the file extension, if possible
        var lastDot = url.lastIndexOf('.');
        var extension = forcedExtension ? forcedExtension : (lastDot > -1 ? url.substring(lastDot).toLowerCase() : "");
        var loader = null;
        for (var _i = 0, _a = Engine._TextureLoaders; _i < _a.length; _i++) {
            var availableLoader = _a[_i];
            if (availableLoader.canLoad(extension)) {
                loader = availableLoader;
                break;
            }
        }
        if (scene) {
            scene._addPendingData(texture);
        }
        texture.url = url;
        texture.generateMipMaps = !noMipmap;
        texture.samplingMode = samplingMode;
        texture.invertY = invertY;
        if (!this.doNotHandleContextLost) {
            // Keep a link to the buffer only if we plan to handle context lost
            texture._buffer = buffer;
        }
        var onLoadObserver = null;
        if (onLoad && !fallback) {
            onLoadObserver = texture.onLoadedObservable.add(onLoad);
        }
        if (!fallback) {
            this._internalTexturesCache.push(texture);
        }
        var onInternalError = function (message, exception) {
            if (scene) {
                scene._removePendingData(texture);
            }
            if (onLoadObserver) {
                texture.onLoadedObservable.remove(onLoadObserver);
            }
            if (Tools.UseFallbackTexture) {
                _this.createTexture(Tools.fallbackTexture, noMipmap, invertY, scene, samplingMode, null, onError, buffer, texture);
            }
            if (onError) {
                onError(message || "Unknown error", exception);
            }
        };
        // processing for non-image formats
        if (loader) {
            throw new Error("Loading textures from IInternalTextureLoader not yet implemented.");
            // var callback = (data: string | ArrayBuffer) => {
            //     loader!.loadData(data as ArrayBuffer, texture, (width: number, height: number, loadMipmap: boolean, isCompressed: boolean, done: () => void) => {
            //         this._prepareWebGLTexture(texture, scene, width, height, invertY, !loadMipmap, isCompressed, () => {
            //                 done();
            //                 return false;
            //             },
            //             samplingMode);
            //     });
            // }
            // if (!buffer) {
            //     this._loadFile(url, callback, undefined, scene ? scene.database : undefined, true, (request?: XMLHttpRequest, exception?: any) => {
            //         onInternalError("Unable to load " + (request ? request.responseURL : url, exception));
            //     });
            // } else {
            //     callback(buffer as ArrayBuffer);
            // }
        }
        else {
            var onload = function (data, responseURL) {
                if (typeof (data) === "string") {
                    throw new Error("Loading textures from string data not yet implemented.");
                }
                if (fromBlob && !_this.doNotHandleContextLost) {
                    // We need to store the image if we need to rebuild the texture
                    // in case of a webgl context lost
                    texture._buffer = data;
                }
                var webGLTexture = texture._webGLTexture;
                if (!webGLTexture) {
                    //  this.resetTextureCache();
                    if (scene) {
                        scene._removePendingData(texture);
                    }
                    return;
                }
                if (!_this._native.loadTexture(webGLTexture, data, !noMipmap, invertY)) {
                    throw new Error("Could not load a native texture.");
                }
                texture.baseWidth = _this._native.getTextureWidth(webGLTexture);
                texture.baseHeight = _this._native.getTextureHeight(webGLTexture);
                texture.width = texture.baseWidth;
                texture.height = texture.baseHeight;
                texture.isReady = true;
                var filter = _this._getSamplingFilter(samplingMode);
                _this._native.setTextureSampling(webGLTexture, filter);
                // this.resetTextureCache();
                if (scene) {
                    scene._removePendingData(texture);
                }
                texture.onLoadedObservable.notifyObservers(texture);
                texture.onLoadedObservable.clear();
            };
            if (buffer instanceof ArrayBuffer) {
                onload(buffer);
            }
            else if (ArrayBuffer.isView(buffer)) {
                onload(buffer.buffer);
            }
            else if (buffer instanceof Blob) {
                throw new Error("Loading texture from Blob not yet implemented.");
            }
            else if (!fromData) {
                var onLoadFileError = function (request, exception) {
                    onInternalError("Failed to retrieve " + url + ".", exception);
                };
                Tools.LoadFile(url, onload, undefined, undefined, /*useArrayBuffer*/ true, onLoadFileError);
            }
            else {
                onload(Tools.DecodeBase64(buffer));
            }
        }
        return texture;
    };
    /**
     * Creates a cube texture
     * @param rootUrl defines the url where the files to load is located
     * @param scene defines the current scene
     * @param files defines the list of files to load (1 per face)
     * @param noMipmap defines a boolean indicating that no mipmaps shall be generated (false by default)
     * @param onLoad defines an optional callback raised when the texture is loaded
     * @param onError defines an optional callback raised if there is an issue to load the texture
     * @param format defines the format of the data
     * @param forcedExtension defines the extension to use to pick the right loader
     * @param createPolynomials if a polynomial sphere should be created for the cube texture
     * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness
     * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness
     * @param fallback defines texture to use while falling back when (compressed) texture file not found.
     * @returns the cube texture as an InternalTexture
     */
    NativeEngine.prototype.createCubeTexture = function (rootUrl, scene, files, noMipmap, onLoad, onError, format, forcedExtension, createPolynomials, lodScale, lodOffset, fallback) {
        var _this = this;
        if (onLoad === void 0) { onLoad = null; }
        if (onError === void 0) { onError = null; }
        if (forcedExtension === void 0) { forcedExtension = null; }
        if (createPolynomials === void 0) { createPolynomials = false; }
        if (lodScale === void 0) { lodScale = 0; }
        if (lodOffset === void 0) { lodOffset = 0; }
        if (fallback === void 0) { fallback = null; }
        var texture = fallback ? fallback : new InternalTexture(this, InternalTextureSource.Cube);
        texture.isCube = true;
        texture.url = rootUrl;
        texture.generateMipMaps = !noMipmap;
        texture._lodGenerationScale = lodScale;
        texture._lodGenerationOffset = lodOffset;
        if (!this._doNotHandleContextLost) {
            texture._extension = forcedExtension;
            texture._files = files;
        }
        var lastDot = rootUrl.lastIndexOf('.');
        var extension = forcedExtension ? forcedExtension : (lastDot > -1 ? rootUrl.substring(lastDot).toLowerCase() : "");
        // TODO: use texture loader to load env files?
        if (extension === ".env") {
            var onloaddata_1 = function (data) {
                var info = EnvironmentTextureTools.GetEnvInfo(data);
                texture.width = info.width;
                texture.height = info.width;
                EnvironmentTextureTools.UploadEnvSpherical(texture, info);
                if (info.version !== 1) {
                    throw new Error("Unsupported babylon environment map version \"" + info.version + "\"");
                }
                var specularInfo = info.specular;
                if (!specularInfo) {
                    throw new Error("Nothing else parsed so far");
                }
                texture._lodGenerationScale = specularInfo.lodGenerationScale;
                var imageData = EnvironmentTextureTools.CreateImageDataArrayBufferViews(data, info);
                texture.format = 5;
                texture.type = 0;
                texture.generateMipMaps = true;
                texture.getEngine().updateTextureSamplingMode(Texture.TRILINEAR_SAMPLINGMODE, texture);
                texture._isRGBD = true;
                texture.invertY = true;
                if (!_this._native.loadEnvTexture(texture._webGLTexture, imageData)) {
                    throw new Error("Could not load a native cube texture.");
                }
                texture.isReady = true;
                if (onLoad) {
                    onLoad();
                }
            };
            if (files && files.length === 6) {
                throw new Error("Multi-file loading not allowed on env files.");
            }
            else {
                var onInternalError = function (request, exception) {
                    if (onError && request) {
                        onError(request.status + " " + request.statusText, exception);
                    }
                };
                this._loadFile(rootUrl, function (data) { return onloaddata_1(new Uint8Array(data)); }, undefined, undefined, true, onInternalError);
            }
        }
        else {
            if (!files || files.length !== 6) {
                throw new Error("Cannot load cubemap because 6 files were not defined");
            }
            // Reorder from [+X, +Y, +Z, -X, -Y, -Z] to [+X, -X, +Y, -Y, +Z, -Z].
            var reorderedFiles = [files[0], files[3], files[1], files[4], files[2], files[5]];
            Promise.all(reorderedFiles.map(function (file) { return Tools.LoadFileAsync(file).then(function (data) { return new Uint8Array(data); }); })).then(function (data) {
                _this._native.loadCubeTexture(texture._webGLTexture, data, !noMipmap);
            }).then(function () {
                texture.isReady = true;
                if (onLoad) {
                    onLoad();
                }
            }, function (error) {
                if (onError) {
                    onError("Failed to load cubemap: " + error.message, error);
                }
            });
        }
        this._internalTexturesCache.push(texture);
        return texture;
    };
    // Returns a NativeFilter.XXXX value.
    NativeEngine.prototype._getSamplingFilter = function (samplingMode) {
        switch (samplingMode) {
            case 2:
                return NativeFilter.MINLINEAR_MAGLINEAR_MIPPOINT;
            case 3:
                return NativeFilter.MINLINEAR_MAGLINEAR_MIPLINEAR;
            case 1:
                return NativeFilter.MINPOINT_MAGPOINT_MIPLINEAR;
            case 4:
                return NativeFilter.MINPOINT_MAGPOINT_MIPPOINT;
            case 5:
                return NativeFilter.MINLINEAR_MAGPOINT_MIPPOINT;
            case 6:
                return NativeFilter.MINLINEAR_MAGPOINT_MIPLINEAR;
            case 7:
                return NativeFilter.MINLINEAR_MAGPOINT_MIPLINEAR;
            case 1:
                return NativeFilter.MINPOINT_MAGPOINT_MIPPOINT;
            case 9:
                return NativeFilter.MINPOINT_MAGLINEAR_MIPPOINT;
            case 10:
                return NativeFilter.MINPOINT_MAGLINEAR_MIPLINEAR;
            case 2:
                return NativeFilter.MINLINEAR_MAGLINEAR_MIPLINEAR;
            case 12:
                return NativeFilter.MINPOINT_MAGLINEAR_MIPLINEAR;
            default:
                throw new Error("Unexpected sampling mode: " + samplingMode + ".");
        }
    };
    NativeEngine._GetNativeTextureFormat = function (format, type) {
        if (format == 5 && type == 0) {
            return NativeTextureFormat.RGBA8;
        }
        else if (format == 5 && type == 1) {
            return NativeTextureFormat.RGBA32F;
        }
        else {
            throw new Error("Unexpected texture format or type: format " + format + ", type " + type + ".");
        }
    };
    NativeEngine.prototype.createRenderTargetTexture = function (size, options) {
        var fullOptions = new RenderTargetCreationOptions();
        if (options !== undefined && typeof options === "object") {
            fullOptions.generateMipMaps = options.generateMipMaps;
            fullOptions.generateDepthBuffer = options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;
            fullOptions.generateStencilBuffer = fullOptions.generateDepthBuffer && options.generateStencilBuffer;
            fullOptions.type = options.type === undefined ? 0 : options.type;
            fullOptions.samplingMode = options.samplingMode === undefined ? 3 : options.samplingMode;
            fullOptions.format = options.format === undefined ? 5 : options.format;
        }
        else {
            fullOptions.generateMipMaps = options;
            fullOptions.generateDepthBuffer = true;
            fullOptions.generateStencilBuffer = false;
            fullOptions.type = 0;
            fullOptions.samplingMode = 3;
            fullOptions.format = 5;
        }
        if (fullOptions.type === 1 && !this._caps.textureFloatLinearFiltering) {
            // if floating point linear (gl.FLOAT) then force to NEAREST_SAMPLINGMODE
            fullOptions.samplingMode = 1;
        }
        else if (fullOptions.type === 2 && !this._caps.textureHalfFloatLinearFiltering) {
            // if floating point linear (HALF_FLOAT) then force to NEAREST_SAMPLINGMODE
            fullOptions.samplingMode = 1;
        }
        var texture = new NativeTexture(this, InternalTextureSource.RenderTarget);
        var width = size.width || size;
        var height = size.height || size;
        if (fullOptions.type === 1 && !this._caps.textureFloat) {
            fullOptions.type = 0;
            Logger.Warn("Float textures are not supported. Render target forced to TEXTURETYPE_UNSIGNED_BYTE type");
        }
        var framebuffer = this._native.createFramebuffer(texture._webGLTexture, width, height, NativeEngine._GetNativeTextureFormat(fullOptions.format, fullOptions.type), fullOptions.samplingMode, fullOptions.generateStencilBuffer ? true : false, fullOptions.generateDepthBuffer, fullOptions.generateMipMaps ? true : false);
        texture._framebuffer = framebuffer;
        texture.baseWidth = width;
        texture.baseHeight = height;
        texture.width = width;
        texture.height = height;
        texture.isReady = true;
        texture.samples = 1;
        texture.generateMipMaps = fullOptions.generateMipMaps ? true : false;
        texture.samplingMode = fullOptions.samplingMode;
        texture.type = fullOptions.type;
        texture.format = fullOptions.format;
        texture._generateDepthBuffer = fullOptions.generateDepthBuffer;
        texture._generateStencilBuffer = fullOptions.generateStencilBuffer ? true : false;
        this._internalTexturesCache.push(texture);
        return texture;
    };
    NativeEngine.prototype.updateTextureSamplingMode = function (samplingMode, texture) {
        if (texture._webGLTexture) {
            var filter = this._getSamplingFilter(samplingMode);
            this._native.setTextureSampling(texture._webGLTexture, filter);
        }
        texture.samplingMode = samplingMode;
    };
    NativeEngine.prototype.bindFramebuffer = function (texture, faceIndex, requiredWidth, requiredHeight, forceFullscreenViewport) {
        if (faceIndex) {
            throw new Error("Cuboid frame buffers are not yet supported in NativeEngine.");
        }
        if (requiredWidth || requiredHeight) {
            throw new Error("Required width/height for frame buffers not yet supported in NativeEngine.");
        }
        if (forceFullscreenViewport) {
            throw new Error("forceFullscreenViewport for frame buffers not yet supported in NativeEngine.");
        }
        this._bindUnboundFramebuffer(texture._framebuffer);
    };
    NativeEngine.prototype.unBindFramebuffer = function (texture, disableGenerateMipMaps, onBeforeUnbind) {
        if (disableGenerateMipMaps === void 0) { disableGenerateMipMaps = false; }
        if (disableGenerateMipMaps) {
            Logger.Warn("Disabling mipmap generation not yet supported in NativeEngine. Ignoring.");
        }
        if (onBeforeUnbind) {
            onBeforeUnbind();
        }
        this._bindUnboundFramebuffer(null);
    };
    NativeEngine.prototype.createDynamicVertexBuffer = function (data) {
        throw new Error("createDynamicVertexBuffer not yet implemented.");
    };
    NativeEngine.prototype.updateDynamicIndexBuffer = function (indexBuffer, indices, offset) {
        if (offset === void 0) { offset = 0; }
        throw new Error("updateDynamicIndexBuffer not yet implemented.");
    };
    /**
     * Updates a dynamic vertex buffer.
     * @param vertexBuffer the vertex buffer to update
     * @param data the data used to update the vertex buffer
     * @param byteOffset the byte offset of the data (optional)
     * @param byteLength the byte length of the data (optional)
     */
    NativeEngine.prototype.updateDynamicVertexBuffer = function (vertexBuffer, data, byteOffset, byteLength) {
        throw new Error("updateDynamicVertexBuffer not yet implemented.");
    };
    // TODO: Refactor to share more logic with base Engine implementation.
    NativeEngine.prototype._setTexture = function (channel, texture, isPartOfTextureArray, depthStencilTexture) {
        if (isPartOfTextureArray === void 0) { isPartOfTextureArray = false; }
        if (depthStencilTexture === void 0) { depthStencilTexture = false; }
        var uniform = this._boundUniforms[channel];
        if (!uniform) {
            return false;
        }
        // Not ready?
        if (!texture) {
            if (this._boundTexturesCache[channel] != null) {
                this._activeChannel = channel;
                this._native.setTexture(uniform, null);
            }
            return false;
        }
        // Video
        if (texture.video) {
            this._activeChannel = channel;
            texture.update();
        }
        else if (texture.delayLoadState === 4) { // Delay loading
            texture.delayLoad();
            return false;
        }
        var internalTexture;
        if (depthStencilTexture) {
            internalTexture = texture.depthStencilTexture;
        }
        else if (texture.isReady()) {
            internalTexture = texture.getInternalTexture();
        }
        else if (texture.isCube) {
            internalTexture = this.emptyCubeTexture;
        }
        else if (texture.is3D) {
            internalTexture = this.emptyTexture3D;
        }
        else if (texture.is2DArray) {
            internalTexture = this.emptyTexture2DArray;
        }
        else {
            internalTexture = this.emptyTexture;
        }
        this._activeChannel = channel;
        if (!internalTexture ||
            !internalTexture._webGLTexture) {
            return false;
        }
        this._native.setTextureWrapMode(internalTexture._webGLTexture, this._getAddressMode(texture.wrapU), this._getAddressMode(texture.wrapV), this._getAddressMode(texture.wrapR));
        this._updateAnisotropicLevel(texture);
        this._native.setTexture(uniform, internalTexture._webGLTexture);
        return true;
    };
    // TODO: Share more of this logic with the base implementation.
    // TODO: Rename to match naming in base implementation once refactoring allows different parameters.
    NativeEngine.prototype._updateAnisotropicLevel = function (texture) {
        var internalTexture = texture.getInternalTexture();
        var value = texture.anisotropicFilteringLevel;
        if (!internalTexture || !internalTexture._webGLTexture) {
            return;
        }
        if (internalTexture._cachedAnisotropicFilteringLevel !== value) {
            this._native.setTextureAnisotropicLevel(internalTexture._webGLTexture, value);
            internalTexture._cachedAnisotropicFilteringLevel = value;
        }
    };
    // Returns a NativeAddressMode.XXX value.
    NativeEngine.prototype._getAddressMode = function (wrapMode) {
        switch (wrapMode) {
            case 1:
                return NativeAddressMode.WRAP;
            case 0:
                return NativeAddressMode.CLAMP;
            case 2:
                return NativeAddressMode.MIRROR;
            default:
                throw new Error("Unexpected wrap mode: " + wrapMode + ".");
        }
    };
    /** @hidden */
    NativeEngine.prototype._bindTexture = function (channel, texture) {
        throw new Error("_bindTexture not implemented.");
    };
    NativeEngine.prototype._deleteBuffer = function (buffer) {
        if (buffer.nativeIndexBuffer) {
            this._native.deleteIndexBuffer(buffer.nativeIndexBuffer);
            delete buffer.nativeIndexBuffer;
        }
        if (buffer.nativeVertexBuffer) {
            this._native.deleteVertexBuffer(buffer.nativeVertexBuffer);
            delete buffer.nativeVertexBuffer;
        }
    };
    NativeEngine.prototype.releaseEffects = function () {
        // TODO
    };
    /** @hidden */
    NativeEngine.prototype._uploadCompressedDataToTextureDirectly = function (texture, internalFormat, width, height, data, faceIndex, lod) {
        if (faceIndex === void 0) { faceIndex = 0; }
        if (lod === void 0) { lod = 0; }
        throw new Error("_uploadCompressedDataToTextureDirectly not implemented.");
    };
    /** @hidden */
    NativeEngine.prototype._uploadDataToTextureDirectly = function (texture, imageData, faceIndex, lod) {
        if (faceIndex === void 0) { faceIndex = 0; }
        if (lod === void 0) { lod = 0; }
        throw new Error("_uploadDataToTextureDirectly not implemented.");
    };
    /** @hidden */
    NativeEngine.prototype._uploadArrayBufferViewToTexture = function (texture, imageData, faceIndex, lod) {
        if (faceIndex === void 0) { faceIndex = 0; }
        if (lod === void 0) { lod = 0; }
        throw new Error("_uploadArrayBufferViewToTexture not implemented.");
    };
    /** @hidden */
    NativeEngine.prototype._uploadImageToTexture = function (texture, image, faceIndex, lod) {
        if (faceIndex === void 0) { faceIndex = 0; }
        if (lod === void 0) { lod = 0; }
        throw new Error("_uploadArrayBufferViewToTexture not implemented.");
    };
    return NativeEngine;
}(Engine));
export { NativeEngine };
//# sourceMappingURL=nativeEngine.js.map