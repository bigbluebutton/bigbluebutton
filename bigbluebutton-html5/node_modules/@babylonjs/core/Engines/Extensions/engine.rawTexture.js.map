{"version":3,"file":"engine.rawTexture.js","sourceRoot":"","sources":["../../../../sourceES6/core/Engines/Extensions/engine.rawTexture.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../../types\";\r\nimport { InternalTexture, InternalTextureSource } from '../../Materials/Textures/internalTexture';\r\nimport { Logger } from '../../Misc/logger';\r\nimport { Tools } from '../../Misc/tools';\r\nimport { Scene } from '../../scene';\r\n\r\nimport { Engine } from '../engine';\r\nimport { IWebRequest } from '../../Misc/interfaces/iWebRequest';\r\n\r\ndeclare module \"../../Engines/engine\" {\r\n    export interface Engine {\r\n        /**\r\n         * Creates a raw texture\r\n         * @param data defines the data to store in the texture\r\n         * @param width defines the width of the texture\r\n         * @param height defines the height of the texture\r\n         * @param format defines the format of the data\r\n         * @param generateMipMaps defines if the engine should generate the mip levels\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param samplingMode defines the required sampling mode (Texture.NEAREST_SAMPLINGMODE by default)\r\n         * @param compression defines the compression used (null by default)\r\n         * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n         * @returns the raw texture inside an InternalTexture\r\n         */\r\n        createRawTexture(data: Nullable<ArrayBufferView>, width: number, height: number, format: number, generateMipMaps: boolean, invertY: boolean, samplingMode: number, compression: Nullable<string>, type: number): InternalTexture;\r\n\r\n        /**\r\n         * Update a raw texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store in the texture\r\n         * @param format defines the format of the data\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         */\r\n        updateRawTexture(texture: Nullable<InternalTexture>, data: Nullable<ArrayBufferView>, format: number, invertY: boolean): void;\r\n\r\n        /**\r\n         * Update a raw texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store in the texture\r\n         * @param format defines the format of the data\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the compression used (null by default)\r\n         * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n         */\r\n        updateRawTexture(texture: Nullable<InternalTexture>, data: Nullable<ArrayBufferView>, format: number, invertY: boolean, compression: Nullable<string>, type: number): void;\r\n\r\n        /**\r\n         * Creates a new raw cube texture\r\n         * @param data defines the array of data to use to create each face\r\n         * @param size defines the size of the textures\r\n         * @param format defines the format of the data\r\n         * @param type defines the type of the data (like Engine.TEXTURETYPE_UNSIGNED_INT)\r\n         * @param generateMipMaps  defines if the engine should generate the mip levels\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\r\n         * @param compression defines the compression used (null by default)\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createRawCubeTexture(data: Nullable<ArrayBufferView[]>, size: number, format: number, type: number, generateMipMaps: boolean, invertY: boolean, samplingMode: number, compression: Nullable<string>): InternalTexture;\r\n\r\n        /**\r\n         * Update a raw cube texture\r\n         * @param texture defines the texture to udpdate\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         */\r\n        updateRawCubeTexture(texture: InternalTexture, data: ArrayBufferView[], format: number, type: number, invertY: boolean): void;\r\n\r\n        /**\r\n         * Update a raw cube texture\r\n         * @param texture defines the texture to udpdate\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the compression used (null by default)\r\n         */\r\n        updateRawCubeTexture(texture: InternalTexture, data: ArrayBufferView[], format: number, type: number, invertY: boolean, compression: Nullable<string>): void;\r\n\r\n        /**\r\n         * Update a raw cube texture\r\n         * @param texture defines the texture to udpdate\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the compression used (null by default)\r\n         * @param level defines which level of the texture to update\r\n         */\r\n        updateRawCubeTexture(texture: InternalTexture, data: ArrayBufferView[], format: number, type: number, invertY: boolean, compression: Nullable<string>, level: number): void;\r\n\r\n        /**\r\n         * Creates a new raw cube texture from a specified url\r\n         * @param url defines the url where the data is located\r\n         * @param scene defines the current scene\r\n         * @param size defines the size of the textures\r\n         * @param format defines the format of the data\r\n         * @param type defines the type fo the data (like Engine.TEXTURETYPE_UNSIGNED_INT)\r\n         * @param noMipmap defines if the engine should avoid generating the mip levels\r\n         * @param callback defines a callback used to extract texture data from loaded data\r\n         * @param mipmapGenerator defines to provide an optional tool to generate mip levels\r\n         * @param onLoad defines a callback called when texture is loaded\r\n         * @param onError defines a callback called if there is an error\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createRawCubeTextureFromUrl(url: string, scene: Scene, size: number, format: number, type: number, noMipmap: boolean,\r\n            callback: (ArrayBuffer: ArrayBuffer) => Nullable<ArrayBufferView[]>,\r\n            mipmapGenerator: Nullable<((faces: ArrayBufferView[]) => ArrayBufferView[][])>,\r\n            onLoad: Nullable<() => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>): InternalTexture;\r\n\r\n        /**\r\n         * Creates a new raw cube texture from a specified url\r\n         * @param url defines the url where the data is located\r\n         * @param scene defines the current scene\r\n         * @param size defines the size of the textures\r\n         * @param format defines the format of the data\r\n         * @param type defines the type fo the data (like Engine.TEXTURETYPE_UNSIGNED_INT)\r\n         * @param noMipmap defines if the engine should avoid generating the mip levels\r\n         * @param callback defines a callback used to extract texture data from loaded data\r\n         * @param mipmapGenerator defines to provide an optional tool to generate mip levels\r\n         * @param onLoad defines a callback called when texture is loaded\r\n         * @param onError defines a callback called if there is an error\r\n         * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createRawCubeTextureFromUrl(url: string, scene: Scene, size: number, format: number, type: number, noMipmap: boolean,\r\n            callback: (ArrayBuffer: ArrayBuffer) => Nullable<ArrayBufferView[]>,\r\n            mipmapGenerator: Nullable<((faces: ArrayBufferView[]) => ArrayBufferView[][])>,\r\n            onLoad: Nullable<() => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            samplingMode: number,\r\n            invertY: boolean): InternalTexture;\r\n\r\n        /**\r\n         * Creates a new raw 3D texture\r\n         * @param data defines the data used to create the texture\r\n         * @param width defines the width of the texture\r\n         * @param height defines the height of the texture\r\n         * @param depth defines the depth of the texture\r\n         * @param format defines the format of the texture\r\n         * @param generateMipMaps defines if the engine must generate mip levels\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\r\n         * @param compression defines the compressed used (can be null)\r\n         * @param textureType defines the compressed used (can be null)\r\n         * @returns a new raw 3D texture (stored in an InternalTexture)\r\n         */\r\n        createRawTexture3D(data: Nullable<ArrayBufferView>, width: number, height: number, depth: number, format: number, generateMipMaps: boolean, invertY: boolean, samplingMode: number, compression: Nullable<string>, textureType: number): InternalTexture;\r\n\r\n        /**\r\n         * Update a raw 3D texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         */\r\n        updateRawTexture3D(texture: InternalTexture, data: Nullable<ArrayBufferView>, format: number, invertY: boolean): void;\r\n\r\n        /**\r\n         * Update a raw 3D texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the used compression (can be null)\r\n         * @param textureType defines the texture Type (Engine.TEXTURETYPE_UNSIGNED_INT, Engine.TEXTURETYPE_FLOAT...)\r\n         */\r\n        updateRawTexture3D(texture: InternalTexture, data: Nullable<ArrayBufferView>, format: number, invertY: boolean, compression: Nullable<string>, textureType: number): void;\r\n\r\n        /**\r\n         * Creates a new raw 2D array texture\r\n         * @param data defines the data used to create the texture\r\n         * @param width defines the width of the texture\r\n         * @param height defines the height of the texture\r\n         * @param depth defines the number of layers of the texture\r\n         * @param format defines the format of the texture\r\n         * @param generateMipMaps defines if the engine must generate mip levels\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\r\n         * @param compression defines the compressed used (can be null)\r\n         * @param textureType defines the compressed used (can be null)\r\n         * @returns a new raw 2D array texture (stored in an InternalTexture)\r\n         */\r\n        createRawTexture2DArray(data: Nullable<ArrayBufferView>, width: number, height: number, depth: number, format: number, generateMipMaps: boolean, invertY: boolean, samplingMode: number, compression: Nullable<string>, textureType: number): InternalTexture;\r\n\r\n        /**\r\n         * Update a raw 2D array texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         */\r\n        updateRawTexture2DArray(texture: InternalTexture, data: Nullable<ArrayBufferView>, format: number, invertY: boolean): void;\r\n\r\n        /**\r\n         * Update a raw 2D array texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the used compression (can be null)\r\n         * @param textureType defines the texture Type (Engine.TEXTURETYPE_UNSIGNED_INT, Engine.TEXTURETYPE_FLOAT...)\r\n         */\r\n        updateRawTexture2DArray(texture: InternalTexture, data: Nullable<ArrayBufferView>, format: number, invertY: boolean, compression: Nullable<string>, textureType: number): void;\r\n    }\r\n}\r\n\r\nEngine.prototype.updateRawTexture = function(texture: Nullable<InternalTexture>, data: Nullable<ArrayBufferView>, format: number, invertY: boolean, compression: Nullable<string> = null, type: number = 0): void {\r\n    if (!texture) {\r\n        return;\r\n    }\r\n    // Babylon's internalSizedFomat but gl's texImage2D internalFormat\r\n    var internalSizedFomat = this._getRGBABufferInternalSizedFormat(type, format);\r\n\r\n    // Babylon's internalFormat but gl's texImage2D format\r\n    var internalFormat = this._getInternalFormat(format);\r\n    var textureType = this._getWebGLTextureType(type);\r\n    this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);\r\n    this._unpackFlipY(invertY === undefined ? true : (invertY ? true : false));\r\n\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferView = data;\r\n        texture.format = format;\r\n        texture.type = type;\r\n        texture.invertY = invertY;\r\n        texture._compression = compression;\r\n    }\r\n\r\n    if (texture.width % 4 !== 0) {\r\n        this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, 1);\r\n    }\r\n\r\n    if (compression && data) {\r\n        this._gl.compressedTexImage2D(this._gl.TEXTURE_2D, 0, (<any>this.getCaps().s3tc)[compression], texture.width, texture.height, 0, <DataView>data);\r\n    } else {\r\n        this._gl.texImage2D(this._gl.TEXTURE_2D, 0, internalSizedFomat, texture.width, texture.height, 0, internalFormat, textureType, data);\r\n    }\r\n\r\n    if (texture.generateMipMaps) {\r\n        this._gl.generateMipmap(this._gl.TEXTURE_2D);\r\n    }\r\n    this._bindTextureDirectly(this._gl.TEXTURE_2D, null);\r\n    //  this.resetTextureCache();\r\n    texture.isReady = true;\r\n};\r\n\r\nEngine.prototype.createRawTexture = function(data: Nullable<ArrayBufferView>, width: number, height: number, format: number, generateMipMaps: boolean, invertY: boolean, samplingMode: number, compression: Nullable<string> = null, type: number = 0): InternalTexture {\r\n    var texture = new InternalTexture(this, InternalTextureSource.Raw);\r\n    texture.baseWidth = width;\r\n    texture.baseHeight = height;\r\n    texture.width = width;\r\n    texture.height = height;\r\n    texture.format = format;\r\n    texture.generateMipMaps = generateMipMaps;\r\n    texture.samplingMode = samplingMode;\r\n    texture.invertY = invertY;\r\n    texture._compression = compression;\r\n    texture.type = type;\r\n\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferView = data;\r\n    }\r\n\r\n    this.updateRawTexture(texture, data, format, invertY, compression, type);\r\n    this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);\r\n\r\n    // Filters\r\n    var filters = this._getSamplingParameters(samplingMode, generateMipMaps);\r\n\r\n    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, filters.mag);\r\n    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, filters.min);\r\n\r\n    if (generateMipMaps) {\r\n        this._gl.generateMipmap(this._gl.TEXTURE_2D);\r\n    }\r\n\r\n    this._bindTextureDirectly(this._gl.TEXTURE_2D, null);\r\n\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    return texture;\r\n};\r\n\r\nEngine.prototype.createRawCubeTexture = function(data: Nullable<ArrayBufferView[]>, size: number, format: number, type: number,\r\n    generateMipMaps: boolean, invertY: boolean, samplingMode: number,\r\n    compression: Nullable<string> = null): InternalTexture {\r\n    var gl = this._gl;\r\n    var texture = new InternalTexture(this, InternalTextureSource.CubeRaw);\r\n    texture.isCube = true;\r\n    texture.format = format;\r\n    texture.type = type;\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferViewArray = data;\r\n    }\r\n\r\n    var textureType = this._getWebGLTextureType(type);\r\n    var internalFormat = this._getInternalFormat(format);\r\n\r\n    if (internalFormat === gl.RGB) {\r\n        internalFormat = gl.RGBA;\r\n    }\r\n\r\n    // Mipmap generation needs a sized internal format that is both color-renderable and texture-filterable\r\n    if (textureType === gl.FLOAT && !this._caps.textureFloatLinearFiltering) {\r\n        generateMipMaps = false;\r\n        samplingMode = 1;\r\n        Logger.Warn(\"Float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.\");\r\n    }\r\n    else if (textureType === this._gl.HALF_FLOAT_OES && !this._caps.textureHalfFloatLinearFiltering) {\r\n        generateMipMaps = false;\r\n        samplingMode = 1;\r\n        Logger.Warn(\"Half float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.\");\r\n    }\r\n    else if (textureType === gl.FLOAT && !this._caps.textureFloatRender) {\r\n        generateMipMaps = false;\r\n        Logger.Warn(\"Render to float textures is not supported. Mipmap generation forced to false.\");\r\n    }\r\n    else if (textureType === gl.HALF_FLOAT && !this._caps.colorBufferFloat) {\r\n        generateMipMaps = false;\r\n        Logger.Warn(\"Render to half float textures is not supported. Mipmap generation forced to false.\");\r\n    }\r\n\r\n    var width = size;\r\n    var height = width;\r\n\r\n    texture.width = width;\r\n    texture.height = height;\r\n\r\n    // Double check on POT to generate Mips.\r\n    var isPot = !this.needPOTTextures || (Tools.IsExponentOfTwo(texture.width) && Tools.IsExponentOfTwo(texture.height));\r\n    if (!isPot) {\r\n        generateMipMaps = false;\r\n    }\r\n\r\n    // Upload data if needed. The texture won't be ready until then.\r\n    if (data) {\r\n        this.updateRawCubeTexture(texture, data, format, type, invertY, compression);\r\n    }\r\n\r\n    this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, texture, true);\r\n\r\n    // Filters\r\n    if (data && generateMipMaps) {\r\n        this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP);\r\n    }\r\n\r\n    var filters = this._getSamplingParameters(samplingMode, generateMipMaps);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, filters.mag);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, filters.min);\r\n\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\r\n\r\n    texture.generateMipMaps = generateMipMaps;\r\n\r\n    return texture;\r\n};\r\n\r\nEngine.prototype.updateRawCubeTexture = function(texture: InternalTexture, data: ArrayBufferView[], format: number, type: number, invertY: boolean, compression: Nullable<string> = null, level: number = 0): void {\r\n    texture._bufferViewArray = data;\r\n    texture.format = format;\r\n    texture.type = type;\r\n    texture.invertY = invertY;\r\n    texture._compression = compression;\r\n\r\n    var gl = this._gl;\r\n    var textureType = this._getWebGLTextureType(type);\r\n    var internalFormat = this._getInternalFormat(format);\r\n    var internalSizedFomat = this._getRGBABufferInternalSizedFormat(type);\r\n\r\n    var needConversion = false;\r\n    if (internalFormat === gl.RGB) {\r\n        internalFormat = gl.RGBA;\r\n        needConversion = true;\r\n    }\r\n\r\n    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);\r\n    this._unpackFlipY(invertY === undefined ? true : (invertY ? true : false));\r\n\r\n    if (texture.width % 4 !== 0) {\r\n        gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);\r\n    }\r\n\r\n    // Data are known to be in +X +Y +Z -X -Y -Z\r\n    for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\r\n        let faceData = data[faceIndex];\r\n\r\n        if (compression) {\r\n            gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, level, (<any>(this.getCaps().s3tc))[compression], texture.width, texture.height, 0, <DataView>faceData);\r\n        } else {\r\n            if (needConversion) {\r\n                faceData = this._convertRGBtoRGBATextureData(faceData, texture.width, texture.height, type);\r\n            }\r\n            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, level, internalSizedFomat, texture.width, texture.height, 0, internalFormat, textureType, faceData);\r\n        }\r\n    }\r\n\r\n    var isPot = !this.needPOTTextures || (Tools.IsExponentOfTwo(texture.width) && Tools.IsExponentOfTwo(texture.height));\r\n    if (isPot && texture.generateMipMaps && level === 0) {\r\n        this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP);\r\n    }\r\n    this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);\r\n\r\n    // this.resetTextureCache();\r\n    texture.isReady = true;\r\n};\r\n\r\nEngine.prototype.createRawCubeTextureFromUrl = function(url: string, scene: Scene, size: number, format: number, type: number, noMipmap: boolean,\r\n    callback: (ArrayBuffer: ArrayBuffer) => Nullable<ArrayBufferView[]>,\r\n    mipmapGenerator: Nullable<((faces: ArrayBufferView[]) => ArrayBufferView[][])>,\r\n    onLoad: Nullable<() => void> = null,\r\n    onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n    samplingMode: number = 3,\r\n    invertY: boolean = false): InternalTexture {\r\n\r\n    var gl = this._gl;\r\n    var texture = this.createRawCubeTexture(null, size, format, type, !noMipmap, invertY, samplingMode, null);\r\n    scene._addPendingData(texture);\r\n    texture.url = url;\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    var onerror = (request?: IWebRequest, exception?: any) => {\r\n        scene._removePendingData(texture);\r\n        if (onError && request) {\r\n            onError(request.status + \" \" + request.statusText, exception);\r\n        }\r\n    };\r\n\r\n    var internalCallback = (data: any) => {\r\n        var width = texture.width;\r\n        var faceDataArrays = callback(data);\r\n\r\n        if (!faceDataArrays) {\r\n            return;\r\n        }\r\n\r\n        if (mipmapGenerator) {\r\n            var textureType = this._getWebGLTextureType(type);\r\n            var internalFormat = this._getInternalFormat(format);\r\n            var internalSizedFomat = this._getRGBABufferInternalSizedFormat(type);\r\n\r\n            var needConversion = false;\r\n            if (internalFormat === gl.RGB) {\r\n                internalFormat = gl.RGBA;\r\n                needConversion = true;\r\n            }\r\n\r\n            this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);\r\n            this._unpackFlipY(false);\r\n\r\n            var mipData = mipmapGenerator(faceDataArrays);\r\n            for (var level = 0; level < mipData.length; level++) {\r\n                var mipSize = width >> level;\r\n\r\n                for (var faceIndex = 0; faceIndex < 6; faceIndex++) {\r\n                    let mipFaceData = mipData[level][faceIndex];\r\n                    if (needConversion) {\r\n                        mipFaceData = this._convertRGBtoRGBATextureData(mipFaceData, mipSize, mipSize, type);\r\n                    }\r\n                    gl.texImage2D(faceIndex, level, internalSizedFomat, mipSize, mipSize, 0, internalFormat, textureType, mipFaceData);\r\n                }\r\n            }\r\n\r\n            this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\r\n        }\r\n        else {\r\n            this.updateRawCubeTexture(texture, faceDataArrays, format, type, invertY);\r\n        }\r\n\r\n        texture.isReady = true;\r\n        // this.resetTextureCache();\r\n        scene._removePendingData(texture);\r\n\r\n        if (onLoad) {\r\n            onLoad();\r\n        }\r\n    };\r\n\r\n    this._loadFile(url, (data) => {\r\n        internalCallback(data);\r\n    }, undefined, scene.offlineProvider, true, onerror);\r\n\r\n    return texture;\r\n};\r\n\r\n/**\r\n * Create a function for createRawTexture3D/createRawTexture2DArray\r\n * @param is3D true for TEXTURE_3D and false for TEXTURE_2D_ARRAY\r\n * @hidden\r\n */\r\nfunction _makeCreateRawTextureFunction(is3D: boolean) {\r\n    return function(this: Engine, data: Nullable<ArrayBufferView>, width: number, height: number, depth: number, format: number, generateMipMaps: boolean, invertY: boolean, samplingMode: number, compression: Nullable<string> = null, textureType: number = 0): InternalTexture {\r\n        var target = is3D ? this._gl.TEXTURE_3D : this._gl.TEXTURE_2D_ARRAY;\r\n        var source = is3D ? InternalTextureSource.Raw3D : InternalTextureSource.Raw2DArray;\r\n        var texture = new InternalTexture(this, source);\r\n        texture.baseWidth = width;\r\n        texture.baseHeight = height;\r\n        texture.baseDepth = depth;\r\n        texture.width = width;\r\n        texture.height = height;\r\n        texture.depth = depth;\r\n        texture.format = format;\r\n        texture.type = textureType;\r\n        texture.generateMipMaps = generateMipMaps;\r\n        texture.samplingMode = samplingMode;\r\n        if (is3D) {\r\n            texture.is3D = true;\r\n        } else {\r\n            texture.is2DArray = true;\r\n        }\r\n\r\n        if (!this._doNotHandleContextLost) {\r\n            texture._bufferView = data;\r\n        }\r\n\r\n        if (is3D) {\r\n            this.updateRawTexture3D(texture, data, format, invertY, compression, textureType);\r\n        } else {\r\n            this.updateRawTexture2DArray(texture, data, format, invertY, compression, textureType);\r\n        }\r\n        this._bindTextureDirectly(target, texture, true);\r\n\r\n        // Filters\r\n        var filters = this._getSamplingParameters(samplingMode, generateMipMaps);\r\n\r\n        this._gl.texParameteri(target, this._gl.TEXTURE_MAG_FILTER, filters.mag);\r\n        this._gl.texParameteri(target, this._gl.TEXTURE_MIN_FILTER, filters.min);\r\n\r\n        if (generateMipMaps) {\r\n            this._gl.generateMipmap(target);\r\n        }\r\n\r\n        this._bindTextureDirectly(target, null);\r\n\r\n        this._internalTexturesCache.push(texture);\r\n\r\n        return texture;\r\n    };\r\n}\r\n\r\nEngine.prototype.createRawTexture2DArray = _makeCreateRawTextureFunction(false);\r\nEngine.prototype.createRawTexture3D = _makeCreateRawTextureFunction(true);\r\n\r\n/**\r\n * Create a function for updateRawTexture3D/updateRawTexture2DArray\r\n * @param is3D true for TEXTURE_3D and false for TEXTURE_2D_ARRAY\r\n * @hidden\r\n */\r\nfunction _makeUpdateRawTextureFunction(is3D: boolean) {\r\n    return function(this: Engine, texture: InternalTexture, data: Nullable<ArrayBufferView>, format: number, invertY: boolean, compression: Nullable<string> = null, textureType: number = 0): void {\r\n        var target = is3D ? this._gl.TEXTURE_3D : this._gl.TEXTURE_2D_ARRAY;\r\n        var internalType = this._getWebGLTextureType(textureType);\r\n        var internalFormat = this._getInternalFormat(format);\r\n        var internalSizedFomat = this._getRGBABufferInternalSizedFormat(textureType, format);\r\n\r\n        this._bindTextureDirectly(target, texture, true);\r\n        this._unpackFlipY(invertY === undefined ? true : (invertY ? true : false));\r\n\r\n        if (!this._doNotHandleContextLost) {\r\n            texture._bufferView = data;\r\n            texture.format = format;\r\n            texture.invertY = invertY;\r\n            texture._compression = compression;\r\n        }\r\n\r\n        if (texture.width % 4 !== 0) {\r\n            this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, 1);\r\n        }\r\n\r\n        if (compression && data) {\r\n            this._gl.compressedTexImage3D(target, 0, (<any>this.getCaps().s3tc)[compression], texture.width, texture.height, texture.depth, 0, data);\r\n        } else {\r\n            this._gl.texImage3D(target, 0, internalSizedFomat, texture.width, texture.height, texture.depth, 0, internalFormat, internalType, data);\r\n        }\r\n\r\n        if (texture.generateMipMaps) {\r\n            this._gl.generateMipmap(target);\r\n        }\r\n        this._bindTextureDirectly(target, null);\r\n        // this.resetTextureCache();\r\n        texture.isReady = true;\r\n    };\r\n}\r\n\r\nEngine.prototype.updateRawTexture2DArray = _makeUpdateRawTextureFunction(false);\r\nEngine.prototype.updateRawTexture3D = _makeUpdateRawTextureFunction(true);\r\n"]}