var _a, _b;
import { __extends } from "tslib";
import { WebGL2ShaderProcessor } from "../WebGL/webGL2ShaderProcessors";
import { VertexBuffer } from "../../Meshes/buffer";
// These numbers must match the values for bgfx::Attrib::Enum
var attributeLocations = (_a = {},
    _a[VertexBuffer.PositionKind] = 0,
    _a[VertexBuffer.NormalKind] = 1,
    _a[VertexBuffer.TangentKind] = 2,
    _a[VertexBuffer.UVKind] = 10,
    _a[VertexBuffer.UV2Kind] = 11,
    _a[VertexBuffer.UV3Kind] = 12,
    _a[VertexBuffer.UV4Kind] = 13,
    _a[VertexBuffer.ColorKind] = 4,
    _a[VertexBuffer.MatricesIndicesKind] = 8,
    _a[VertexBuffer.MatricesWeightsKind] = 9,
    _a);
// Remap BJS names to bgfx names
var attributeBGFXName = (_b = {},
    _b[VertexBuffer.PositionKind] = "a_position",
    _b[VertexBuffer.NormalKind] = "a_normal",
    _b[VertexBuffer.TangentKind] = "a_tangent",
    _b[VertexBuffer.UVKind] = "a_texcoord0",
    _b[VertexBuffer.UV2Kind] = "a_texcoord1",
    _b[VertexBuffer.UV3Kind] = "a_texcoord2",
    _b[VertexBuffer.UV4Kind] = "a_texcoord3",
    _b[VertexBuffer.ColorKind] = "a_color0",
    _b[VertexBuffer.MatricesIndicesKind] = "a_indices",
    _b[VertexBuffer.MatricesWeightsKind] = "a_weight",
    _b);
// Must match bgfx::Attrib::TexCoord0
var firstGenericAttributeLocation = 10;
// Must match bgfx::Attrib::TexCoord7
var lastGenericAttributeLocation = 17;
/** @hidden */
var NativeShaderProcessor = /** @class */ (function (_super) {
    __extends(NativeShaderProcessor, _super);
    function NativeShaderProcessor() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NativeShaderProcessor.prototype.lineProcessor = function (line) {
        for (var _i = 0, _a = this._replacements; _i < _a.length; _i++) {
            var replacement = _a[_i];
            line = line.replace(replacement.searchValue, replacement.replaceValue);
        }
        return line;
    };
    NativeShaderProcessor.prototype.attributeProcessor = function (attribute) {
        var match = attribute.match(/attribute\s+[^\s]+\s+([^\s]+)\s*(?:\[.+\])?\s*;/);
        var name = match[1];
        var location = attributeLocations[name];
        if (location === undefined) {
            location = this._genericAttributeLocation++;
            if (location > lastGenericAttributeLocation) {
                throw new Error("Exceeded maximum custom attributes");
            }
        }
        var newName = attributeBGFXName[name];
        if (newName === undefined) {
            throw new Error("Can't find bgfx name mapping");
        }
        attribute = attribute.replace(name, newName);
        this._replacements.push({ searchValue: new RegExp("\\b" + name + "\\b", 'g'), replaceValue: "" + newName });
        return "layout(location=" + location + ") " + _super.prototype.attributeProcessor.call(this, attribute);
    };
    NativeShaderProcessor.prototype.varyingProcessor = function (varying, isFragment) {
        var location;
        if (isFragment) {
            location = this._varyingLocationMap[varying];
        }
        else {
            location = this._varyingLocationCount++;
            this._varyingLocationMap[varying] = location;
        }
        return "layout(location=" + location + ") " + _super.prototype.varyingProcessor.call(this, varying, isFragment);
    };
    NativeShaderProcessor.prototype.uniformProcessor = function (uniform) {
        var match = uniform.match(/uniform\s+([^\s]+)\s+([^\s]+)\s*(?:\[.+\])?\s*;/);
        var type = match[1];
        var name = match[2];
        switch (type) {
            case "sampler2D":
            case "samplerCube": {
                var suffix = type.substr(7);
                var binding = this._textureCount++;
                this._replacements.push({ searchValue: new RegExp("\\b" + name + "\\b"), replaceValue: "sampler" + suffix + "(" + name + "Texture, " + name + ")" });
                return "layout(binding=" + binding + ") uniform texture" + suffix + " " + name + "Texture;\nlayout(binding=" + binding + ") uniform sampler " + name + ";";
            }
            case "float": {
                this._replacements.push({ searchValue: new RegExp("\\b" + name + "\\b"), replaceValue: name + ".x" });
                uniform = "uniform vec4 " + name + ";";
                break;
            }
            case "vec2": {
                this._replacements.push({ searchValue: new RegExp("\\b" + name + "\\b"), replaceValue: name + ".xy" });
                uniform = "uniform vec4 " + name + ";";
                break;
            }
            case "vec3": {
                this._replacements.push({ searchValue: new RegExp("\\b" + name + "\\b"), replaceValue: name + ".xyz" });
                uniform = "uniform vec4 " + name + ";";
                break;
            }
        }
        this._uniforms.push(uniform);
        return this._uniforms.length === 1 ? "<UNIFORM>" : "";
    };
    NativeShaderProcessor.prototype.preProcessor = function (code, defines, isFragment) {
        this._genericAttributeLocation = firstGenericAttributeLocation;
        if (!isFragment) {
            this._varyingLocationCount = 0;
            this._varyingLocationMap = {};
        }
        this._replacements = [];
        this._textureCount = 0;
        this._uniforms = [];
        return code;
    };
    NativeShaderProcessor.prototype.postProcessor = function (code, defines, isFragment) {
        code = _super.prototype.postProcessor.call(this, code, defines, isFragment);
        code = code.replace("<UNIFORM>", "layout(binding=0) uniform Frame {\n" + this._uniforms.join("\n") + "\n};");
        code = code.replace("out vec4 glFragColor", "layout(location=0) out vec4 glFragColor");
        return code;
    };
    return NativeShaderProcessor;
}(WebGL2ShaderProcessor));
export { NativeShaderProcessor };
//# sourceMappingURL=nativeShaderProcessor.js.map