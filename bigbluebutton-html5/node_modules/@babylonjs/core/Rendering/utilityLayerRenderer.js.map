{"version":3,"file":"utilityLayerRenderer.js","sourceRoot":"","sources":["../../../sourceES6/core/Rendering/utilityLayerRenderer.ts"],"names":[],"mappings":"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","sourcesContent":["import { IDisposable, Scene } from \"../scene\";\r\nimport { Nullable } from \"../types\";\r\nimport { Observable, Observer } from \"../Misc/observable\";\r\nimport { PointerInfoPre, PointerInfo, PointerEventTypes } from \"../Events/pointerEvents\";\r\nimport { PickingInfo } from \"../Collisions/pickingInfo\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { HemisphericLight } from '../Lights/hemisphericLight';\r\nimport { Vector3 } from '../Maths/math.vector';\r\nimport { Camera } from '../Cameras/camera';\r\nimport { Color3 } from '../Maths/math.color';\r\n\r\n/**\r\n * Renders a layer on top of an existing scene\r\n */\r\nexport class UtilityLayerRenderer implements IDisposable {\r\n    private _pointerCaptures: { [pointerId: number]: boolean } = {};\r\n    private _lastPointerEvents: { [pointerId: number]: boolean } = {};\r\n    private static _DefaultUtilityLayer: Nullable<UtilityLayerRenderer> = null;\r\n    private static _DefaultKeepDepthUtilityLayer: Nullable<UtilityLayerRenderer> = null;\r\n    private _sharedGizmoLight: Nullable<HemisphericLight> = null;\r\n\r\n    private _renderCamera: Nullable<Camera> = null;\r\n\r\n    /**\r\n     * Gets the camera that is used to render the utility layer (when not set, this will be the last active camera)\r\n     * @param getRigParentIfPossible if the current active camera is a rig camera, should its parent camera be returned\r\n     * @returns the camera that is used when rendering the utility layer\r\n     */\r\n    public getRenderCamera(getRigParentIfPossible?: boolean) {\r\n        if (this._renderCamera) {\r\n            return this._renderCamera;\r\n        } else {\r\n            let activeCam: Camera;\r\n            if (this.originalScene.activeCameras.length > 1) {\r\n                activeCam = this.originalScene.activeCameras[this.originalScene.activeCameras.length - 1];\r\n            } else {\r\n                activeCam = <Camera>(this.originalScene.activeCamera!);\r\n            }\r\n\r\n            if (getRigParentIfPossible && activeCam && activeCam.isRigCamera) {\r\n                return activeCam.rigParent!;\r\n            }\r\n            return activeCam;\r\n        }\r\n    }\r\n    /**\r\n     * Sets the camera that should be used when rendering the utility layer (If set to null the last active camera will be used)\r\n     * @param cam the camera that should be used when rendering the utility layer\r\n     */\r\n    public setRenderCamera(cam: Nullable<Camera>) {\r\n        this._renderCamera = cam;\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     * Light which used by gizmos to get light shading\r\n     */\r\n    public _getSharedGizmoLight(): HemisphericLight {\r\n        if (!this._sharedGizmoLight) {\r\n            this._sharedGizmoLight = new HemisphericLight(\"shared gizmo light\", new Vector3(0, 1, 0), this.utilityLayerScene);\r\n            this._sharedGizmoLight.intensity = 2;\r\n            this._sharedGizmoLight.groundColor = Color3.Gray();\r\n        }\r\n        return this._sharedGizmoLight;\r\n    }\r\n\r\n    /**\r\n     * If the picking should be done on the utility layer prior to the actual scene (Default: true)\r\n     */\r\n    public pickUtilitySceneFirst = true;\r\n    /**\r\n     * A shared utility layer that can be used to overlay objects into a scene (Depth map of the previous scene is cleared before drawing on top of it)\r\n     */\r\n    public static get DefaultUtilityLayer(): UtilityLayerRenderer {\r\n        if (UtilityLayerRenderer._DefaultUtilityLayer == null) {\r\n            UtilityLayerRenderer._DefaultUtilityLayer = new UtilityLayerRenderer(EngineStore.LastCreatedScene!);\r\n            UtilityLayerRenderer._DefaultUtilityLayer.originalScene.onDisposeObservable.addOnce(() => {\r\n                UtilityLayerRenderer._DefaultUtilityLayer = null;\r\n            });\r\n        }\r\n        return UtilityLayerRenderer._DefaultUtilityLayer;\r\n    }\r\n    /**\r\n     * A shared utility layer that can be used to embed objects into a scene (Depth map of the previous scene is not cleared before drawing on top of it)\r\n     */\r\n    public static get DefaultKeepDepthUtilityLayer(): UtilityLayerRenderer {\r\n        if (UtilityLayerRenderer._DefaultKeepDepthUtilityLayer == null) {\r\n            UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = new UtilityLayerRenderer(EngineStore.LastCreatedScene!);\r\n            UtilityLayerRenderer._DefaultKeepDepthUtilityLayer.utilityLayerScene.autoClearDepthAndStencil = false;\r\n            UtilityLayerRenderer._DefaultKeepDepthUtilityLayer.originalScene.onDisposeObservable.addOnce(() => {\r\n                UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = null;\r\n            });\r\n        }\r\n        return UtilityLayerRenderer._DefaultKeepDepthUtilityLayer;\r\n    }\r\n\r\n    /**\r\n     * The scene that is rendered on top of the original scene\r\n     */\r\n    public utilityLayerScene: Scene;\r\n\r\n    /**\r\n     *  If the utility layer should automatically be rendered on top of existing scene\r\n    */\r\n    public shouldRender: boolean = true;\r\n    /**\r\n     * If set to true, only pointer down onPointerObservable events will be blocked when picking is occluded by original scene\r\n     */\r\n    public onlyCheckPointerDownEvents = true;\r\n\r\n    /**\r\n     * If set to false, only pointerUp, pointerDown and pointerMove will be sent to the utilityLayerScene (false by default)\r\n     */\r\n    public processAllEvents = false;\r\n\r\n    /**\r\n     * Observable raised when the pointer move from the utility layer scene to the main scene\r\n     */\r\n    public onPointerOutObservable = new Observable<number>();\r\n\r\n    /** Gets or sets a predicate that will be used to indicate utility meshes present in the main scene */\r\n    public mainSceneTrackerPredicate: (mesh: Nullable<AbstractMesh>) => boolean;\r\n\r\n    private _afterRenderObserver: Nullable<Observer<Camera>>;\r\n    private _sceneDisposeObserver: Nullable<Observer<Scene>>;\r\n    private _originalPointerObserver: Nullable<Observer<PointerInfoPre>>;\r\n    /**\r\n     * Instantiates a UtilityLayerRenderer\r\n     * @param originalScene the original scene that will be rendered on top of\r\n     * @param handleEvents boolean indicating if the utility layer should handle events\r\n     */\r\n    constructor(\r\n        /** the original scene that will be rendered on top of */\r\n        public originalScene: Scene,\r\n        handleEvents: boolean = true) {\r\n        // Create scene which will be rendered in the foreground and remove it from being referenced by engine to avoid interfering with existing app\r\n        this.utilityLayerScene = new Scene(originalScene.getEngine(), { virtual: true });\r\n        this.utilityLayerScene.useRightHandedSystem = originalScene.useRightHandedSystem;\r\n        this.utilityLayerScene._allowPostProcessClearColor = false;\r\n\r\n        // Detach controls on utility scene, events will be fired by logic below to handle picking priority\r\n        this.utilityLayerScene.detachControl();\r\n\r\n        if (handleEvents) {\r\n            this._originalPointerObserver = originalScene.onPrePointerObservable.add((prePointerInfo, eventState) => {\r\n                if (!this.utilityLayerScene.activeCamera) {\r\n                    return;\r\n                }\r\n                if (!this.processAllEvents) {\r\n                    if (prePointerInfo.type !== PointerEventTypes.POINTERMOVE\r\n                        && prePointerInfo.type !== PointerEventTypes.POINTERUP\r\n                        && prePointerInfo.type !== PointerEventTypes.POINTERDOWN) {\r\n                        return;\r\n                    }\r\n                }\r\n                this.utilityLayerScene.pointerX = originalScene.pointerX;\r\n                this.utilityLayerScene.pointerY = originalScene.pointerY;\r\n                let pointerEvent = <PointerEvent>(prePointerInfo.event);\r\n                if (originalScene!.isPointerCaptured(pointerEvent.pointerId)) {\r\n                    this._pointerCaptures[pointerEvent.pointerId] = false;\r\n                    return;\r\n                }\r\n\r\n                var utilityScenePick = prePointerInfo.ray ? this.utilityLayerScene.pickWithRay(prePointerInfo.ray) : this.utilityLayerScene.pick(originalScene.pointerX, originalScene.pointerY);\r\n                if (!prePointerInfo.ray && utilityScenePick) {\r\n                    prePointerInfo.ray = utilityScenePick.ray;\r\n                }\r\n\r\n                // always fire the prepointer oversvable\r\n                this.utilityLayerScene.onPrePointerObservable.notifyObservers(prePointerInfo);\r\n\r\n                // allow every non pointer down event to flow to the utility layer\r\n                if (this.onlyCheckPointerDownEvents && prePointerInfo.type != PointerEventTypes.POINTERDOWN) {\r\n                    if (!prePointerInfo.skipOnPointerObservable) {\r\n                        this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, utilityScenePick));\r\n                    }\r\n                    if (prePointerInfo.type === PointerEventTypes.POINTERUP && this._pointerCaptures[pointerEvent.pointerId]) {\r\n                        this._pointerCaptures[pointerEvent.pointerId] = false;\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                if (this.utilityLayerScene.autoClearDepthAndStencil || this.pickUtilitySceneFirst) {\r\n                    // If this layer is an overlay, check if this layer was hit and if so, skip pointer events for the main scene\r\n                    if (utilityScenePick && utilityScenePick.hit) {\r\n\r\n                        if (!prePointerInfo.skipOnPointerObservable) {\r\n                            this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, utilityScenePick));\r\n                        }\r\n                        prePointerInfo.skipOnPointerObservable = true;\r\n                    }\r\n                } else {\r\n                    var originalScenePick = prePointerInfo.ray ? originalScene.pickWithRay(prePointerInfo.ray) : originalScene.pick(originalScene.pointerX, originalScene.pointerY);\r\n                    let pointerEvent = <PointerEvent>(prePointerInfo.event);\r\n\r\n                    // If the layer can be occluded by the original scene, only fire pointer events to the first layer that hit they ray\r\n                    if (originalScenePick && utilityScenePick) {\r\n\r\n                        // No pick in utility scene\r\n                        if (utilityScenePick.distance === 0 && originalScenePick.pickedMesh) {\r\n                            if (this.mainSceneTrackerPredicate && this.mainSceneTrackerPredicate(originalScenePick.pickedMesh)) {\r\n                                // We touched an utility mesh present in the main scene\r\n                                this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent);\r\n                                prePointerInfo.skipOnPointerObservable = true;\r\n                            } else if (prePointerInfo.type === PointerEventTypes.POINTERDOWN) {\r\n                                this._pointerCaptures[pointerEvent.pointerId] = true;\r\n                            } else if (this._lastPointerEvents[pointerEvent.pointerId]) {\r\n                                // We need to send a last pointerup to the utilityLayerScene to make sure animations can complete\r\n                                this.onPointerOutObservable.notifyObservers(pointerEvent.pointerId);\r\n                                delete this._lastPointerEvents[pointerEvent.pointerId];\r\n                            }\r\n                        } else if (!this._pointerCaptures[pointerEvent.pointerId] && (utilityScenePick.distance < originalScenePick.distance || originalScenePick.distance === 0)) {\r\n                            // We pick something in utility scene or the pick in utility is closer than the one in main scene\r\n                            this._notifyObservers(prePointerInfo, utilityScenePick, pointerEvent);\r\n                            // If a previous utility layer set this, do not unset this\r\n                            if (!prePointerInfo.skipOnPointerObservable) {\r\n                                prePointerInfo.skipOnPointerObservable = utilityScenePick.distance > 0;\r\n                            }\r\n                        } else if (!this._pointerCaptures[pointerEvent.pointerId] && (utilityScenePick.distance > originalScenePick.distance)) {\r\n                            // We have a pick in both scenes but main is closer than utility\r\n\r\n                            // We touched an utility mesh present in the main scene\r\n                            if (this.mainSceneTrackerPredicate && this.mainSceneTrackerPredicate(originalScenePick.pickedMesh)) {\r\n                                this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent);\r\n                                prePointerInfo.skipOnPointerObservable = true;\r\n                            } else if (this._lastPointerEvents[pointerEvent.pointerId]) {\r\n                                // We need to send a last pointerup to the utilityLayerScene to make sure animations can complete\r\n                                this.onPointerOutObservable.notifyObservers(pointerEvent.pointerId);\r\n                                delete this._lastPointerEvents[pointerEvent.pointerId];\r\n                            }\r\n                        }\r\n\r\n                        if (prePointerInfo.type === PointerEventTypes.POINTERUP && this._pointerCaptures[pointerEvent.pointerId]) {\r\n                            this._pointerCaptures[pointerEvent.pointerId] = false;\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n\r\n            // As a newly added utility layer will be rendered over the screen last, it's pointer events should be processed first\r\n            if (this._originalPointerObserver) {\r\n                originalScene.onPrePointerObservable.makeObserverTopPriority(this._originalPointerObserver);\r\n            }\r\n        }\r\n\r\n        // Render directly on top of existing scene without clearing\r\n        this.utilityLayerScene.autoClear = false;\r\n\r\n        this._afterRenderObserver = this.originalScene.onAfterCameraRenderObservable.add((camera) => {\r\n            // Only render when the render camera finishes rendering\r\n            if (this.shouldRender && camera == this.getRenderCamera()) {\r\n                this.render();\r\n            }\r\n        });\r\n\r\n        this._sceneDisposeObserver = this.originalScene.onDisposeObservable.add(() => {\r\n            this.dispose();\r\n        });\r\n\r\n        this._updateCamera();\r\n    }\r\n\r\n    private _notifyObservers(prePointerInfo: PointerInfoPre, pickInfo: PickingInfo, pointerEvent: PointerEvent) {\r\n        if (!prePointerInfo.skipOnPointerObservable) {\r\n            this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, pickInfo));\r\n            this._lastPointerEvents[pointerEvent.pointerId] = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Renders the utility layers scene on top of the original scene\r\n     */\r\n    public render() {\r\n        this._updateCamera();\r\n        if (this.utilityLayerScene.activeCamera) {\r\n            // Set the camera's scene to utility layers scene\r\n            var oldScene = this.utilityLayerScene.activeCamera.getScene();\r\n            var camera = this.utilityLayerScene.activeCamera;\r\n            camera._scene = this.utilityLayerScene;\r\n            if (camera.leftCamera) {\r\n                camera.leftCamera._scene = this.utilityLayerScene;\r\n            }\r\n            if (camera.rightCamera) {\r\n                camera.rightCamera._scene = this.utilityLayerScene;\r\n            }\r\n\r\n            this.utilityLayerScene.render(false);\r\n\r\n            // Reset camera's scene back to original\r\n            camera._scene = oldScene;\r\n            if (camera.leftCamera) {\r\n                camera.leftCamera._scene = oldScene;\r\n            }\r\n            if (camera.rightCamera) {\r\n                camera.rightCamera._scene = oldScene;\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Disposes of the renderer\r\n     */\r\n    public dispose() {\r\n        this.onPointerOutObservable.clear();\r\n\r\n        if (this._afterRenderObserver) {\r\n            this.originalScene.onAfterCameraRenderObservable.remove(this._afterRenderObserver);\r\n        }\r\n        if (this._sceneDisposeObserver) {\r\n            this.originalScene.onDisposeObservable.remove(this._sceneDisposeObserver);\r\n        }\r\n        if (this._originalPointerObserver) {\r\n            this.originalScene.onPrePointerObservable.remove(this._originalPointerObserver);\r\n        }\r\n        this.utilityLayerScene.dispose();\r\n    }\r\n\r\n    private _updateCamera() {\r\n        this.utilityLayerScene.cameraToUseForPointers = this.getRenderCamera();\r\n        this.utilityLayerScene.activeCamera = this.getRenderCamera();\r\n    }\r\n}\r\n"]}