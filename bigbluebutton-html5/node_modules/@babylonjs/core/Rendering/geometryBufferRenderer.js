import { Matrix } from "../Maths/math.vector";
import { VertexBuffer } from "../Meshes/buffer";
import { Texture } from "../Materials/Textures/texture";
import { MultiRenderTarget } from "../Materials/Textures/multiRenderTarget";
import { MaterialHelper } from "../Materials/materialHelper";
import { Color4 } from '../Maths/math.color';
import { StandardMaterial } from '../Materials/standardMaterial';
import { PBRMaterial } from '../Materials/PBR/pbrMaterial';
import "../Shaders/geometry.fragment";
import "../Shaders/geometry.vertex";
import { _DevTools } from '../Misc/devTools';
/**
 * This renderer is helpfull to fill one of the render target with a geometry buffer.
 */
var GeometryBufferRenderer = /** @class */ (function () {
    /**
     * Creates a new G Buffer for the scene
     * @param scene The scene the buffer belongs to
     * @param ratio How big is the buffer related to the main canvas.
     */
    function GeometryBufferRenderer(scene, ratio) {
        if (ratio === void 0) { ratio = 1; }
        /**
         * Dictionary used to store the previous transformation matrices of each rendered mesh
         * in order to compute objects velocities when enableVelocity is set to "true"
         * @hidden
         */
        this._previousTransformationMatrices = {};
        /**
         * Dictionary used to store the previous bones transformation matrices of each rendered mesh
         * in order to compute objects velocities when enableVelocity is set to "true"
         * @hidden
         */
        this._previousBonesTransformationMatrices = {};
        /**
         * Array used to store the ignored skinned meshes while computing velocity map (typically used by the motion blur post-process).
         * Avoids computing bones velocities and computes only mesh's velocity itself (position, rotation, scaling).
         */
        this.excludedSkinnedMeshesFromVelocity = [];
        /** Gets or sets a boolean indicating if transparent meshes should be rendered */
        this.renderTransparentMeshes = true;
        this._enablePosition = false;
        this._enableVelocity = false;
        this._enableReflectivity = false;
        this._positionIndex = -1;
        this._velocityIndex = -1;
        this._reflectivityIndex = -1;
        this._scene = scene;
        this._ratio = ratio;
        GeometryBufferRenderer._SceneComponentInitialization(this._scene);
        // Render target
        this._createRenderTargets();
    }
    Object.defineProperty(GeometryBufferRenderer.prototype, "renderList", {
        /**
         * Set the render list (meshes to be rendered) used in the G buffer.
         */
        set: function (meshes) {
            this._multiRenderTarget.renderList = meshes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GeometryBufferRenderer.prototype, "isSupported", {
        /**
         * Gets wether or not G buffer are supported by the running hardware.
         * This requires draw buffer supports
         */
        get: function () {
            return this._multiRenderTarget.isSupported;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns the index of the given texture type in the G-Buffer textures array
     * @param textureType The texture type constant. For example GeometryBufferRenderer.POSITION_TEXTURE_INDEX
     * @returns the index of the given texture type in the G-Buffer textures array
     */
    GeometryBufferRenderer.prototype.getTextureIndex = function (textureType) {
        switch (textureType) {
            case GeometryBufferRenderer.POSITION_TEXTURE_TYPE: return this._positionIndex;
            case GeometryBufferRenderer.VELOCITY_TEXTURE_TYPE: return this._velocityIndex;
            case GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE: return this._reflectivityIndex;
            default: return -1;
        }
    };
    Object.defineProperty(GeometryBufferRenderer.prototype, "enablePosition", {
        /**
         * Gets a boolean indicating if objects positions are enabled for the G buffer.
         */
        get: function () {
            return this._enablePosition;
        },
        /**
         * Sets whether or not objects positions are enabled for the G buffer.
         */
        set: function (enable) {
            this._enablePosition = enable;
            this.dispose();
            this._createRenderTargets();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GeometryBufferRenderer.prototype, "enableVelocity", {
        /**
         * Gets a boolean indicating if objects velocities are enabled for the G buffer.
         */
        get: function () {
            return this._enableVelocity;
        },
        /**
         * Sets wether or not objects velocities are enabled for the G buffer.
         */
        set: function (enable) {
            this._enableVelocity = enable;
            if (!enable) {
                this._previousTransformationMatrices = {};
            }
            this.dispose();
            this._createRenderTargets();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GeometryBufferRenderer.prototype, "enableReflectivity", {
        /**
         * Gets a boolean indicating if objects roughness are enabled in the G buffer.
         */
        get: function () {
            return this._enableReflectivity;
        },
        /**
         * Sets wether or not objects roughness are enabled for the G buffer.
         */
        set: function (enable) {
            this._enableReflectivity = enable;
            this.dispose();
            this._createRenderTargets();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GeometryBufferRenderer.prototype, "scene", {
        /**
         * Gets the scene associated with the buffer.
         */
        get: function () {
            return this._scene;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GeometryBufferRenderer.prototype, "ratio", {
        /**
         * Gets the ratio used by the buffer during its creation.
         * How big is the buffer related to the main canvas.
         */
        get: function () {
            return this._ratio;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Checks wether everything is ready to render a submesh to the G buffer.
     * @param subMesh the submesh to check readiness for
     * @param useInstances is the mesh drawn using instance or not
     * @returns true if ready otherwise false
     */
    GeometryBufferRenderer.prototype.isReady = function (subMesh, useInstances) {
        var material = subMesh.getMaterial();
        if (material && material.disableDepthWrite) {
            return false;
        }
        var defines = [];
        var attribs = [VertexBuffer.PositionKind, VertexBuffer.NormalKind];
        var mesh = subMesh.getMesh();
        // Alpha test
        if (material) {
            var needUv = false;
            if (material.needAlphaBlending()) {
                defines.push("#define ALPHATEST");
                needUv = true;
            }
            if (material.bumpTexture && StandardMaterial.BumpTextureEnabled) {
                defines.push("#define BUMP");
                needUv = true;
            }
            if (this._enableReflectivity) {
                if (material instanceof StandardMaterial && material.specularTexture) {
                    defines.push("#define HAS_SPECULAR");
                    needUv = true;
                }
                else if (material instanceof PBRMaterial && material.reflectivityTexture) {
                    defines.push("#define HAS_REFLECTIVITY");
                    needUv = true;
                }
            }
            if (needUv) {
                defines.push("#define NEED_UV");
                if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {
                    attribs.push(VertexBuffer.UVKind);
                    defines.push("#define UV1");
                }
                if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {
                    attribs.push(VertexBuffer.UV2Kind);
                    defines.push("#define UV2");
                }
            }
        }
        // Buffers
        if (this._enablePosition) {
            defines.push("#define POSITION");
            defines.push("#define POSITION_INDEX " + this._positionIndex);
        }
        if (this._enableVelocity) {
            defines.push("#define VELOCITY");
            defines.push("#define VELOCITY_INDEX " + this._velocityIndex);
            if (this.excludedSkinnedMeshesFromVelocity.indexOf(mesh) === -1) {
                defines.push("#define BONES_VELOCITY_ENABLED");
            }
        }
        if (this._enableReflectivity) {
            defines.push("#define REFLECTIVITY");
            defines.push("#define REFLECTIVITY_INDEX " + this._reflectivityIndex);
        }
        // Bones
        if (mesh.useBones && mesh.computeBonesUsingShaders) {
            attribs.push(VertexBuffer.MatricesIndicesKind);
            attribs.push(VertexBuffer.MatricesWeightsKind);
            if (mesh.numBoneInfluencers > 4) {
                attribs.push(VertexBuffer.MatricesIndicesExtraKind);
                attribs.push(VertexBuffer.MatricesWeightsExtraKind);
            }
            defines.push("#define NUM_BONE_INFLUENCERS " + mesh.numBoneInfluencers);
            defines.push("#define BonesPerMesh " + (mesh.skeleton ? mesh.skeleton.bones.length + 1 : 0));
        }
        else {
            defines.push("#define NUM_BONE_INFLUENCERS 0");
        }
        // Morph targets
        var morphTargetManager = mesh.morphTargetManager;
        var numMorphInfluencers = 0;
        if (morphTargetManager) {
            if (morphTargetManager.numInfluencers > 0) {
                numMorphInfluencers = morphTargetManager.numInfluencers;
                defines.push("#define MORPHTARGETS");
                defines.push("#define NUM_MORPH_INFLUENCERS " + numMorphInfluencers);
                MaterialHelper.PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, numMorphInfluencers);
            }
        }
        // Instances
        if (useInstances) {
            defines.push("#define INSTANCES");
            MaterialHelper.PushAttributesForInstances(attribs);
        }
        // Setup textures count
        defines.push("#define RENDER_TARGET_COUNT " + this._multiRenderTarget.textures.length);
        // Get correct effect
        var join = defines.join("\n");
        if (this._cachedDefines !== join) {
            this._cachedDefines = join;
            this._effect = this._scene.getEngine().createEffect("geometry", attribs, [
                "world", "mBones", "viewProjection", "diffuseMatrix", "view", "previousWorld", "previousViewProjection", "mPreviousBones",
                "morphTargetInfluences", "bumpMatrix", "reflectivityMatrix", "vTangentSpaceParams", "vBumpInfos"
            ], ["diffuseSampler", "bumpSampler", "reflectivitySampler"], join, undefined, undefined, undefined, { buffersCount: this._multiRenderTarget.textures.length - 1, maxSimultaneousMorphTargets: numMorphInfluencers });
        }
        return this._effect.isReady();
    };
    /**
     * Gets the current underlying G Buffer.
     * @returns the buffer
     */
    GeometryBufferRenderer.prototype.getGBuffer = function () {
        return this._multiRenderTarget;
    };
    Object.defineProperty(GeometryBufferRenderer.prototype, "samples", {
        /**
         * Gets the number of samples used to render the buffer (anti aliasing).
         */
        get: function () {
            return this._multiRenderTarget.samples;
        },
        /**
         * Sets the number of samples used to render the buffer (anti aliasing).
         */
        set: function (value) {
            this._multiRenderTarget.samples = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Disposes the renderer and frees up associated resources.
     */
    GeometryBufferRenderer.prototype.dispose = function () {
        this.getGBuffer().dispose();
    };
    GeometryBufferRenderer.prototype._createRenderTargets = function () {
        var _this = this;
        var engine = this._scene.getEngine();
        var count = 2;
        if (this._enablePosition) {
            this._positionIndex = count;
            count++;
        }
        if (this._enableVelocity) {
            this._velocityIndex = count;
            count++;
        }
        if (this._enableReflectivity) {
            this._reflectivityIndex = count;
            count++;
        }
        this._multiRenderTarget = new MultiRenderTarget("gBuffer", { width: engine.getRenderWidth() * this._ratio, height: engine.getRenderHeight() * this._ratio }, count, this._scene, { generateMipMaps: false, generateDepthTexture: true, defaultType: 1 });
        if (!this.isSupported) {
            return;
        }
        this._multiRenderTarget.wrapU = Texture.CLAMP_ADDRESSMODE;
        this._multiRenderTarget.wrapV = Texture.CLAMP_ADDRESSMODE;
        this._multiRenderTarget.refreshRate = 1;
        this._multiRenderTarget.renderParticles = false;
        this._multiRenderTarget.renderList = null;
        // set default depth value to 1.0 (far away)
        this._multiRenderTarget.onClearObservable.add(function (engine) {
            engine.clear(new Color4(0.0, 0.0, 0.0, 1.0), true, true, true);
        });
        // Custom render function
        var renderSubMesh = function (subMesh) {
            var mesh = subMesh.getRenderingMesh();
            var scene = _this._scene;
            var engine = scene.getEngine();
            var material = subMesh.getMaterial();
            if (!material) {
                return;
            }
            mesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;
            // Velocity
            if (_this._enableVelocity && !_this._previousTransformationMatrices[mesh.uniqueId]) {
                _this._previousTransformationMatrices[mesh.uniqueId] = {
                    world: Matrix.Identity(),
                    viewProjection: scene.getTransformMatrix()
                };
                if (mesh.skeleton) {
                    var bonesTransformations = mesh.skeleton.getTransformMatrices(mesh);
                    _this._previousBonesTransformationMatrices[mesh.uniqueId] = _this._copyBonesTransformationMatrices(bonesTransformations, new Float32Array(bonesTransformations.length));
                }
            }
            // Culling
            engine.setState(material.backFaceCulling, 0, false, scene.useRightHandedSystem);
            // Managing instances
            var batch = mesh._getInstancesRenderList(subMesh._id);
            if (batch.mustReturn) {
                return;
            }
            var hardwareInstancedRendering = (engine.getCaps().instancedArrays) && (batch.visibleInstances[subMesh._id] !== null);
            if (_this.isReady(subMesh, hardwareInstancedRendering)) {
                engine.enableEffect(_this._effect);
                mesh._bind(subMesh, _this._effect, material.fillMode);
                _this._effect.setMatrix("viewProjection", scene.getTransformMatrix());
                _this._effect.setMatrix("view", scene.getViewMatrix());
                if (material) {
                    // Alpha test
                    if (material.needAlphaTesting()) {
                        var alphaTexture = material.getAlphaTestTexture();
                        if (alphaTexture) {
                            _this._effect.setTexture("diffuseSampler", alphaTexture);
                            _this._effect.setMatrix("diffuseMatrix", alphaTexture.getTextureMatrix());
                        }
                    }
                    // Bump
                    if (material.bumpTexture && scene.getEngine().getCaps().standardDerivatives && StandardMaterial.BumpTextureEnabled) {
                        _this._effect.setFloat3("vBumpInfos", material.bumpTexture.coordinatesIndex, 1.0 / material.bumpTexture.level, material.parallaxScaleBias);
                        _this._effect.setMatrix("bumpMatrix", material.bumpTexture.getTextureMatrix());
                        _this._effect.setTexture("bumpSampler", material.bumpTexture);
                        _this._effect.setFloat2("vTangentSpaceParams", material.invertNormalMapX ? -1.0 : 1.0, material.invertNormalMapY ? -1.0 : 1.0);
                    }
                    // Roughness
                    if (_this._enableReflectivity) {
                        if (material instanceof StandardMaterial && material.specularTexture) {
                            _this._effect.setMatrix("reflectivityMatrix", material.specularTexture.getTextureMatrix());
                            _this._effect.setTexture("reflectivitySampler", material.specularTexture);
                        }
                        else if (material instanceof PBRMaterial && material.reflectivityTexture) {
                            _this._effect.setMatrix("reflectivityMatrix", material.reflectivityTexture.getTextureMatrix());
                            _this._effect.setTexture("reflectivitySampler", material.reflectivityTexture);
                        }
                    }
                }
                // Bones
                if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {
                    _this._effect.setMatrices("mBones", mesh.skeleton.getTransformMatrices(mesh));
                    if (_this._enableVelocity) {
                        _this._effect.setMatrices("mPreviousBones", _this._previousBonesTransformationMatrices[mesh.uniqueId]);
                    }
                }
                // Morph targets
                MaterialHelper.BindMorphTargetParameters(mesh, _this._effect);
                // Velocity
                if (_this._enableVelocity) {
                    _this._effect.setMatrix("previousWorld", _this._previousTransformationMatrices[mesh.uniqueId].world);
                    _this._effect.setMatrix("previousViewProjection", _this._previousTransformationMatrices[mesh.uniqueId].viewProjection);
                }
                // Draw
                mesh._processRendering(subMesh, _this._effect, material.fillMode, batch, hardwareInstancedRendering, function (isInstance, world) { return _this._effect.setMatrix("world", world); });
            }
            // Velocity
            if (_this._enableVelocity) {
                _this._previousTransformationMatrices[mesh.uniqueId].world = mesh.getWorldMatrix().clone();
                _this._previousTransformationMatrices[mesh.uniqueId].viewProjection = _this._scene.getTransformMatrix().clone();
                if (mesh.skeleton) {
                    _this._copyBonesTransformationMatrices(mesh.skeleton.getTransformMatrices(mesh), _this._previousBonesTransformationMatrices[mesh.uniqueId]);
                }
            }
        };
        this._multiRenderTarget.customRenderFunction = function (opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) {
            var index;
            if (depthOnlySubMeshes.length) {
                engine.setColorWrite(false);
                for (index = 0; index < depthOnlySubMeshes.length; index++) {
                    renderSubMesh(depthOnlySubMeshes.data[index]);
                }
                engine.setColorWrite(true);
            }
            for (index = 0; index < opaqueSubMeshes.length; index++) {
                renderSubMesh(opaqueSubMeshes.data[index]);
            }
            for (index = 0; index < alphaTestSubMeshes.length; index++) {
                renderSubMesh(alphaTestSubMeshes.data[index]);
            }
            if (_this.renderTransparentMeshes) {
                for (index = 0; index < transparentSubMeshes.length; index++) {
                    renderSubMesh(transparentSubMeshes.data[index]);
                }
            }
        };
    };
    // Copies the bones transformation matrices into the target array and returns the target's reference
    GeometryBufferRenderer.prototype._copyBonesTransformationMatrices = function (source, target) {
        for (var i = 0; i < source.length; i++) {
            target[i] = source[i];
        }
        return target;
    };
    /**
     * Constant used to retrieve the position texture index in the G-Buffer textures array
     * using getIndex(GeometryBufferRenderer.POSITION_TEXTURE_INDEX)
     */
    GeometryBufferRenderer.POSITION_TEXTURE_TYPE = 1;
    /**
     * Constant used to retrieve the velocity texture index in the G-Buffer textures array
     * using getIndex(GeometryBufferRenderer.VELOCITY_TEXTURE_INDEX)
     */
    GeometryBufferRenderer.VELOCITY_TEXTURE_TYPE = 2;
    /**
     * Constant used to retrieve the reflectivity texture index in the G-Buffer textures array
     * using the getIndex(GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE)
     */
    GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE = 3;
    /** @hidden */
    GeometryBufferRenderer._SceneComponentInitialization = function (_) {
        throw _DevTools.WarnImport("GeometryBufferRendererSceneComponent");
    };
    return GeometryBufferRenderer;
}());
export { GeometryBufferRenderer };
//# sourceMappingURL=geometryBufferRenderer.js.map