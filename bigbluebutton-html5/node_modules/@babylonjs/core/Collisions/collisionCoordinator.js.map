{"version":3,"file":"collisionCoordinator.js","sourceRoot":"","sources":["../../../sourceES6/core/Collisions/collisionCoordinator.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { Collider } from \"./collider\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\n\r\n/** @hidden */\r\nexport interface ICollisionCoordinator {\r\n    createCollider(): Collider;\r\n    getNewPosition(position: Vector3, displacement: Vector3, collider: Collider, maximumRetry: number, excludedMesh: Nullable<AbstractMesh>, onNewPosition: (collisionIndex: number, newPosition: Vector3, collidedMesh: Nullable<AbstractMesh>) => void, collisionIndex: number): void;\r\n    init(scene: Scene): void;\r\n}\r\n\r\n/** @hidden */\r\nexport class DefaultCollisionCoordinator implements ICollisionCoordinator {\r\n\r\n    private _scene: Scene;\r\n\r\n    private _scaledPosition = Vector3.Zero();\r\n    private _scaledVelocity = Vector3.Zero();\r\n\r\n    private _finalPosition = Vector3.Zero();\r\n\r\n    public getNewPosition(position: Vector3, displacement: Vector3, collider: Collider, maximumRetry: number, excludedMesh: AbstractMesh, onNewPosition: (collisionIndex: number, newPosition: Vector3, collidedMesh: Nullable<AbstractMesh>) => void, collisionIndex: number): void {\r\n        position.divideToRef(collider._radius, this._scaledPosition);\r\n        displacement.divideToRef(collider._radius, this._scaledVelocity);\r\n        collider.collidedMesh = null;\r\n        collider._retry = 0;\r\n        collider._initialVelocity = this._scaledVelocity;\r\n        collider._initialPosition = this._scaledPosition;\r\n        this._collideWithWorld(this._scaledPosition, this._scaledVelocity, collider, maximumRetry, this._finalPosition, excludedMesh);\r\n\r\n        this._finalPosition.multiplyInPlace(collider._radius);\r\n        //run the callback\r\n        onNewPosition(collisionIndex, this._finalPosition, collider.collidedMesh);\r\n    }\r\n\r\n    public createCollider(): Collider {\r\n        return new Collider();\r\n    }\r\n\r\n    public init(scene: Scene): void {\r\n        this._scene = scene;\r\n    }\r\n\r\n    private _collideWithWorld(position: Vector3, velocity: Vector3, collider: Collider, maximumRetry: number, finalPosition: Vector3, excludedMesh: Nullable<AbstractMesh> = null): void {\r\n        var closeDistance = Engine.CollisionsEpsilon * 10.0;\r\n\r\n        if (collider._retry >= maximumRetry) {\r\n            finalPosition.copyFrom(position);\r\n            return;\r\n        }\r\n\r\n        // Check if this is a mesh else camera or -1\r\n        var collisionMask = (excludedMesh ? excludedMesh.collisionMask : collider.collisionMask);\r\n\r\n        collider._initialize(position, velocity, closeDistance);\r\n\r\n        // Check all meshes\r\n        for (var index = 0; index < this._scene.meshes.length; index++) {\r\n            var mesh = this._scene.meshes[index];\r\n            if (mesh.isEnabled() && mesh.checkCollisions && mesh.subMeshes && mesh !== excludedMesh && ((collisionMask & mesh.collisionGroup) !== 0)) {\r\n                mesh._checkCollision(collider);\r\n            }\r\n        }\r\n\r\n        if (!collider.collisionFound) {\r\n            position.addToRef(velocity, finalPosition);\r\n            return;\r\n        }\r\n\r\n        if (velocity.x !== 0 || velocity.y !== 0 || velocity.z !== 0) {\r\n            collider._getResponse(position, velocity);\r\n        }\r\n\r\n        if (velocity.length() <= closeDistance) {\r\n            finalPosition.copyFrom(position);\r\n            return;\r\n        }\r\n\r\n        collider._retry++;\r\n        this._collideWithWorld(position, velocity, collider, maximumRetry, finalPosition, excludedMesh);\r\n    }\r\n}\r\n\r\nScene.CollisionCoordinatorFactory = () => {\r\n    return new DefaultCollisionCoordinator();\r\n};\r\n"]}