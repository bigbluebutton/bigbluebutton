import { Nullable } from '../types';
import { PickingInfo } from '../Collisions/pickingInfo';
import { Vector2 } from '../Maths/math.vector';
import { AbstractMesh } from '../Meshes/abstractMesh';
declare type Scene = import("../scene").Scene;
/**
 * Class used to manage all inputs for the scene.
 */
export declare class InputManager {
    /** The distance in pixel that you have to move to prevent some events */
    static DragMovementThreshold: number;
    /** Time in milliseconds to wait to raise long press events if button is still pressed */
    static LongPressDelay: number;
    /** Time in milliseconds with two consecutive clicks will be considered as a double click */
    static DoubleClickDelay: number;
    /** If you need to check double click without raising a single click at first click, enable this flag */
    static ExclusiveDoubleClickMode: boolean;
    private _wheelEventName;
    private _onPointerMove;
    private _onPointerDown;
    private _onPointerUp;
    private _initClickEvent;
    private _initActionManager;
    private _delayedSimpleClick;
    private _delayedSimpleClickTimeout;
    private _previousDelayedSimpleClickTimeout;
    private _meshPickProceed;
    private _previousButtonPressed;
    private _currentPickResult;
    private _previousPickResult;
    private _totalPointersPressed;
    private _doubleClickOccured;
    private _pointerOverMesh;
    private _pickedDownMesh;
    private _pickedUpMesh;
    private _pointerX;
    private _pointerY;
    private _unTranslatedPointerX;
    private _unTranslatedPointerY;
    private _startingPointerPosition;
    private _previousStartingPointerPosition;
    private _startingPointerTime;
    private _previousStartingPointerTime;
    private _pointerCaptures;
    private _onKeyDown;
    private _onKeyUp;
    private _onCanvasFocusObserver;
    private _onCanvasBlurObserver;
    private _scene;
    /**
     * Creates a new InputManager
     * @param scene defines the hosting scene
     */
    constructor(scene: Scene);
    /**
    * Gets the mesh that is currently under the pointer
    */
    get meshUnderPointer(): Nullable<AbstractMesh>;
    /**
     * Gets the pointer coordinates in 2D without any translation (ie. straight out of the pointer event)
     */
    get unTranslatedPointer(): Vector2;
    /**
     * Gets or sets the current on-screen X position of the pointer
     */
    get pointerX(): number;
    set pointerX(value: number);
    /**
     * Gets or sets the current on-screen Y position of the pointer
     */
    get pointerY(): number;
    set pointerY(value: number);
    private _updatePointerPosition;
    private _processPointerMove;
    private _setRayOnPointerInfo;
    private _checkPrePointerObservable;
    /**
     * Use this method to simulate a pointer move on a mesh
     * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay
     * @param pickResult pickingInfo of the object wished to simulate pointer event on
     * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)
     */
    simulatePointerMove(pickResult: PickingInfo, pointerEventInit?: PointerEventInit): void;
    /**
     * Use this method to simulate a pointer down on a mesh
     * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay
     * @param pickResult pickingInfo of the object wished to simulate pointer event on
     * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)
     */
    simulatePointerDown(pickResult: PickingInfo, pointerEventInit?: PointerEventInit): void;
    private _processPointerDown;
    /** @hidden */
    _isPointerSwiping(): boolean;
    /**
     * Use this method to simulate a pointer up on a mesh
     * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay
     * @param pickResult pickingInfo of the object wished to simulate pointer event on
     * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)
     * @param doubleTap indicates that the pointer up event should be considered as part of a double click (false by default)
     */
    simulatePointerUp(pickResult: PickingInfo, pointerEventInit?: PointerEventInit, doubleTap?: boolean): void;
    private _processPointerUp;
    /**
     * Gets a boolean indicating if the current pointer event is captured (meaning that the scene has already handled the pointer down)
     * @param pointerId defines the pointer id to use in a multi-touch scenario (0 by default)
     * @returns true if the pointer was captured
     */
    isPointerCaptured(pointerId?: number): boolean;
    /**
    * Attach events to the canvas (To handle actionManagers triggers and raise onPointerMove, onPointerDown and onPointerUp
    * @param attachUp defines if you want to attach events to pointerup
    * @param attachDown defines if you want to attach events to pointerdown
    * @param attachMove defines if you want to attach events to pointermove
    * @param elementToAttachTo defines the target DOM element to attach to (will use the canvas by default)
    */
    attachControl(attachUp?: boolean, attachDown?: boolean, attachMove?: boolean, elementToAttachTo?: Nullable<HTMLElement>): void;
    /**
     * Detaches all event handlers
     */
    detachControl(): void;
    /**
     * Force the value of meshUnderPointer
     * @param mesh defines the mesh to use
     */
    setPointerOverMesh(mesh: Nullable<AbstractMesh>): void;
    /**
     * Gets the mesh under the pointer
     * @returns a Mesh or null if no mesh is under the pointer
     */
    getPointerOverMesh(): Nullable<AbstractMesh>;
}
export {};
