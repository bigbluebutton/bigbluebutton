{"version":3,"file":"INavigationEngine.js","sourceRoot":"","sources":["../../../sourceES6/core/Navigation/INavigationEngine.ts"],"names":[],"mappings":"","sourcesContent":["import { TransformNode } from \"../Meshes/transformNode\";\r\nimport { Vector3 } from \"../Maths/math\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { Scene } from \"../scene\";\r\n\r\n/**\r\n * Navigation plugin interface to add navigation constrained by a navigation mesh\r\n */\r\nexport interface INavigationEnginePlugin {\r\n    /**\r\n     * plugin name\r\n     */\r\n    name: string;\r\n\r\n    /**\r\n     * Creates a navigation mesh\r\n     * @param meshes array of all the geometry used to compute the navigatio mesh\r\n     * @param parameters bunch of parameters used to filter geometry\r\n     */\r\n    createNavMesh(meshes: Array<Mesh>, parameters: INavMeshParameters): void;\r\n\r\n    /**\r\n     * Create a navigation mesh debug mesh\r\n     * @param scene is where the mesh will be added\r\n     * @returns debug display mesh\r\n     */\r\n    createDebugNavMesh(scene: Scene): Mesh;\r\n\r\n    /**\r\n     * Get a navigation mesh constrained position, closest to the parameter position\r\n     * @param position world position\r\n     * @returns the closest point to position constrained by the navigation mesh\r\n     */\r\n    getClosestPoint(position: Vector3): Vector3;\r\n\r\n    /**\r\n     * Get a navigation mesh constrained position, within a particular radius\r\n     * @param position world position\r\n     * @param maxRadius the maximum distance to the constrained world position\r\n     * @returns the closest point to position constrained by the navigation mesh\r\n     */\r\n    getRandomPointAround(position: Vector3, maxRadius: number): Vector3;\r\n\r\n    /**\r\n     * Compute the final position from a segment made of destination-position\r\n     * @param position world position\r\n     * @param destination world position\r\n     * @returns the resulting point along the navmesh\r\n     */\r\n    moveAlong(position: Vector3, destination: Vector3): Vector3;\r\n\r\n    /**\r\n     * Compute a navigation path from start to end. Returns an empty array if no path can be computed\r\n     * @param start world position\r\n     * @param end world position\r\n     * @returns array containing world position composing the path\r\n     */\r\n    computePath(start: Vector3, end: Vector3): Vector3[];\r\n\r\n    /**\r\n     * If this plugin is supported\r\n     * @returns true if plugin is supported\r\n     */\r\n    isSupported(): boolean;\r\n\r\n    /**\r\n     * Create a new Crowd so you can add agents\r\n     * @param maxAgents the maximum agent count in the crowd\r\n     * @param maxAgentRadius the maximum radius an agent can have\r\n     * @param scene to attach the crowd to\r\n     * @returns the crowd you can add agents to\r\n     */\r\n    createCrowd(maxAgents: number, maxAgentRadius: number, scene: Scene): ICrowd;\r\n\r\n    /**\r\n     * Set the Bounding box extent for doing spatial queries (getClosestPoint, getRandomPointAround, ...)\r\n     * The queries will try to find a solution within those bounds\r\n     * default is (1,1,1)\r\n     * @param extent x,y,z value that define the extent around the queries point of reference\r\n     */\r\n    setDefaultQueryExtent(extent: Vector3): void;\r\n\r\n    /**\r\n     * Get the Bounding box extent specified by setDefaultQueryExtent\r\n     * @returns the box extent values\r\n     */\r\n    getDefaultQueryExtent(): Vector3;\r\n\r\n    /**\r\n     * Release all resources\r\n     */\r\n    dispose(): void;\r\n}\r\n\r\n/**\r\n * Crowd Interface. A Crowd is a collection of moving agents constrained by a navigation mesh\r\n */\r\nexport interface ICrowd {\r\n    /**\r\n     * Add a new agent to the crowd with the specified parameter a corresponding transformNode.\r\n     * You can attach anything to that node. The node position is updated in the scene update tick.\r\n     * @param pos world position that will be constrained by the navigation mesh\r\n     * @param parameters agent parameters\r\n     * @param transform hooked to the agent that will be update by the scene\r\n     * @returns agent index\r\n     */\r\n    addAgent(pos: Vector3, parameters: IAgentParameters, transform: TransformNode): number;\r\n\r\n    /**\r\n     * Returns the agent position in world space\r\n     * @param index agent index returned by addAgent\r\n     * @returns world space position\r\n     */\r\n    getAgentPosition(index: number): Vector3;\r\n\r\n    /**\r\n     * Gets the agent velocity in world space\r\n     * @param index agent index returned by addAgent\r\n     * @returns world space velocity\r\n     */\r\n    getAgentVelocity(index: number): Vector3;\r\n\r\n    /**\r\n     * remove a particular agent previously created\r\n     * @param index agent index returned by addAgent\r\n     */\r\n    removeAgent(index: number): void;\r\n\r\n    /**\r\n     * get the list of all agents attached to this crowd\r\n     * @returns list of agent indices\r\n     */\r\n    getAgents() : number[];\r\n\r\n    /**\r\n     * Tick update done by the Scene. Agent position/velocity/acceleration is updated by this function\r\n     * @param deltaTime in seconds\r\n     */\r\n    update(deltaTime: number): void;\r\n\r\n    /**\r\n     * Asks a particular agent to go to a destination. That destination is constrained by the navigation mesh\r\n     * @param index agent index returned by addAgent\r\n     * @param destination targeted world position\r\n     */\r\n    agentGoto(index: number, destination: Vector3): void;\r\n\r\n    /**\r\n     * Teleport the agent to a new position\r\n     * @param index agent index returned by addAgent\r\n     * @param destination targeted world position\r\n     */\r\n    agentTeleport(index: number, destination: Vector3): void;\r\n\r\n    /**\r\n     * Update agent parameters\r\n     * @param index agent index returned by addAgent\r\n     * @param parameters agent parameters\r\n     */\r\n    updateAgentParameters(index: number, parameters: IAgentParameters): void;\r\n\r\n    /**\r\n     * Set the Bounding box extent for doing spatial queries (getClosestPoint, getRandomPointAround, ...)\r\n     * The queries will try to find a solution within those bounds\r\n     * default is (1,1,1)\r\n     * @param extent x,y,z value that define the extent around the queries point of reference\r\n     */\r\n    setDefaultQueryExtent(extent: Vector3): void;\r\n\r\n    /**\r\n     * Get the Bounding box extent specified by setDefaultQueryExtent\r\n     * @returns the box extent values\r\n     */\r\n    getDefaultQueryExtent(): Vector3;\r\n\r\n    /**\r\n     * Release all resources\r\n     */\r\n    dispose() : void;\r\n}\r\n\r\n/**\r\n * Configures an agent\r\n */\r\nexport interface IAgentParameters {\r\n    /**\r\n     *  Agent radius. [Limit: >= 0]\r\n     */\r\n    radius: number;\r\n\r\n    /**\r\n     * Agent height. [Limit: > 0]\r\n     */\r\n    height: number;\r\n\r\n    /**\r\n     *  Maximum allowed acceleration. [Limit: >= 0]\r\n     */\r\n    maxAcceleration: number;\r\n\r\n    /**\r\n     * Maximum allowed speed. [Limit: >= 0]\r\n     */\r\n    maxSpeed: number;\r\n\r\n    /**\r\n     * Defines how close a collision element must be before it is considered for steering behaviors. [Limits: > 0]\r\n     */\r\n    collisionQueryRange: number;\r\n\r\n    /**\r\n     * The path visibility optimization range. [Limit: > 0]\r\n     */\r\n    pathOptimizationRange: number;\r\n\r\n    /**\r\n     * How aggresive the agent manager should be at avoiding collisions with this agent. [Limit: >= 0]\r\n     */\r\n    separationWeight: number;\r\n}\r\n\r\n/**\r\n * Configures the navigation mesh creation\r\n */\r\nexport interface INavMeshParameters {\r\n    /**\r\n     * The xz-plane cell size to use for fields. [Limit: > 0] [Units: wu]\r\n     */\r\n    cs: number;\r\n\r\n    /**\r\n     * The y-axis cell size to use for fields. [Limit: > 0] [Units: wu]\r\n     */\r\n    ch: number;\r\n\r\n    /**\r\n     * The maximum slope that is considered walkable. [Limits: 0 <= value < 90] [Units: Degrees]\r\n     */\r\n    walkableSlopeAngle: number;\r\n\r\n    /**\r\n     * Minimum floor to 'ceiling' height that will still allow the floor area to\r\n     * be considered walkable. [Limit: >= 3] [Units: vx]\r\n     */\r\n    walkableHeight: number;\r\n\r\n    /**\r\n     * Maximum ledge height that is considered to still be traversable. [Limit: >=0] [Units: vx]\r\n     */\r\n    walkableClimb: number;\r\n\r\n    /**\r\n     * The distance to erode/shrink the walkable area of the heightfield away from\r\n     * obstructions.  [Limit: >=0] [Units: vx]\r\n     */\r\n    walkableRadius: number;\r\n\r\n    /**\r\n     * The maximum allowed length for contour edges along the border of the mesh. [Limit: >=0] [Units: vx]\r\n     */\r\n    maxEdgeLen: number;\r\n\r\n    /**\r\n     * The maximum distance a simplfied contour's border edges should deviate\r\n     * the original raw contour. [Limit: >=0] [Units: vx]\r\n     */\r\n    maxSimplificationError: number;\r\n\r\n    /**\r\n     * The minimum number of cells allowed to form isolated island areas. [Limit: >=0] [Units: vx]\r\n     */\r\n    minRegionArea: number;\r\n\r\n    /**\r\n     * Any regions with a span count smaller than this value will, if possible,\r\n     * be merged with larger regions. [Limit: >=0] [Units: vx]\r\n     */\r\n    mergeRegionArea: number;\r\n\r\n    /**\r\n     * The maximum number of vertices allowed for polygons generated during the\r\n     * contour to polygon conversion process. [Limit: >= 3]\r\n     */\r\n    maxVertsPerPoly: number;\r\n\r\n    /**\r\n     * Sets the sampling distance to use when generating the detail mesh.\r\n     * (For height detail only.) [Limits: 0 or >= 0.9] [Units: wu]\r\n     */\r\n    detailSampleDist: number;\r\n\r\n    /**\r\n     * The maximum distance the detail mesh surface should deviate from heightfield\r\n     * data. (For height detail only.) [Limit: >=0] [Units: wu]\r\n     */\r\n    detailSampleMaxError: number;\r\n}\r\n"]}