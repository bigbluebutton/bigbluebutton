import { Mesh } from "../Meshes/mesh";
import { GPUParticleSystem } from "./gpuParticleSystem";
import { AbstractScene } from "../abstractScene";
import { Engine } from "../Engines/engine";
import { ParticleSystem } from "./particleSystem";
import { SceneComponentConstants } from "../sceneComponent";
import "../Shaders/particles.vertex";
// Adds the parsers to the scene parsers.
AbstractScene.AddParser(SceneComponentConstants.NAME_PARTICLESYSTEM, function (parsedData, scene, container, rootUrl) {
    var individualParser = AbstractScene.GetIndividualParser(SceneComponentConstants.NAME_PARTICLESYSTEM);
    if (!individualParser) {
        return;
    }
    // Particles Systems
    if (parsedData.particleSystems !== undefined && parsedData.particleSystems !== null) {
        for (var index = 0, cache = parsedData.particleSystems.length; index < cache; index++) {
            var parsedParticleSystem = parsedData.particleSystems[index];
            container.particleSystems.push(individualParser(parsedParticleSystem, scene, rootUrl));
        }
    }
});
AbstractScene.AddIndividualParser(SceneComponentConstants.NAME_PARTICLESYSTEM, function (parsedParticleSystem, scene, rootUrl) {
    if (parsedParticleSystem.activeParticleCount) {
        var ps = GPUParticleSystem.Parse(parsedParticleSystem, scene, rootUrl);
        return ps;
    }
    else {
        var ps = ParticleSystem.Parse(parsedParticleSystem, scene, rootUrl);
        return ps;
    }
});
Engine.prototype.createEffectForParticles = function (fragmentName, uniformsNames, samplers, defines, fallbacks, onCompiled, onError) {
    if (uniformsNames === void 0) { uniformsNames = []; }
    if (samplers === void 0) { samplers = []; }
    if (defines === void 0) { defines = ""; }
    var attributesNamesOrOptions = ParticleSystem._GetAttributeNamesOrOptions();
    var effectCreationOption = ParticleSystem._GetEffectCreationOptions();
    if (defines.indexOf(" BILLBOARD") === -1) {
        defines += "\n#define BILLBOARD\n";
    }
    if (samplers.indexOf("diffuseSampler") === -1) {
        samplers.push("diffuseSampler");
    }
    return this.createEffect({
        vertex: "particles",
        fragmentElement: fragmentName
    }, attributesNamesOrOptions, effectCreationOption.concat(uniformsNames), samplers, defines, fallbacks, onCompiled, onError);
};
Mesh.prototype.getEmittedParticleSystems = function () {
    var results = new Array();
    for (var index = 0; index < this.getScene().particleSystems.length; index++) {
        var particleSystem = this.getScene().particleSystems[index];
        if (particleSystem.emitter === this) {
            results.push(particleSystem);
        }
    }
    return results;
};
Mesh.prototype.getHierarchyEmittedParticleSystems = function () {
    var results = new Array();
    var descendants = this.getDescendants();
    descendants.push(this);
    for (var index = 0; index < this.getScene().particleSystems.length; index++) {
        var particleSystem = this.getScene().particleSystems[index];
        var emitter = particleSystem.emitter;
        if (emitter.position && descendants.indexOf(emitter) !== -1) {
            results.push(particleSystem);
        }
    }
    return results;
};
/**
 * @hidden
 */
export var _IDoNeedToBeInTheBuild = 42;
//# sourceMappingURL=particleSystemComponent.js.map