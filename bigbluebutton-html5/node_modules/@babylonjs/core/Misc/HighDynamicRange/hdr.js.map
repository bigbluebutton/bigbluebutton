{"version":3,"file":"hdr.js","sourceRoot":"","sources":["../../../../sourceES6/core/Misc/HighDynamicRange/hdr.ts"],"names":[],"mappings":"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","sourcesContent":["import { CubeMapInfo, PanoramaToCubeMapTools } from \"./panoramaToCubemap\";\r\n\r\n/**\r\n * Header information of HDR texture files.\r\n */\r\nexport interface HDRInfo {\r\n    /**\r\n     * The height of the texture in pixels.\r\n     */\r\n    height: number;\r\n\r\n    /**\r\n     * The width of the texture in pixels.\r\n     */\r\n    width: number;\r\n\r\n    /**\r\n     * The index of the beginning of the data in the binary file.\r\n     */\r\n    dataPosition: number;\r\n}\r\n\r\n/**\r\n * This groups tools to convert HDR texture to native colors array.\r\n */\r\nexport class HDRTools {\r\n\r\n    private static Ldexp(mantissa: number, exponent: number): number {\r\n        if (exponent > 1023) {\r\n            return mantissa * Math.pow(2, 1023) * Math.pow(2, exponent - 1023);\r\n        }\r\n\r\n        if (exponent < -1074) {\r\n            return mantissa * Math.pow(2, -1074) * Math.pow(2, exponent + 1074);\r\n        }\r\n\r\n        return mantissa * Math.pow(2, exponent);\r\n    }\r\n\r\n    private static Rgbe2float(float32array: Float32Array,\r\n        red: number, green: number, blue: number, exponent: number,\r\n        index: number) {\r\n        if (exponent > 0) {   /*nonzero pixel*/\r\n            exponent = this.Ldexp(1.0, exponent - (128 + 8));\r\n\r\n            float32array[index + 0] = red * exponent;\r\n            float32array[index + 1] = green * exponent;\r\n            float32array[index + 2] = blue * exponent;\r\n        }\r\n        else {\r\n            float32array[index + 0] = 0;\r\n            float32array[index + 1] = 0;\r\n            float32array[index + 2] = 0;\r\n        }\r\n    }\r\n\r\n    private static readStringLine(uint8array: Uint8Array, startIndex: number): string {\r\n        var line = \"\";\r\n        var character = \"\";\r\n\r\n        for (var i = startIndex; i < uint8array.length - startIndex; i++) {\r\n            character = String.fromCharCode(uint8array[i]);\r\n\r\n            if (character == \"\\n\") {\r\n                break;\r\n            }\r\n\r\n            line += character;\r\n        }\r\n\r\n        return line;\r\n    }\r\n\r\n    /**\r\n     * Reads header information from an RGBE texture stored in a native array.\r\n     * More information on this format are available here:\r\n     * https://en.wikipedia.org/wiki/RGBE_image_format\r\n     *\r\n     * @param uint8array The binary file stored in  native array.\r\n     * @return The header information.\r\n     */\r\n    public static RGBE_ReadHeader(uint8array: Uint8Array): HDRInfo {\r\n        var height: number = 0;\r\n        var width: number = 0;\r\n\r\n        var line = this.readStringLine(uint8array, 0);\r\n        if (line[0] != '#' || line[1] != '?') {\r\n            throw \"Bad HDR Format.\";\r\n        }\r\n\r\n        var endOfHeader = false;\r\n        var findFormat = false;\r\n        var lineIndex: number = 0;\r\n\r\n        do {\r\n            lineIndex += (line.length + 1);\r\n            line = this.readStringLine(uint8array, lineIndex);\r\n\r\n            if (line == \"FORMAT=32-bit_rle_rgbe\") {\r\n                findFormat = true;\r\n            }\r\n            else if (line.length == 0) {\r\n                endOfHeader = true;\r\n            }\r\n        } while (!endOfHeader);\r\n\r\n        if (!findFormat) {\r\n            throw \"HDR Bad header format, unsupported FORMAT\";\r\n        }\r\n\r\n        lineIndex += (line.length + 1);\r\n        line = this.readStringLine(uint8array, lineIndex);\r\n\r\n        var sizeRegexp = /^\\-Y (.*) \\+X (.*)$/g;\r\n        var match = sizeRegexp.exec(line);\r\n\r\n        // TODO. Support +Y and -X if needed.\r\n        if (!match || match.length < 3) {\r\n            throw \"HDR Bad header format, no size\";\r\n        }\r\n        width = parseInt(match[2]);\r\n        height = parseInt(match[1]);\r\n\r\n        if (width < 8 || width > 0x7fff) {\r\n            throw \"HDR Bad header format, unsupported size\";\r\n        }\r\n\r\n        lineIndex += (line.length + 1);\r\n\r\n        return {\r\n            height: height,\r\n            width: width,\r\n            dataPosition: lineIndex\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Returns the cubemap information (each faces texture data) extracted from an RGBE texture.\r\n     * This RGBE texture needs to store the information as a panorama.\r\n     *\r\n     * More information on this format are available here:\r\n     * https://en.wikipedia.org/wiki/RGBE_image_format\r\n     *\r\n     * @param buffer The binary file stored in an array buffer.\r\n     * @param size The expected size of the extracted cubemap.\r\n     * @return The Cube Map information.\r\n     */\r\n    public static GetCubeMapTextureData(buffer: ArrayBuffer, size: number): CubeMapInfo {\r\n        var uint8array = new Uint8Array(buffer);\r\n        var hdrInfo = this.RGBE_ReadHeader(uint8array);\r\n        var data = this.RGBE_ReadPixels_RLE(uint8array, hdrInfo);\r\n\r\n        var cubeMapData = PanoramaToCubeMapTools.ConvertPanoramaToCubemap(data, hdrInfo.width, hdrInfo.height, size);\r\n\r\n        return cubeMapData;\r\n    }\r\n\r\n    /**\r\n     * Returns the pixels data extracted from an RGBE texture.\r\n     * This pixels will be stored left to right up to down in the R G B order in one array.\r\n     *\r\n     * More information on this format are available here:\r\n     * https://en.wikipedia.org/wiki/RGBE_image_format\r\n     *\r\n     * @param uint8array The binary file stored in an array buffer.\r\n     * @param hdrInfo The header information of the file.\r\n     * @return The pixels data in RGB right to left up to down order.\r\n     */\r\n    public static RGBE_ReadPixels(uint8array: Uint8Array, hdrInfo: HDRInfo): Float32Array {\r\n        // Keep for multi format supports.\r\n        return this.RGBE_ReadPixels_RLE(uint8array, hdrInfo);\r\n    }\r\n\r\n    private static RGBE_ReadPixels_RLE(uint8array: Uint8Array, hdrInfo: HDRInfo): Float32Array {\r\n        var num_scanlines = hdrInfo.height;\r\n        var scanline_width = hdrInfo.width;\r\n\r\n        var a: number, b: number, c: number, d: number, count: number;\r\n        var dataIndex = hdrInfo.dataPosition;\r\n        var index = 0, endIndex = 0, i = 0;\r\n\r\n        var scanLineArrayBuffer = new ArrayBuffer(scanline_width * 4); // four channel R G B E\r\n        var scanLineArray = new Uint8Array(scanLineArrayBuffer);\r\n\r\n        // 3 channels of 4 bytes per pixel in float.\r\n        var resultBuffer = new ArrayBuffer(hdrInfo.width * hdrInfo.height * 4 * 3);\r\n        var resultArray = new Float32Array(resultBuffer);\r\n\r\n        // read in each successive scanline\r\n        while (num_scanlines > 0) {\r\n            a = uint8array[dataIndex++];\r\n            b = uint8array[dataIndex++];\r\n            c = uint8array[dataIndex++];\r\n            d = uint8array[dataIndex++];\r\n\r\n            if (a != 2 || b != 2 || (c & 0x80)) {\r\n                // this file is not run length encoded\r\n                throw \"HDR Bad header format, not RLE\";\r\n            }\r\n\r\n            if (((c << 8) | d) != scanline_width) {\r\n                throw \"HDR Bad header format, wrong scan line width\";\r\n            }\r\n\r\n            index = 0;\r\n\r\n            // read each of the four channels for the scanline into the buffer\r\n            for (i = 0; i < 4; i++) {\r\n                endIndex = (i + 1) * scanline_width;\r\n\r\n                while (index < endIndex) {\r\n                    a = uint8array[dataIndex++];\r\n                    b = uint8array[dataIndex++];\r\n\r\n                    if (a > 128) {\r\n                        // a run of the same value\r\n                        count = a - 128;\r\n                        if ((count == 0) || (count > endIndex - index)) {\r\n                            throw \"HDR Bad Format, bad scanline data (run)\";\r\n                        }\r\n\r\n                        while (count-- > 0) {\r\n                            scanLineArray[index++] = b;\r\n                        }\r\n                    }\r\n                    else {\r\n                        // a non-run\r\n                        count = a;\r\n                        if ((count == 0) || (count > endIndex - index)) {\r\n                            throw \"HDR Bad Format, bad scanline data (non-run)\";\r\n                        }\r\n\r\n                        scanLineArray[index++] = b;\r\n                        if (--count > 0) {\r\n                            for (var j = 0; j < count; j++) {\r\n                                scanLineArray[index++] = uint8array[dataIndex++];\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // now convert data from buffer into floats\r\n            for (i = 0; i < scanline_width; i++) {\r\n                a = scanLineArray[i];\r\n                b = scanLineArray[i + scanline_width];\r\n                c = scanLineArray[i + 2 * scanline_width];\r\n                d = scanLineArray[i + 3 * scanline_width];\r\n\r\n                this.Rgbe2float(resultArray,\r\n                    a, b, c, d,\r\n                    (hdrInfo.height - num_scanlines) * scanline_width * 3 + i * 3);\r\n            }\r\n\r\n            num_scanlines--;\r\n        }\r\n\r\n        return resultArray;\r\n    }\r\n}\r\n"]}