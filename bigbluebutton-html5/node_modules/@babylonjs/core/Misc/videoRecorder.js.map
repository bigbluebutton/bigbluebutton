{"version":3,"file":"videoRecorder.js","sourceRoot":"","sources":["../../../sourceES6/core/Misc/videoRecorder.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable } from \"../types\";\r\nimport { Tools } from \"./tools\";\r\nimport { Engine } from \"../Engines/engine\";\r\n\r\ninterface MediaRecorder {\r\n    /** Starts recording */\r\n    start(timeSlice: number): void;\r\n    /** Stops recording */\r\n    stop(): void;\r\n\r\n    /** Event raised when an error arised. */\r\n    onerror: (event: ErrorEvent) => void;\r\n    /** Event raised when the recording stops. */\r\n    onstop: (event: Event) => void;\r\n    /** Event raised when a new chunk of data is available and should be tracked. */\r\n    ondataavailable: (event: Event) => void;\r\n}\r\n\r\ninterface MediaRecorderOptions {\r\n    /** The mime type you want to use as the recording container for the new MediaRecorder. */\r\n    mimeType?: string;\r\n    /** The chosen bitrate for the audio component of the media. */\r\n    audioBitsPerSecond?: number;\r\n    /** The chosen bitrate for the video component of the media. */\r\n    videoBitsPerSecond?: number;\r\n    /** The chosen bitrate for the audio and video components of the media. This can be specified instead of the above two properties.\r\n     * If this is specified along with one or the other of the above properties, this will be used for the one that isn't specified. */\r\n    bitsPerSecond?: number;\r\n}\r\n\r\ninterface MediaRecorderConstructor {\r\n    /**\r\n     * A reference to the prototype.\r\n     */\r\n    readonly prototype: MediaRecorder;\r\n\r\n    /**\r\n     * Creates a new MediaRecorder.\r\n     * @param stream Defines the stream to record.\r\n     * @param options Defines the options for the recorder available in the type MediaRecorderOptions.\r\n     */\r\n    new(stream: MediaStream, options?: MediaRecorderOptions): MediaRecorder;\r\n}\r\n\r\n/**\r\n * MediaRecoreder object available in some browsers.\r\n */\r\ndeclare var MediaRecorder: MediaRecorderConstructor;\r\n\r\n/**\r\n * This represents the different options available for the video capture.\r\n */\r\nexport interface VideoRecorderOptions {\r\n    /** Defines the mime type of the video. */\r\n    mimeType: string;\r\n    /** Defines the FPS the video should be recorded at. */\r\n    fps: number;\r\n    /** Defines the chunk size for the recording data. */\r\n    recordChunckSize: number;\r\n    /** The audio tracks to attach to the recording. */\r\n    audioTracks?: MediaStreamTrack[];\r\n}\r\n\r\n/**\r\n * This can help with recording videos from BabylonJS.\r\n * This is based on the available WebRTC functionalities of the browser.\r\n *\r\n * @see http://doc.babylonjs.com/how_to/render_scene_on_a_video\r\n */\r\nexport class VideoRecorder {\r\n\r\n    private static readonly _defaultOptions = {\r\n        mimeType: \"video/webm\",\r\n        fps: 25,\r\n        recordChunckSize: 3000\r\n    };\r\n\r\n    /**\r\n     * Returns whether or not the VideoRecorder is available in your browser.\r\n     * @param engine Defines the Babylon Engine.\r\n     * @returns true if supported otherwise false.\r\n     */\r\n    public static IsSupported(engine: Engine): boolean {\r\n        const canvas = engine.getRenderingCanvas();\r\n        return (!!canvas && typeof (<any>canvas).captureStream === \"function\");\r\n    }\r\n\r\n    private readonly _options: VideoRecorderOptions;\r\n    private _canvas: Nullable<HTMLCanvasElement>;\r\n    private _mediaRecorder: Nullable<MediaRecorder>;\r\n\r\n    private _recordedChunks: any[];\r\n    private _fileName: Nullable<string>;\r\n    private _resolve: Nullable<(blob: Blob) => void>;\r\n    private _reject: Nullable<(error: any) => void>;\r\n\r\n    /**\r\n     * True when a recording is already in progress.\r\n     */\r\n    public get isRecording(): boolean {\r\n        return !!this._canvas && this._canvas.isRecording;\r\n    }\r\n\r\n    /**\r\n     * Create a new VideoCapture object which can help converting what you see in Babylon to a video file.\r\n     * @param engine Defines the BabylonJS Engine you wish to record.\r\n     * @param options Defines options that can be used to customize the capture.\r\n     */\r\n    constructor(engine: Engine, options: Nullable<VideoRecorderOptions> = null) {\r\n        if (!VideoRecorder.IsSupported(engine)) {\r\n            throw \"Your browser does not support recording so far.\";\r\n        }\r\n\r\n        const canvas = engine.getRenderingCanvas();\r\n        if (!canvas) {\r\n            throw \"The babylon engine must have a canvas to be recorded\";\r\n        }\r\n\r\n        this._canvas = canvas;\r\n        this._canvas.isRecording = false;\r\n\r\n        this._options = {\r\n            ...VideoRecorder._defaultOptions,\r\n            ...options\r\n        };\r\n\r\n        const stream = this._canvas.captureStream(this._options.fps);\r\n        if (this._options.audioTracks) {\r\n            for (let track of this._options.audioTracks) {\r\n                stream.addTrack(track);\r\n            }\r\n        }\r\n\r\n        this._mediaRecorder = new MediaRecorder(stream, { mimeType: this._options.mimeType });\r\n        this._mediaRecorder.ondataavailable = this._handleDataAvailable.bind(this);\r\n        this._mediaRecorder.onerror = this._handleError.bind(this);\r\n        this._mediaRecorder.onstop = this._handleStop.bind(this);\r\n    }\r\n\r\n    /**\r\n     * Stops the current recording before the default capture timeout passed in the startRecording function.\r\n     */\r\n    public stopRecording(): void {\r\n        if (!this._canvas || !this._mediaRecorder) {\r\n            return;\r\n        }\r\n\r\n        if (!this.isRecording) {\r\n            return;\r\n        }\r\n\r\n        this._canvas.isRecording = false;\r\n        this._mediaRecorder.stop();\r\n    }\r\n\r\n    /**\r\n     * Starts recording the canvas for a max duration specified in parameters.\r\n     * @param fileName Defines the name of the file to be downloaded when the recording stop.\r\n     * If null no automatic download will start and you can rely on the promise to get the data back.\r\n     * @param maxDuration Defines the maximum recording time in seconds.\r\n     * It defaults to 7 seconds. A value of zero will not stop automatically, you would need to call stopRecording manually.\r\n     * @return A promise callback at the end of the recording with the video data in Blob.\r\n     */\r\n    public startRecording(fileName: Nullable<string> = \"babylonjs.webm\", maxDuration = 7): Promise<Blob> {\r\n        if (!this._canvas || !this._mediaRecorder) {\r\n            throw \"Recorder has already been disposed\";\r\n        }\r\n\r\n        if (this.isRecording) {\r\n            throw \"Recording already in progress\";\r\n        }\r\n\r\n        if (maxDuration > 0) {\r\n            setTimeout(() => {\r\n                this.stopRecording();\r\n            }, maxDuration * 1000);\r\n        }\r\n\r\n        this._fileName = fileName;\r\n        this._recordedChunks = [];\r\n        this._resolve = null;\r\n        this._reject = null;\r\n\r\n        this._canvas.isRecording = true;\r\n        this._mediaRecorder.start(this._options.recordChunckSize);\r\n\r\n        return new Promise<Blob>((resolve, reject) => {\r\n            this._resolve = resolve;\r\n            this._reject = reject;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Releases internal resources used during the recording.\r\n     */\r\n    public dispose() {\r\n        this._canvas = null;\r\n        this._mediaRecorder = null;\r\n\r\n        this._recordedChunks = [];\r\n        this._fileName = null;\r\n        this._resolve = null;\r\n        this._reject = null;\r\n    }\r\n\r\n    private _handleDataAvailable(event: any): void {\r\n        if (event.data.size > 0) {\r\n            this._recordedChunks.push(event.data);\r\n        }\r\n    }\r\n\r\n    private _handleError(event: ErrorEvent): void {\r\n        this.stopRecording();\r\n\r\n        if (this._reject) {\r\n            this._reject(event.error);\r\n        }\r\n        else {\r\n            throw new event.error();\r\n        }\r\n    }\r\n\r\n    private _handleStop(): void {\r\n        this.stopRecording();\r\n\r\n        const superBuffer = new Blob(this._recordedChunks);\r\n        if (this._resolve) {\r\n            this._resolve(superBuffer);\r\n        }\r\n\r\n        window.URL.createObjectURL(superBuffer);\r\n\r\n        if (this._fileName) {\r\n            Tools.Download(superBuffer, this._fileName);\r\n        }\r\n    }\r\n}\r\n"]}