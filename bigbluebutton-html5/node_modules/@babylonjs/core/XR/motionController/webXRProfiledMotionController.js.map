{"version":3,"file":"webXRProfiledMotionController.js","sourceRoot":"","sources":["../../../../sourceES6/core/XR/motionController/webXRProfiledMotionController.ts"],"names":[],"mappings":"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","sourcesContent":["import { AbstractMesh } from '../../Meshes/abstractMesh';\r\nimport { WebXRAbstractMotionController, IMotionControllerProfile, IMotionControllerMeshMap } from './webXRAbstractMotionController';\r\nimport { Scene } from '../../scene';\r\nimport { SceneLoader } from '../../Loading/sceneLoader';\r\nimport { Mesh } from '../../Meshes/mesh';\r\nimport { Axis, Space } from '../../Maths/math.axis';\r\nimport { Color3 } from '../../Maths/math.color';\r\nimport { WebXRControllerComponent } from './webXRControllerComponent';\r\nimport { SphereBuilder } from '../../Meshes/Builders/sphereBuilder';\r\nimport { StandardMaterial } from '../../Materials/standardMaterial';\r\nimport { Logger } from '../../Misc/logger';\r\n\r\n/**\r\n * A profiled motion controller has its profile loaded from an online repository.\r\n * The class is responsible of loading the model, mapping the keys and enabling model-animations\r\n */\r\nexport class WebXRProfiledMotionController extends WebXRAbstractMotionController {\r\n    private _buttonMeshMapping: {\r\n        [buttonName: string]: {\r\n            mainMesh: AbstractMesh;\r\n            states: {\r\n                [state: string]: IMotionControllerMeshMap\r\n            }\r\n        }\r\n    } = {};\r\n    private _touchDots: { [visKey: string]: AbstractMesh } = {};\r\n\r\n    /**\r\n     * The profile ID of this controller. Will be populated when the controller initializes.\r\n     */\r\n    public profileId: string;\r\n\r\n    constructor(scene: Scene, xrInput: XRInputSource, _profile: IMotionControllerProfile, private _repositoryUrl: string) {\r\n        super(scene, _profile.layouts[xrInput.handedness || \"none\"], xrInput.gamepad as any, xrInput.handedness);\r\n        this.profileId = _profile.profileId;\r\n    }\r\n\r\n    public dispose() {\r\n        super.dispose();\r\n        Object.keys(this._touchDots).forEach((visResKey) => {\r\n            this._touchDots[visResKey].dispose();\r\n        });\r\n    }\r\n\r\n    protected _getFilenameAndPath(): { filename: string; path: string; } {\r\n        return {\r\n            filename: this.layout.assetPath,\r\n            path: `${this._repositoryUrl}/profiles/${this.profileId}/`\r\n        };\r\n    }\r\n\r\n    protected _getModelLoadingConstraints(): boolean {\r\n        const glbLoaded = SceneLoader.IsPluginForExtensionAvailable(\".glb\");\r\n        if (!glbLoaded) {\r\n            Logger.Warn('glTF / glb loaded was not registered, using generic controller instead');\r\n        }\r\n        return glbLoaded;\r\n    }\r\n\r\n    protected _processLoadedModel(_meshes: AbstractMesh[]): void {\r\n        this.getComponentIds().forEach((type) => {\r\n            const componentInLayout = this.layout.components[type];\r\n            this._buttonMeshMapping[type] = {\r\n                mainMesh: this._getChildByName(this.rootMesh!, componentInLayout.rootNodeName),\r\n                states: {}\r\n            };\r\n            Object.keys(componentInLayout.visualResponses).forEach((visualResponseKey) => {\r\n                const visResponse = componentInLayout.visualResponses[visualResponseKey];\r\n                if (visResponse.valueNodeProperty === \"transform\") {\r\n                    this._buttonMeshMapping[type].states[visualResponseKey] = {\r\n                        valueMesh: this._getChildByName(this.rootMesh!, visResponse.valueNodeName!),\r\n                        minMesh: this._getChildByName(this.rootMesh!, visResponse.minNodeName!),\r\n                        maxMesh: this._getChildByName(this.rootMesh!, visResponse.maxNodeName!)\r\n                    };\r\n                } else {\r\n                    // visibility, usually for touchpads\r\n                    const nameOfMesh = (componentInLayout.type === WebXRControllerComponent.TOUCHPAD_TYPE && componentInLayout.touchPointNodeName)\r\n                        ? componentInLayout.touchPointNodeName : visResponse.valueNodeName!;\r\n                    this._buttonMeshMapping[type].states[visualResponseKey] = {\r\n                        valueMesh: this._getChildByName(this.rootMesh!, nameOfMesh)\r\n                    };\r\n                    if (componentInLayout.type === WebXRControllerComponent.TOUCHPAD_TYPE && !this._touchDots[visualResponseKey]) {\r\n                        const dot = SphereBuilder.CreateSphere(visualResponseKey + 'dot', {\r\n                            diameter: 0.0015,\r\n                            segments: 8\r\n                        }, this.scene);\r\n                        dot.material = new StandardMaterial(visualResponseKey + 'mat', this.scene);\r\n                        (<StandardMaterial>dot.material).diffuseColor = Color3.Red();\r\n                        dot.parent = this._buttonMeshMapping[type].states[visualResponseKey].valueMesh;\r\n                        dot.isVisible = false;\r\n                        this._touchDots[visualResponseKey] = dot;\r\n                    }\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    protected _setRootMesh(meshes: AbstractMesh[]): void {\r\n        this.rootMesh = new Mesh(this.profileId + \"-\" + this.handness, this.scene);\r\n        this.rootMesh.isPickable = false;\r\n        let rootMesh;\r\n        // Find the root node in the loaded glTF scene, and attach it as a child of 'parentMesh'\r\n        for (let i = 0; i < meshes.length; i++) {\r\n            let mesh = meshes[i];\r\n\r\n            mesh.isPickable = false;\r\n\r\n            if (!mesh.parent) {\r\n                // Handle root node, attach to the new parentMesh\r\n                rootMesh = mesh;\r\n            }\r\n        }\r\n\r\n        if (rootMesh) {\r\n            rootMesh.setParent(this.rootMesh);\r\n        }\r\n\r\n        this.rootMesh.rotate(Axis.Y, Math.PI, Space.WORLD);\r\n    }\r\n\r\n    protected _updateModel(_xrFrame: XRFrame): void {\r\n        if (this.disableAnimation) {\r\n            return;\r\n        }\r\n        this.getComponentIds().forEach((id) => {\r\n            const component = this.getComponent(id);\r\n            if (!component.hasChanges) { return; }\r\n            const meshes = this._buttonMeshMapping[id];\r\n            const componentInLayout = this.layout.components[id];\r\n            Object.keys(componentInLayout.visualResponses).forEach((visualResponseKey) => {\r\n                const visResponse = componentInLayout.visualResponses[visualResponseKey];\r\n                let value = component.value;\r\n                if (visResponse.componentProperty === \"xAxis\") {\r\n                    value = component.axes.x;\r\n                } else if (visResponse.componentProperty === \"yAxis\") {\r\n                    value = component.axes.y;\r\n                }\r\n                if (visResponse.valueNodeProperty === \"transform\") {\r\n                    this._lerpTransform(meshes.states[visualResponseKey], value, visResponse.componentProperty !== \"button\");\r\n                } else {\r\n                    // visibility\r\n                    meshes.states[visualResponseKey].valueMesh.isVisible = component.touched || component.pressed;\r\n                    if (this._touchDots[visualResponseKey]) {\r\n                        this._touchDots[visualResponseKey].isVisible = component.touched || component.pressed;\r\n                    }\r\n                }\r\n            });\r\n        });\r\n    }\r\n}"]}