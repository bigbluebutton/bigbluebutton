import { __awaiter, __generator } from "tslib";
import { WebXRControllerComponent } from './webXRControllerComponent';
import { Observable } from '../../Misc/observable';
import { Logger } from '../../Misc/logger';
import { SceneLoader } from '../../Loading/sceneLoader';
import { Quaternion, Vector3 } from '../../Maths/math.vector';
import { Mesh } from '../../Meshes/mesh';
/**
 * An Abstract Motion controller
 * This class receives an xrInput and a profile layout and uses those to initialize the components
 * Each component has an observable to check for changes in value and state
 */
var WebXRAbstractMotionController = /** @class */ (function () {
    /**
     * constructs a new abstract motion controller
     * @param scene the scene to which the model of the controller will be added
     * @param layout The profile layout to load
     * @param gamepadObject The gamepad object correlating to this controller
     * @param handness handness (left/right/none) of this controller
     * @param _doNotLoadControllerMesh set this flag to ignore the mesh loading
     */
    function WebXRAbstractMotionController(scene, layout, 
    /**
     * The gamepad object correlating to this controller
     */
    gamepadObject, 
    /**
     * handness (left/right/none) of this controller
     */
    handness, _doNotLoadControllerMesh) {
        var _this = this;
        if (_doNotLoadControllerMesh === void 0) { _doNotLoadControllerMesh = false; }
        this.scene = scene;
        this.layout = layout;
        this.gamepadObject = gamepadObject;
        this.handness = handness;
        this._initComponent = function (id) {
            if (!id) {
                return;
            }
            var componentDef = _this.layout.components[id];
            var type = componentDef.type;
            var buttonIndex = componentDef.gamepadIndices.button;
            // search for axes
            var axes = [];
            if (componentDef.gamepadIndices.xAxis !== undefined && componentDef.gamepadIndices.yAxis !== undefined) {
                axes.push(componentDef.gamepadIndices.xAxis, componentDef.gamepadIndices.yAxis);
            }
            _this.components[id] = new WebXRControllerComponent(id, type, buttonIndex, axes);
        };
        this._modelReady = false;
        /**
         * A map of components (WebXRControllerComponent) in this motion controller
         * Components have a ComponentType and can also have both button and axis definitions
         */
        this.components = {};
        /**
         * Disable the model's animation. Can be set at any time.
         */
        this.disableAnimation = false;
        /**
         * Observers registered here will be triggered when the model of this controller is done loading
         */
        this.onModelLoadedObservable = new Observable();
        // initialize the components
        if (layout.components) {
            Object.keys(layout.components).forEach(this._initComponent);
        }
        // Model is loaded in WebXRInput
    }
    /**
     * Dispose this controller, the model mesh and all its components
     */
    WebXRAbstractMotionController.prototype.dispose = function () {
        var _this = this;
        this.getComponentIds().forEach(function (id) { return _this.getComponent(id).dispose(); });
        if (this.rootMesh) {
            this.rootMesh.dispose();
        }
    };
    /**
     * Returns all components of specific type
     * @param type the type to search for
     * @return an array of components with this type
     */
    WebXRAbstractMotionController.prototype.getAllComponentsOfType = function (type) {
        var _this = this;
        return this.getComponentIds().map(function (id) { return _this.components[id]; }).filter(function (component) { return component.type === type; });
    };
    /**
     * get a component based an its component id as defined in layout.components
     * @param id the id of the component
     * @returns the component correlates to the id or undefined if not found
     */
    WebXRAbstractMotionController.prototype.getComponent = function (id) {
        return this.components[id];
    };
    /**
     * Get the list of components available in this motion controller
     * @returns an array of strings correlating to available components
     */
    WebXRAbstractMotionController.prototype.getComponentIds = function () {
        return Object.keys(this.components);
    };
    /**
     * Get the first component of specific type
     * @param type type of component to find
     * @return a controller component or null if not found
     */
    WebXRAbstractMotionController.prototype.getComponentOfType = function (type) {
        return this.getAllComponentsOfType(type)[0] || null;
    };
    /**
     * Get the main (Select) component of this controller as defined in the layout
     * @returns the main component of this controller
     */
    WebXRAbstractMotionController.prototype.getMainComponent = function () {
        return this.getComponent(this.layout.selectComponentId);
    };
    /**
     * Loads the model correlating to this controller
     * When the mesh is loaded, the onModelLoadedObservable will be triggered
     * @returns A promise fulfilled with the result of the model loading
     */
    WebXRAbstractMotionController.prototype.loadModel = function () {
        return __awaiter(this, void 0, void 0, function () {
            var useGeneric, loadingParams;
            var _this = this;
            return __generator(this, function (_a) {
                useGeneric = !this._getModelLoadingConstraints();
                loadingParams = this._getGenericFilenameAndPath();
                // Checking if GLB loader is present
                if (useGeneric) {
                    Logger.Warn("Falling back to generic models");
                }
                else {
                    loadingParams = this._getFilenameAndPath();
                }
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        SceneLoader.ImportMesh("", loadingParams.path, loadingParams.filename, _this.scene, function (meshes) {
                            if (useGeneric) {
                                _this._getGenericParentMesh(meshes);
                            }
                            else {
                                _this._setRootMesh(meshes);
                            }
                            _this._processLoadedModel(meshes);
                            _this._modelReady = true;
                            _this.onModelLoadedObservable.notifyObservers(_this);
                            resolve(true);
                        }, null, function (_scene, message) {
                            Logger.Log(message);
                            Logger.Warn("Failed to retrieve controller model of type " + _this.profileId + " from the remote server: " + loadingParams.path + loadingParams.filename);
                            reject(message);
                        });
                    })];
            });
        });
    };
    /**
     * Update this model using the current XRFrame
     * @param xrFrame the current xr frame to use and update the model
     */
    WebXRAbstractMotionController.prototype.updateFromXRFrame = function (xrFrame) {
        var _this = this;
        this.getComponentIds().forEach(function (id) { return _this.getComponent(id).update(_this.gamepadObject); });
        this.updateModel(xrFrame);
    };
    // Look through all children recursively. This will return null if no mesh exists with the given name.
    WebXRAbstractMotionController.prototype._getChildByName = function (node, name) {
        return node.getChildren(function (n) { return n.name === name; }, false)[0];
    };
    // Look through only immediate children. This will return null if no mesh exists with the given name.
    WebXRAbstractMotionController.prototype._getImmediateChildByName = function (node, name) {
        return node.getChildren(function (n) { return n.name == name; }, true)[0];
    };
    /**
     * Moves the axis on the controller mesh based on its current state
     * @param axis the index of the axis
     * @param axisValue the value of the axis which determines the meshes new position
     * @hidden
     */
    WebXRAbstractMotionController.prototype._lerpTransform = function (axisMap, axisValue, fixValueCoordinates) {
        if (!axisMap.minMesh || !axisMap.maxMesh) {
            return;
        }
        if (!axisMap.minMesh.rotationQuaternion || !axisMap.maxMesh.rotationQuaternion || !axisMap.valueMesh.rotationQuaternion) {
            return;
        }
        // Convert from gamepad value range (-1 to +1) to lerp range (0 to 1)
        var lerpValue = fixValueCoordinates ? axisValue * 0.5 + 0.5 : axisValue;
        Quaternion.SlerpToRef(axisMap.minMesh.rotationQuaternion, axisMap.maxMesh.rotationQuaternion, lerpValue, axisMap.valueMesh.rotationQuaternion);
        Vector3.LerpToRef(axisMap.minMesh.position, axisMap.maxMesh.position, lerpValue, axisMap.valueMesh.position);
    };
    /**
     * Update the model itself with the current frame data
     * @param xrFrame the frame to use for updating the model mesh
     */
    WebXRAbstractMotionController.prototype.updateModel = function (xrFrame) {
        if (!this._modelReady) {
            return;
        }
        this._updateModel(xrFrame);
    };
    WebXRAbstractMotionController.prototype._getGenericFilenameAndPath = function () {
        return {
            filename: "generic.babylon",
            path: "https://controllers.babylonjs.com/generic/"
        };
    };
    WebXRAbstractMotionController.prototype._getGenericParentMesh = function (meshes) {
        var _this = this;
        this.rootMesh = new Mesh(this.profileId + " " + this.handness, this.scene);
        meshes.forEach(function (mesh) {
            if (!mesh.parent) {
                mesh.isPickable = false;
                mesh.setParent(_this.rootMesh);
            }
        });
        this.rootMesh.rotationQuaternion = Quaternion.FromEulerAngles(0, Math.PI, 0);
    };
    return WebXRAbstractMotionController;
}());
export { WebXRAbstractMotionController };
//# sourceMappingURL=webXRAbstractMotionController.js.map