import { Observable } from "../Misc/observable";
import { AbstractMesh } from "../Meshes/abstractMesh";
import { Quaternion, Vector3 } from '../Maths/math.vector';
import { WebXRMotionControllerManager } from './motionController/webXRMotionControllerManager';
var idCount = 0;
/**
 * Represents an XR controller
 */
var WebXRInputSource = /** @class */ (function () {
    /**
     * Creates the controller
     * @see https://doc.babylonjs.com/how_to/webxr
     * @param _scene the scene which the controller should be associated to
     * @param inputSource the underlying input source for the controller
     * @param _options options for this controller creation
     */
    function WebXRInputSource(_scene, 
    /** The underlying input source for the controller  */
    inputSource, _options) {
        var _this = this;
        if (_options === void 0) { _options = {}; }
        this._scene = _scene;
        this.inputSource = inputSource;
        this._options = _options;
        this._tmpQuaternion = new Quaternion();
        this._tmpVector = new Vector3();
        /**
         * Event that fires when the controller is removed/disposed.
         * The object provided as event data is this controller, after associated assets were disposed.
         * uniqueId is still available.
         */
        this.onDisposeObservable = new Observable();
        /**
         * Will be triggered when the mesh associated with the motion controller is done loading.
         * It is also possible that this will never trigger (!) if no mesh was loaded, or if the developer decides to load a different mesh
         * A shortened version of controller -> motion controller -> on mesh loaded.
         */
        this.onMeshLoadedObservable = new Observable();
        /**
         * Observers registered here will trigger when a motion controller profile was assigned to this xr controller
         */
        this.onMotionControllerInitObservable = new Observable();
        this._uniqueId = "controller-" + idCount++ + "-" + inputSource.targetRayMode + "-" + inputSource.handedness;
        this.pointer = new AbstractMesh(this._uniqueId + "-pointer", _scene);
        this.pointer.rotationQuaternion = new Quaternion();
        if (this.inputSource.gripSpace) {
            this.grip = new AbstractMesh(this._uniqueId + "-grip", this._scene);
            this.grip.rotationQuaternion = new Quaternion();
        }
        // for now only load motion controllers if gamepad object available
        if (this.inputSource.gamepad) {
            WebXRMotionControllerManager.GetMotionControllerWithXRInput(inputSource, _scene, this._options.forceControllerProfile).then(function (motionController) {
                _this.motionController = motionController;
                _this.onMotionControllerInitObservable.notifyObservers(motionController);
                // should the model be loaded?
                if (!_this._options.doNotLoadControllerMesh) {
                    _this.motionController.loadModel().then(function (success) {
                        if (success) {
                            _this.onMeshLoadedObservable.notifyObservers(_this.motionController.rootMesh);
                            _this.motionController.rootMesh.parent = _this.grip || _this.pointer;
                            _this.motionController.disableAnimation = !!_this._options.disableMotionControllerAnimation;
                        }
                    });
                }
            });
        }
    }
    Object.defineProperty(WebXRInputSource.prototype, "uniqueId", {
        /**
         * Get this controllers unique id
         */
        get: function () {
            return this._uniqueId;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Disposes of the object
     */
    WebXRInputSource.prototype.dispose = function () {
        if (this.grip) {
            this.grip.dispose();
        }
        if (this.motionController) {
            this.motionController.dispose();
        }
        this.pointer.dispose();
        this.onMotionControllerInitObservable.clear();
        this.onMeshLoadedObservable.clear();
        this.onDisposeObservable.notifyObservers(this);
        this.onDisposeObservable.clear();
    };
    /**
     * Gets a world space ray coming from the pointer or grip
     * @param result the resulting ray
     * @param gripIfAvailable use the grip mesh instead of the pointer, if available
     */
    WebXRInputSource.prototype.getWorldPointerRayToRef = function (result, gripIfAvailable) {
        if (gripIfAvailable === void 0) { gripIfAvailable = false; }
        var object = gripIfAvailable && this.grip ? this.grip : this.pointer;
        var worldMatrix = object.computeWorldMatrix();
        worldMatrix.decompose(undefined, this._tmpQuaternion, undefined);
        this._tmpVector.set(0, 0, 1);
        this._tmpVector.rotateByQuaternionToRef(this._tmpQuaternion, this._tmpVector);
        result.origin.copyFrom(object.absolutePosition);
        result.direction.copyFrom(this._tmpVector);
        result.length = 1000;
    };
    /**
     * Updates the controller pose based on the given XRFrame
     * @param xrFrame xr frame to update the pose with
     * @param referenceSpace reference space to use
     */
    WebXRInputSource.prototype.updateFromXRFrame = function (xrFrame, referenceSpace) {
        var pose = xrFrame.getPose(this.inputSource.targetRaySpace, referenceSpace);
        // Update the pointer mesh
        if (pose) {
            this.pointer.position.copyFrom((pose.transform.position));
            this.pointer.rotationQuaternion.copyFrom((pose.transform.orientation));
            if (!this._scene.useRightHandedSystem) {
                this.pointer.position.z *= -1;
                this.pointer.rotationQuaternion.z *= -1;
                this.pointer.rotationQuaternion.w *= -1;
            }
        }
        // Update the grip mesh if it exists
        if (this.inputSource.gripSpace && this.grip) {
            var pose_1 = xrFrame.getPose(this.inputSource.gripSpace, referenceSpace);
            if (pose_1) {
                this.grip.position.copyFrom((pose_1.transform.position));
                this.grip.rotationQuaternion.copyFrom((pose_1.transform.orientation));
                if (!this._scene.useRightHandedSystem) {
                    this.grip.position.z *= -1;
                    this.grip.rotationQuaternion.z *= -1;
                    this.grip.rotationQuaternion.w *= -1;
                }
            }
        }
        if (this.motionController) {
            // either update buttons only or also position, if in gamepad mode
            this.motionController.updateFromXRFrame(xrFrame);
        }
    };
    return WebXRInputSource;
}());
export { WebXRInputSource };
//# sourceMappingURL=webXRInputSource.js.map