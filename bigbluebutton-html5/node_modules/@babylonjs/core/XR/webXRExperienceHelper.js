import { Observable } from "../Misc/observable";
import { WebXRSessionManager } from "./webXRSessionManager";
import { WebXRCamera } from "./webXRCamera";
import { WebXRState } from './webXRTypes';
import { WebXRFeaturesManager } from './webXRFeaturesManager';
import { Logger } from '../Misc/logger';
/**
 * Base set of functionality needed to create an XR experience (WebXRSessionManager, Camera, StateManagement, etc.)
 * @see https://doc.babylonjs.com/how_to/webxr
 */
var WebXRExperienceHelper = /** @class */ (function () {
    /**
     * Creates a WebXRExperienceHelper
     * @param scene The scene the helper should be created in
     */
    function WebXRExperienceHelper(scene) {
        var _this = this;
        this.scene = scene;
        this._nonVRCamera = null;
        this._originalSceneAutoClear = true;
        this._supported = false;
        /**
         * Observers registered here will be triggered after the camera's initial transformation is set
         * This can be used to set a different ground level or an extra rotation.
         *
         * Note that ground level is considered to be at 0. The height defined by the XR camera will be added
         * to the position set after this observable is done executing.
         */
        this.onInitialXRPoseSetObservable = new Observable();
        /**
         * Fires when the state of the experience helper has changed
         */
        this.onStateChangedObservable = new Observable();
        /**
         * The current state of the XR experience (eg. transitioning, in XR or not in XR)
         */
        this.state = WebXRState.NOT_IN_XR;
        this.sessionManager = new WebXRSessionManager(scene);
        this.camera = new WebXRCamera("", scene, this.sessionManager);
        this.featuresManager = new WebXRFeaturesManager(this.sessionManager);
        scene.onDisposeObservable.add(function () {
            _this.exitXRAsync();
        });
    }
    /**
     * Creates the experience helper
     * @param scene the scene to attach the experience helper to
     * @returns a promise for the experience helper
     */
    WebXRExperienceHelper.CreateAsync = function (scene) {
        var helper = new WebXRExperienceHelper(scene);
        return helper.sessionManager.initializeAsync().then(function () {
            helper._supported = true;
            return helper;
        }).catch(function (e) {
            helper._setState(WebXRState.NOT_IN_XR);
            helper.dispose();
            throw e;
        });
    };
    /**
     * Disposes of the experience helper
     */
    WebXRExperienceHelper.prototype.dispose = function () {
        this.camera.dispose();
        this.onStateChangedObservable.clear();
        this.onInitialXRPoseSetObservable.clear();
        this.sessionManager.dispose();
        if (this._nonVRCamera) {
            this.scene.activeCamera = this._nonVRCamera;
        }
    };
    /**
     * Enters XR mode (This must be done within a user interaction in most browsers eg. button click)
     * @param sessionMode options for the XR session
     * @param referenceSpaceType frame of reference of the XR session
     * @param renderTarget the output canvas that will be used to enter XR mode
     * @returns promise that resolves after xr mode has entered
     */
    WebXRExperienceHelper.prototype.enterXRAsync = function (sessionMode, referenceSpaceType, renderTarget) {
        var _this = this;
        if (renderTarget === void 0) { renderTarget = this.sessionManager.getWebXRRenderTarget(); }
        if (!this._supported) {
            throw "WebXR not supported in this browser or environment";
        }
        this._setState(WebXRState.ENTERING_XR);
        var sessionCreationOptions = {
            optionalFeatures: (referenceSpaceType !== "viewer" && referenceSpaceType !== "local") ? [referenceSpaceType] : []
        };
        // we currently recommend "local" space in AR
        if (sessionMode === "immersive-ar" && referenceSpaceType !== "local") {
            Logger.Warn("We recommend using 'local' reference space type when using 'immersive-ar' session mode");
        }
        // make sure that the session mode is supported
        return this.sessionManager.isSessionSupportedAsync(sessionMode).then(function (supported) {
            if (!supported) {
                throw new Error("Session mode \"" + sessionMode + "\" not supported in browser");
            }
            return _this.sessionManager.initializeSessionAsync(sessionMode, sessionCreationOptions);
        }).then(function () {
            return _this.sessionManager.setReferenceSpaceTypeAsync(referenceSpaceType);
        }).then(function () {
            return renderTarget.initializeXRLayerAsync(_this.sessionManager.session);
        }).then(function () {
            return _this.sessionManager.updateRenderStateAsync({ depthFar: _this.camera.maxZ, depthNear: _this.camera.minZ, baseLayer: renderTarget.xrLayer });
        }).then(function () {
            // run the render loop
            _this.sessionManager.runXRRenderLoop();
            // Cache pre xr scene settings
            _this._originalSceneAutoClear = _this.scene.autoClear;
            _this._nonVRCamera = _this.scene.activeCamera;
            // Overwrite current scene settings
            _this.scene.autoClear = false;
            _this.scene.activeCamera = _this.camera;
            // do not compensate when AR session is used
            if (sessionMode !== 'immersive-ar') {
                _this._nonXRToXRCamera();
            }
            else {
                _this.camera.compensateOnFirstFrame = false;
            }
            _this.sessionManager.onXRSessionEnded.addOnce(function () {
                // Reset camera rigs output render target to ensure sessions render target is not drawn after it ends
                _this.camera.rigCameras.forEach(function (c) {
                    c.outputRenderTarget = null;
                });
                // Restore scene settings
                _this.scene.autoClear = _this._originalSceneAutoClear;
                _this.scene.activeCamera = _this._nonVRCamera;
                if (sessionMode !== 'immersive-ar' && _this.camera.compensateOnFirstFrame) {
                    if (_this._nonVRCamera.setPosition) {
                        _this._nonVRCamera.setPosition(_this.camera.position);
                    }
                    else {
                        _this._nonVRCamera.position.copyFrom(_this.camera.position);
                    }
                }
                _this._setState(WebXRState.NOT_IN_XR);
            });
            // Wait until the first frame arrives before setting state to in xr
            _this.sessionManager.onXRFrameObservable.addOnce(function () {
                _this._setState(WebXRState.IN_XR);
            });
            return _this.sessionManager;
        }).catch(function (e) {
            console.log(e);
            console.log(e.message);
            _this._setState(WebXRState.NOT_IN_XR);
            throw (e);
        });
    };
    /**
     * Exits XR mode and returns the scene to its original state
     * @returns promise that resolves after xr mode has exited
     */
    WebXRExperienceHelper.prototype.exitXRAsync = function () {
        this._setState(WebXRState.EXITING_XR);
        return this.sessionManager.exitXRAsync();
    };
    WebXRExperienceHelper.prototype._nonXRToXRCamera = function () {
        this.camera.setTransformationFromNonVRCamera(this._nonVRCamera);
        this.onInitialXRPoseSetObservable.notifyObservers(this.camera);
    };
    WebXRExperienceHelper.prototype._setState = function (val) {
        if (this.state === val) {
            return;
        }
        this.state = val;
        this.onStateChangedObservable.notifyObservers(this.state);
    };
    return WebXRExperienceHelper;
}());
export { WebXRExperienceHelper };
//# sourceMappingURL=webXRExperienceHelper.js.map