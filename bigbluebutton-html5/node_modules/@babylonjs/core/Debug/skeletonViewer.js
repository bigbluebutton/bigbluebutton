import { Vector3, Matrix, TmpVectors } from "../Maths/math.vector";
import { Color3 } from '../Maths/math.color';
import { LinesBuilder } from "../Meshes/Builders/linesBuilder";
import { UtilityLayerRenderer } from "../Rendering/utilityLayerRenderer";
/**
     * Class used to render a debug view of a given skeleton
     * @see http://www.babylonjs-playground.com/#1BZJVJ#8
     */
var SkeletonViewer = /** @class */ (function () {
    /**
     * Creates a new SkeletonViewer
     * @param skeleton defines the skeleton to render
     * @param mesh defines the mesh attached to the skeleton
     * @param scene defines the hosting scene
     * @param autoUpdateBonesMatrices defines a boolean indicating if bones matrices must be forced to update before rendering (true by default)
     * @param renderingGroupId defines the rendering group id to use with the viewer
     */
    function SkeletonViewer(
    /** defines the skeleton to render */
    skeleton, 
    /** defines the mesh attached to the skeleton */
    mesh, scene, 
    /** defines a boolean indicating if bones matrices must be forced to update before rendering (true by default)  */
    autoUpdateBonesMatrices, 
    /** defines the rendering group id to use with the viewer */
    renderingGroupId) {
        if (autoUpdateBonesMatrices === void 0) { autoUpdateBonesMatrices = true; }
        if (renderingGroupId === void 0) { renderingGroupId = 1; }
        this.skeleton = skeleton;
        this.mesh = mesh;
        this.autoUpdateBonesMatrices = autoUpdateBonesMatrices;
        this.renderingGroupId = renderingGroupId;
        /** Gets or sets the color used to render the skeleton */
        this.color = Color3.White();
        this._debugLines = new Array();
        this._isEnabled = false;
        this._scene = scene;
        this._utilityLayer = new UtilityLayerRenderer(this._scene, false);
        this._utilityLayer.pickUtilitySceneFirst = false;
        this._utilityLayer.utilityLayerScene.autoClearDepthAndStencil = true;
        this.update();
        this._renderFunction = this.update.bind(this);
    }
    Object.defineProperty(SkeletonViewer.prototype, "debugMesh", {
        /**
         * Returns the mesh used to render the bones
         */
        get: function () {
            return this._debugMesh;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SkeletonViewer.prototype, "isEnabled", {
        get: function () {
            return this._isEnabled;
        },
        /** Gets or sets a boolean indicating if the viewer is enabled */
        set: function (value) {
            if (this._isEnabled === value) {
                return;
            }
            this._isEnabled = value;
            if (value) {
                this._scene.registerBeforeRender(this._renderFunction);
            }
            else {
                this._scene.unregisterBeforeRender(this._renderFunction);
            }
        },
        enumerable: true,
        configurable: true
    });
    SkeletonViewer.prototype._getBonePosition = function (position, bone, meshMat, x, y, z) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        if (z === void 0) { z = 0; }
        var tmat = TmpVectors.Matrix[0];
        var parentBone = bone.getParent();
        tmat.copyFrom(bone.getLocalMatrix());
        if (x !== 0 || y !== 0 || z !== 0) {
            var tmat2 = TmpVectors.Matrix[1];
            Matrix.IdentityToRef(tmat2);
            tmat2.setTranslationFromFloats(x, y, z);
            tmat2.multiplyToRef(tmat, tmat);
        }
        if (parentBone) {
            tmat.multiplyToRef(parentBone.getAbsoluteTransform(), tmat);
        }
        tmat.multiplyToRef(meshMat, tmat);
        position.x = tmat.m[12];
        position.y = tmat.m[13];
        position.z = tmat.m[14];
    };
    SkeletonViewer.prototype._getLinesForBonesWithLength = function (bones, meshMat) {
        var len = bones.length;
        var mesh = this.mesh._effectiveMesh;
        var meshPos = mesh.position;
        for (var i = 0; i < len; i++) {
            var bone = bones[i];
            var points = this._debugLines[i];
            if (!points) {
                points = [Vector3.Zero(), Vector3.Zero()];
                this._debugLines[i] = points;
            }
            this._getBonePosition(points[0], bone, meshMat);
            this._getBonePosition(points[1], bone, meshMat, 0, bone.length, 0);
            points[0].subtractInPlace(meshPos);
            points[1].subtractInPlace(meshPos);
        }
    };
    SkeletonViewer.prototype._getLinesForBonesNoLength = function (bones, meshMat) {
        var len = bones.length;
        var boneNum = 0;
        var mesh = this.mesh._effectiveMesh;
        var meshPos = mesh.position;
        for (var i = len - 1; i >= 0; i--) {
            var childBone = bones[i];
            var parentBone = childBone.getParent();
            if (!parentBone) {
                continue;
            }
            var points = this._debugLines[boneNum];
            if (!points) {
                points = [Vector3.Zero(), Vector3.Zero()];
                this._debugLines[boneNum] = points;
            }
            childBone.getAbsolutePositionToRef(mesh, points[0]);
            parentBone.getAbsolutePositionToRef(mesh, points[1]);
            points[0].subtractInPlace(meshPos);
            points[1].subtractInPlace(meshPos);
            boneNum++;
        }
    };
    /** Update the viewer to sync with current skeleton state */
    SkeletonViewer.prototype.update = function () {
        if (!this._utilityLayer) {
            return;
        }
        if (this.autoUpdateBonesMatrices) {
            this.skeleton.computeAbsoluteTransforms();
        }
        var mesh = this.mesh._effectiveMesh;
        if (this.skeleton.bones[0].length === undefined) {
            this._getLinesForBonesNoLength(this.skeleton.bones, mesh.getWorldMatrix());
        }
        else {
            this._getLinesForBonesWithLength(this.skeleton.bones, mesh.getWorldMatrix());
        }
        var targetScene = this._utilityLayer.utilityLayerScene;
        if (!this._debugMesh) {
            this._debugMesh = LinesBuilder.CreateLineSystem("", { lines: this._debugLines, updatable: true, instance: null }, targetScene);
            this._debugMesh.renderingGroupId = this.renderingGroupId;
        }
        else {
            LinesBuilder.CreateLineSystem("", { lines: this._debugLines, updatable: true, instance: this._debugMesh }, targetScene);
        }
        this._debugMesh.position.copyFrom(this.mesh.position);
        this._debugMesh.color = this.color;
    };
    /** Release associated resources */
    SkeletonViewer.prototype.dispose = function () {
        this.isEnabled = false;
        if (this._debugMesh) {
            this.isEnabled = false;
            this._debugMesh.dispose();
            this._debugMesh = null;
        }
        if (this._utilityLayer) {
            this._utilityLayer.dispose();
            this._utilityLayer = null;
        }
    };
    return SkeletonViewer;
}());
export { SkeletonViewer };
//# sourceMappingURL=skeletonViewer.js.map