{"version":3,"file":"light.js","sourceRoot":"","sources":["../../../sourceES6/core/Lights/light.ts"],"names":[],"mappings":"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","sourcesContent":["import { serialize, SerializationHelper, serializeAsColor3, expandToProperty } from \"../Misc/decorators\";\r\nimport { Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Color3, TmpColors } from \"../Maths/math.color\";\r\nimport { Node } from \"../node\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Effect } from \"../Materials/effect\";\r\nimport { UniformBuffer } from \"../Materials/uniformBuffer\";\r\nimport { IShadowGenerator } from \"./Shadows/shadowGenerator\";\r\nimport { _TypeStore } from '../Misc/typeStore';\r\n\r\n/**\r\n * Base class of all the lights in Babylon. It groups all the generic information about lights.\r\n * Lights are used, as you would expect, to affect how meshes are seen, in terms of both illumination and colour.\r\n * All meshes allow light to pass through them unless shadow generation is activated. The default number of lights allowed is four but this can be increased.\r\n */\r\nexport abstract class Light extends Node {\r\n\r\n    /**\r\n     * Falloff Default: light is falling off following the material specification:\r\n     * standard material is using standard falloff whereas pbr material can request special falloff per materials.\r\n     */\r\n    public static readonly FALLOFF_DEFAULT = 0;\r\n\r\n    /**\r\n     * Falloff Physical: light is falling off following the inverse squared distance law.\r\n     */\r\n    public static readonly FALLOFF_PHYSICAL = 1;\r\n\r\n    /**\r\n     * Falloff gltf: light is falling off as described in the gltf moving to PBR document\r\n     * to enhance interoperability with other engines.\r\n     */\r\n    public static readonly FALLOFF_GLTF = 2;\r\n\r\n    /**\r\n     * Falloff Standard: light is falling off like in the standard material\r\n     * to enhance interoperability with other materials.\r\n     */\r\n    public static readonly FALLOFF_STANDARD = 3;\r\n\r\n    //lightmapMode Consts\r\n    /**\r\n     * If every light affecting the material is in this lightmapMode,\r\n     * material.lightmapTexture adds or multiplies\r\n     * (depends on material.useLightmapAsShadowmap)\r\n     * after every other light calculations.\r\n     */\r\n    public static readonly LIGHTMAP_DEFAULT = 0;\r\n    /**\r\n     * material.lightmapTexture as only diffuse lighting from this light\r\n     * adds only specular lighting from this light\r\n     * adds dynamic shadows\r\n     */\r\n    public static readonly LIGHTMAP_SPECULAR = 1;\r\n    /**\r\n     * material.lightmapTexture as only lighting\r\n     * no light calculation from this light\r\n     * only adds dynamic shadows from this light\r\n     */\r\n    public static readonly LIGHTMAP_SHADOWSONLY = 2;\r\n\r\n    // Intensity Mode Consts\r\n    /**\r\n     * Each light type uses the default quantity according to its type:\r\n     *      point/spot lights use luminous intensity\r\n     *      directional lights use illuminance\r\n     */\r\n    public static readonly INTENSITYMODE_AUTOMATIC = 0;\r\n    /**\r\n     * lumen (lm)\r\n     */\r\n    public static readonly INTENSITYMODE_LUMINOUSPOWER = 1;\r\n    /**\r\n     * candela (lm/sr)\r\n     */\r\n    public static readonly INTENSITYMODE_LUMINOUSINTENSITY = 2;\r\n    /**\r\n     * lux (lm/m^2)\r\n     */\r\n    public static readonly INTENSITYMODE_ILLUMINANCE = 3;\r\n    /**\r\n     * nit (cd/m^2)\r\n     */\r\n    public static readonly INTENSITYMODE_LUMINANCE = 4;\r\n\r\n    // Light types ids const.\r\n    /**\r\n     * Light type const id of the point light.\r\n     */\r\n    public static readonly LIGHTTYPEID_POINTLIGHT = 0;\r\n    /**\r\n     * Light type const id of the directional light.\r\n     */\r\n    public static readonly LIGHTTYPEID_DIRECTIONALLIGHT = 1;\r\n    /**\r\n     * Light type const id of the spot light.\r\n     */\r\n    public static readonly LIGHTTYPEID_SPOTLIGHT = 2;\r\n    /**\r\n     * Light type const id of the hemispheric light.\r\n     */\r\n    public static readonly LIGHTTYPEID_HEMISPHERICLIGHT = 3;\r\n\r\n    /**\r\n     * Diffuse gives the basic color to an object.\r\n     */\r\n    @serializeAsColor3()\r\n    public diffuse = new Color3(1.0, 1.0, 1.0);\r\n\r\n    /**\r\n     * Specular produces a highlight color on an object.\r\n     * Note: This is note affecting PBR materials.\r\n     */\r\n    @serializeAsColor3()\r\n    public specular = new Color3(1.0, 1.0, 1.0);\r\n\r\n    /**\r\n     * Defines the falloff type for this light. This lets overrriding how punctual light are\r\n     * falling off base on range or angle.\r\n     * This can be set to any values in Light.FALLOFF_x.\r\n     *\r\n     * Note: This is only useful for PBR Materials at the moment. This could be extended if required to\r\n     * other types of materials.\r\n     */\r\n    @serialize()\r\n    public falloffType = Light.FALLOFF_DEFAULT;\r\n\r\n    /**\r\n     * Strength of the light.\r\n     * Note: By default it is define in the framework own unit.\r\n     * Note: In PBR materials the intensityMode can be use to chose what unit the intensity is defined in.\r\n     */\r\n    @serialize()\r\n    public intensity = 1.0;\r\n\r\n    private _range = Number.MAX_VALUE;\r\n    protected _inverseSquaredRange = 0;\r\n\r\n    /**\r\n     * Defines how far from the source the light is impacting in scene units.\r\n     * Note: Unused in PBR material as the distance light falloff is defined following the inverse squared falloff.\r\n     */\r\n    @serialize()\r\n    public get range(): number {\r\n        return this._range;\r\n    }\r\n    /**\r\n     * Defines how far from the source the light is impacting in scene units.\r\n     * Note: Unused in PBR material as the distance light falloff is defined following the inverse squared falloff.\r\n     */\r\n    public set range(value: number) {\r\n        this._range = value;\r\n        this._inverseSquaredRange = 1.0 / (this.range * this.range);\r\n    }\r\n\r\n    /**\r\n     * Cached photometric scale default to 1.0 as the automatic intensity mode defaults to 1.0 for every type\r\n     * of light.\r\n     */\r\n    private _photometricScale = 1.0;\r\n\r\n    private _intensityMode: number = Light.INTENSITYMODE_AUTOMATIC;\r\n    /**\r\n     * Gets the photometric scale used to interpret the intensity.\r\n     * This is only relevant with PBR Materials where the light intensity can be defined in a physical way.\r\n     */\r\n    @serialize()\r\n    public get intensityMode(): number {\r\n        return this._intensityMode;\r\n    }\r\n    /**\r\n     * Sets the photometric scale used to interpret the intensity.\r\n     * This is only relevant with PBR Materials where the light intensity can be defined in a physical way.\r\n     */\r\n    public set intensityMode(value: number) {\r\n        this._intensityMode = value;\r\n        this._computePhotometricScale();\r\n    }\r\n\r\n    private _radius = 0.00001;\r\n    /**\r\n     * Gets the light radius used by PBR Materials to simulate soft area lights.\r\n     */\r\n    @serialize()\r\n    public get radius(): number {\r\n        return this._radius;\r\n    }\r\n    /**\r\n     * sets the light radius used by PBR Materials to simulate soft area lights.\r\n     */\r\n    public set radius(value: number) {\r\n        this._radius = value;\r\n        this._computePhotometricScale();\r\n    }\r\n\r\n    @serialize()\r\n    private _renderPriority: number;\r\n    /**\r\n     * Defines the rendering priority of the lights. It can help in case of fallback or number of lights\r\n     * exceeding the number allowed of the materials.\r\n     */\r\n    @expandToProperty(\"_reorderLightsInScene\")\r\n    public renderPriority: number = 0;\r\n\r\n    @serialize(\"shadowEnabled\")\r\n    private _shadowEnabled: boolean = true;\r\n    /**\r\n     * Gets wether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching\r\n     * the current shadow generator.\r\n     */\r\n    public get shadowEnabled(): boolean {\r\n        return this._shadowEnabled;\r\n    }\r\n    /**\r\n     * Sets wether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching\r\n     * the current shadow generator.\r\n     */\r\n    public set shadowEnabled(value: boolean) {\r\n        if (this._shadowEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._shadowEnabled = value;\r\n        this._markMeshesAsLightDirty();\r\n    }\r\n\r\n    private _includedOnlyMeshes: AbstractMesh[];\r\n    /**\r\n     * Gets the only meshes impacted by this light.\r\n     */\r\n    public get includedOnlyMeshes(): AbstractMesh[] {\r\n        return this._includedOnlyMeshes;\r\n    }\r\n    /**\r\n     * Sets the only meshes impacted by this light.\r\n     */\r\n    public set includedOnlyMeshes(value: AbstractMesh[]) {\r\n        this._includedOnlyMeshes = value;\r\n        this._hookArrayForIncludedOnly(value);\r\n    }\r\n\r\n    private _excludedMeshes: AbstractMesh[];\r\n    /**\r\n     * Gets the meshes not impacted by this light.\r\n     */\r\n    public get excludedMeshes(): AbstractMesh[] {\r\n        return this._excludedMeshes;\r\n    }\r\n    /**\r\n     * Sets the meshes not impacted by this light.\r\n     */\r\n    public set excludedMeshes(value: AbstractMesh[]) {\r\n        this._excludedMeshes = value;\r\n        this._hookArrayForExcluded(value);\r\n    }\r\n\r\n    @serialize(\"excludeWithLayerMask\")\r\n    private _excludeWithLayerMask = 0;\r\n    /**\r\n     * Gets the layer id use to find what meshes are not impacted by the light.\r\n     * Inactive if 0\r\n     */\r\n    public get excludeWithLayerMask(): number {\r\n        return this._excludeWithLayerMask;\r\n    }\r\n    /**\r\n     * Sets the layer id use to find what meshes are not impacted by the light.\r\n     * Inactive if 0\r\n     */\r\n    public set excludeWithLayerMask(value: number) {\r\n        this._excludeWithLayerMask = value;\r\n        this._resyncMeshes();\r\n    }\r\n\r\n    @serialize(\"includeOnlyWithLayerMask\")\r\n    private _includeOnlyWithLayerMask = 0;\r\n    /**\r\n     * Gets the layer id use to find what meshes are impacted by the light.\r\n     * Inactive if 0\r\n     */\r\n    public get includeOnlyWithLayerMask(): number {\r\n        return this._includeOnlyWithLayerMask;\r\n    }\r\n    /**\r\n     * Sets the layer id use to find what meshes are impacted by the light.\r\n     * Inactive if 0\r\n     */\r\n    public set includeOnlyWithLayerMask(value: number) {\r\n        this._includeOnlyWithLayerMask = value;\r\n        this._resyncMeshes();\r\n    }\r\n\r\n    @serialize(\"lightmapMode\")\r\n    private _lightmapMode = 0;\r\n    /**\r\n     * Gets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)\r\n     */\r\n    public get lightmapMode(): number {\r\n        return this._lightmapMode;\r\n    }\r\n    /**\r\n     * Sets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)\r\n     */\r\n    public set lightmapMode(value: number) {\r\n        if (this._lightmapMode === value) {\r\n            return;\r\n        }\r\n\r\n        this._lightmapMode = value;\r\n        this._markMeshesAsLightDirty();\r\n    }\r\n\r\n    /**\r\n     * Shadow generator associted to the light.\r\n     * @hidden Internal use only.\r\n     */\r\n    public _shadowGenerator: Nullable<IShadowGenerator>;\r\n\r\n    /**\r\n     * @hidden Internal use only.\r\n     */\r\n    public _excludedMeshesIds = new Array<string>();\r\n\r\n    /**\r\n     * @hidden Internal use only.\r\n     */\r\n    public _includedOnlyMeshesIds = new Array<string>();\r\n\r\n    /**\r\n     * The current light unifom buffer.\r\n     * @hidden Internal use only.\r\n     */\r\n    public _uniformBuffer: UniformBuffer;\r\n\r\n    /** @hidden */\r\n    public _renderId: number;\r\n    /**\r\n     * Creates a Light object in the scene.\r\n     * Documentation : https://doc.babylonjs.com/babylon101/lights\r\n     * @param name The firendly name of the light\r\n     * @param scene The scene the light belongs too\r\n     */\r\n    constructor(name: string, scene: Scene) {\r\n        super(name, scene);\r\n        this.getScene().addLight(this);\r\n        this._uniformBuffer = new UniformBuffer(this.getScene().getEngine());\r\n        this._buildUniformLayout();\r\n\r\n        this.includedOnlyMeshes = new Array<AbstractMesh>();\r\n        this.excludedMeshes = new Array<AbstractMesh>();\r\n\r\n        this._resyncMeshes();\r\n    }\r\n\r\n    protected abstract _buildUniformLayout(): void;\r\n\r\n    /**\r\n     * Sets the passed Effect \"effect\" with the Light information.\r\n     * @param effect The effect to update\r\n     * @param lightIndex The index of the light in the effect to update\r\n     * @returns The light\r\n     */\r\n    public abstract transferToEffect(effect: Effect, lightIndex: string): Light;\r\n\r\n    /**\r\n     * Sets the passed Effect \"effect\" with the Light textures.\r\n     * @param effect The effect to update\r\n     * @param lightIndex The index of the light in the effect to update\r\n     * @returns The light\r\n     */\r\n    public transferTexturesToEffect(effect: Effect, lightIndex: string): Light {\r\n        // Do nothing by default.\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Binds the lights information from the scene to the effect for the given mesh.\r\n     * @param lightIndex Light index\r\n     * @param scene The scene where the light belongs to\r\n     * @param effect The effect we are binding the data to\r\n     * @param useSpecular Defines if specular is supported\r\n     * @param rebuildInParallel Specifies whether the shader is rebuilding in parallel\r\n     */\r\n    public _bindLight(lightIndex: number, scene: Scene, effect: Effect, useSpecular: boolean, rebuildInParallel = false): void {\r\n        let iAsString = lightIndex.toString();\r\n        let needUpdate = false;\r\n\r\n        if (rebuildInParallel && this._uniformBuffer._alreadyBound) {\r\n            return;\r\n        }\r\n\r\n        this._uniformBuffer.bindToEffect(effect, \"Light\" + iAsString);\r\n\r\n        if (this._renderId !== scene.getRenderId() || !this._uniformBuffer.useUbo) {\r\n            this._renderId = scene.getRenderId();\r\n\r\n            let scaledIntensity = this.getScaledIntensity();\r\n\r\n            this.transferToEffect(effect, iAsString);\r\n\r\n            this.diffuse.scaleToRef(scaledIntensity, TmpColors.Color3[0]);\r\n            this._uniformBuffer.updateColor4(\"vLightDiffuse\", TmpColors.Color3[0], this.range, iAsString);\r\n            if (useSpecular) {\r\n                this.specular.scaleToRef(scaledIntensity, TmpColors.Color3[1]);\r\n                this._uniformBuffer.updateColor4(\"vLightSpecular\", TmpColors.Color3[1], this.radius, iAsString);\r\n            }\r\n            needUpdate = true;\r\n        }\r\n\r\n        // Textures might still need to be rebound.\r\n        this.transferTexturesToEffect(effect, iAsString);\r\n\r\n        // Shadows\r\n        if (scene.shadowsEnabled && this.shadowEnabled) {\r\n            var shadowGenerator = this.getShadowGenerator();\r\n            if (shadowGenerator) {\r\n                shadowGenerator.bindShadowLight(iAsString, effect);\r\n                needUpdate = true;\r\n            }\r\n        }\r\n\r\n        if (needUpdate) {\r\n            this._uniformBuffer.update();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the passed Effect \"effect\" with the Light information.\r\n     * @param effect The effect to update\r\n     * @param lightDataUniformName The uniform used to store light data (position or direction)\r\n     * @returns The light\r\n     */\r\n    public abstract transferToNodeMaterialEffect(effect: Effect, lightDataUniformName: string): Light;\r\n\r\n    /**\r\n     * Returns the string \"Light\".\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"Light\";\r\n    }\r\n\r\n    /** @hidden */\r\n    public readonly _isLight = true;\r\n\r\n    /**\r\n     * Converts the light information to a readable string for debug purpose.\r\n     * @param fullDetails Supports for multiple levels of logging within scene loading\r\n     * @returns the human readable light info\r\n     */\r\n    public toString(fullDetails?: boolean): string {\r\n        var ret = \"Name: \" + this.name;\r\n        ret += \", type: \" + ([\"Point\", \"Directional\", \"Spot\", \"Hemispheric\"])[this.getTypeID()];\r\n        if (this.animations) {\r\n            for (var i = 0; i < this.animations.length; i++) {\r\n                ret += \", animation[0]: \" + this.animations[i].toString(fullDetails);\r\n            }\r\n        }\r\n        if (fullDetails) {\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /** @hidden */\r\n    protected _syncParentEnabledState() {\r\n        super._syncParentEnabledState();\r\n        if (!this.isDisposed()) {\r\n            this._resyncMeshes();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the enabled state of this node.\r\n     * @param value - the new enabled state\r\n     */\r\n    public setEnabled(value: boolean): void {\r\n        super.setEnabled(value);\r\n\r\n        this._resyncMeshes();\r\n    }\r\n\r\n    /**\r\n     * Returns the Light associated shadow generator if any.\r\n     * @return the associated shadow generator.\r\n     */\r\n    public getShadowGenerator(): Nullable<IShadowGenerator> {\r\n        return this._shadowGenerator;\r\n    }\r\n\r\n    /**\r\n     * Returns a Vector3, the absolute light position in the World.\r\n     * @returns the world space position of the light\r\n     */\r\n    public getAbsolutePosition(): Vector3 {\r\n        return Vector3.Zero();\r\n    }\r\n\r\n    /**\r\n     * Specifies if the light will affect the passed mesh.\r\n     * @param mesh The mesh to test against the light\r\n     * @return true the mesh is affected otherwise, false.\r\n     */\r\n    public canAffectMesh(mesh: AbstractMesh): boolean {\r\n        if (!mesh) {\r\n            return true;\r\n        }\r\n\r\n        if (this.includedOnlyMeshes && this.includedOnlyMeshes.length > 0 && this.includedOnlyMeshes.indexOf(mesh) === -1) {\r\n            return false;\r\n        }\r\n\r\n        if (this.excludedMeshes && this.excludedMeshes.length > 0 && this.excludedMeshes.indexOf(mesh) !== -1) {\r\n            return false;\r\n        }\r\n\r\n        if (this.includeOnlyWithLayerMask !== 0 && (this.includeOnlyWithLayerMask & mesh.layerMask) === 0) {\r\n            return false;\r\n        }\r\n\r\n        if (this.excludeWithLayerMask !== 0 && this.excludeWithLayerMask & mesh.layerMask) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Sort function to order lights for rendering.\r\n     * @param a First Light object to compare to second.\r\n     * @param b Second Light object to compare first.\r\n     * @return -1 to reduce's a's index relative to be, 0 for no change, 1 to increase a's index relative to b.\r\n     */\r\n    public static CompareLightsPriority(a: Light, b: Light): number {\r\n        //shadow-casting lights have priority over non-shadow-casting lights\r\n        //the renderPrioirty is a secondary sort criterion\r\n        if (a.shadowEnabled !== b.shadowEnabled) {\r\n            return (b.shadowEnabled ? 1 : 0) - (a.shadowEnabled ? 1 : 0);\r\n        }\r\n        return b.renderPriority - a.renderPriority;\r\n    }\r\n\r\n    /**\r\n     * Releases resources associated with this node.\r\n     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\r\n     * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\r\n     */\r\n    public dispose(doNotRecurse?: boolean, disposeMaterialAndTextures = false): void {\r\n        if (this._shadowGenerator) {\r\n            this._shadowGenerator.dispose();\r\n            this._shadowGenerator = null;\r\n        }\r\n\r\n        // Animations\r\n        this.getScene().stopAnimation(this);\r\n\r\n        // Remove from meshes\r\n        for (var mesh of this.getScene().meshes) {\r\n            mesh._removeLightSource(this, true);\r\n        }\r\n\r\n        this._uniformBuffer.dispose();\r\n\r\n        // Remove from scene\r\n        this.getScene().removeLight(this);\r\n        super.dispose(doNotRecurse, disposeMaterialAndTextures);\r\n    }\r\n\r\n    /**\r\n     * Returns the light type ID (integer).\r\n     * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x\r\n     */\r\n    public getTypeID(): number {\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Returns the intensity scaled by the Photometric Scale according to the light type and intensity mode.\r\n     * @returns the scaled intensity in intensity mode unit\r\n     */\r\n    public getScaledIntensity() {\r\n        return this._photometricScale * this.intensity;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Light object, named \"name\", from the current one.\r\n     * @param name The name of the cloned light\r\n     * @returns the new created light\r\n     */\r\n    public clone(name: string): Nullable<Light> {\r\n        let constructor = Light.GetConstructorFromName(this.getTypeID(), name, this.getScene());\r\n\r\n        if (!constructor) {\r\n            return null;\r\n        }\r\n        return SerializationHelper.Clone(constructor, this);\r\n    }\r\n\r\n    /**\r\n     * Serializes the current light into a Serialization object.\r\n     * @returns the serialized object.\r\n     */\r\n    public serialize(): any {\r\n        var serializationObject = SerializationHelper.Serialize(this);\r\n\r\n        // Type\r\n        serializationObject.type = this.getTypeID();\r\n\r\n        // Parent\r\n        if (this.parent) {\r\n            serializationObject.parentId = this.parent.id;\r\n        }\r\n\r\n        // Inclusion / exclusions\r\n        if (this.excludedMeshes.length > 0) {\r\n            serializationObject.excludedMeshesIds = [];\r\n            this.excludedMeshes.forEach((mesh: AbstractMesh) => {\r\n                serializationObject.excludedMeshesIds.push(mesh.id);\r\n            });\r\n        }\r\n\r\n        if (this.includedOnlyMeshes.length > 0) {\r\n            serializationObject.includedOnlyMeshesIds = [];\r\n            this.includedOnlyMeshes.forEach((mesh: AbstractMesh) => {\r\n                serializationObject.includedOnlyMeshesIds.push(mesh.id);\r\n            });\r\n        }\r\n\r\n        // Animations\r\n        SerializationHelper.AppendSerializedAnimations(this, serializationObject);\r\n        serializationObject.ranges = this.serializeAnimationRanges();\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a new typed light from the passed type (integer) : point light = 0, directional light = 1, spot light = 2, hemispheric light = 3.\r\n     * This new light is named \"name\" and added to the passed scene.\r\n     * @param type Type according to the types available in Light.LIGHTTYPEID_x\r\n     * @param name The friendly name of the light\r\n     * @param scene The scene the new light will belong to\r\n     * @returns the constructor function\r\n     */\r\n    static GetConstructorFromName(type: number, name: string, scene: Scene): Nullable<() => Light> {\r\n        let constructorFunc = Node.Construct(\"Light_Type_\" + type, name, scene);\r\n\r\n        if (constructorFunc) {\r\n            return <() => Light>constructorFunc;\r\n        }\r\n\r\n        // Default to no light for none present once.\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Parses the passed \"parsedLight\" and returns a new instanced Light from this parsing.\r\n     * @param parsedLight The JSON representation of the light\r\n     * @param scene The scene to create the parsed light in\r\n     * @returns the created light after parsing\r\n     */\r\n    public static Parse(parsedLight: any, scene: Scene): Nullable<Light> {\r\n        let constructor = Light.GetConstructorFromName(parsedLight.type, parsedLight.name, scene);\r\n\r\n        if (!constructor) {\r\n            return null;\r\n        }\r\n\r\n        var light = SerializationHelper.Parse(constructor, parsedLight, scene);\r\n\r\n        // Inclusion / exclusions\r\n        if (parsedLight.excludedMeshesIds) {\r\n            light._excludedMeshesIds = parsedLight.excludedMeshesIds;\r\n        }\r\n\r\n        if (parsedLight.includedOnlyMeshesIds) {\r\n            light._includedOnlyMeshesIds = parsedLight.includedOnlyMeshesIds;\r\n        }\r\n\r\n        // Parent\r\n        if (parsedLight.parentId) {\r\n            light._waitingParentId = parsedLight.parentId;\r\n        }\r\n\r\n        // Falloff\r\n        if (parsedLight.falloffType !== undefined) {\r\n            light.falloffType = parsedLight.falloffType;\r\n        }\r\n\r\n        // Lightmaps\r\n        if (parsedLight.lightmapMode !== undefined) {\r\n            light.lightmapMode = parsedLight.lightmapMode;\r\n        }\r\n\r\n        // Animations\r\n        if (parsedLight.animations) {\r\n            for (var animationIndex = 0; animationIndex < parsedLight.animations.length; animationIndex++) {\r\n                var parsedAnimation = parsedLight.animations[animationIndex];\r\n                const internalClass = _TypeStore.GetClass(\"BABYLON.Animation\");\r\n                if (internalClass) {\r\n                    light.animations.push(internalClass.Parse(parsedAnimation));\r\n                }\r\n            }\r\n            Node.ParseAnimationRanges(light, parsedLight, scene);\r\n        }\r\n\r\n        if (parsedLight.autoAnimate) {\r\n            scene.beginAnimation(light, parsedLight.autoAnimateFrom, parsedLight.autoAnimateTo, parsedLight.autoAnimateLoop, parsedLight.autoAnimateSpeed || 1.0);\r\n        }\r\n\r\n        return light;\r\n    }\r\n\r\n    private _hookArrayForExcluded(array: AbstractMesh[]): void {\r\n        var oldPush = array.push;\r\n        array.push = (...items: AbstractMesh[]) => {\r\n            var result = oldPush.apply(array, items);\r\n\r\n            for (var item of items) {\r\n                item._resyncLightSource(this);\r\n            }\r\n\r\n            return result;\r\n        };\r\n\r\n        var oldSplice = array.splice;\r\n        array.splice = (index: number, deleteCount?: number) => {\r\n            var deleted = oldSplice.apply(array, [index, deleteCount]);\r\n\r\n            for (var item of deleted) {\r\n                item._resyncLightSource(this);\r\n            }\r\n\r\n            return deleted;\r\n        };\r\n\r\n        for (var item of array) {\r\n            item._resyncLightSource(this);\r\n        }\r\n    }\r\n\r\n    private _hookArrayForIncludedOnly(array: AbstractMesh[]): void {\r\n        var oldPush = array.push;\r\n        array.push = (...items: AbstractMesh[]) => {\r\n            var result = oldPush.apply(array, items);\r\n\r\n            this._resyncMeshes();\r\n\r\n            return result;\r\n        };\r\n\r\n        var oldSplice = array.splice;\r\n        array.splice = (index: number, deleteCount?: number) => {\r\n            var deleted = oldSplice.apply(array, [index, deleteCount]);\r\n\r\n            this._resyncMeshes();\r\n\r\n            return deleted;\r\n        };\r\n\r\n        this._resyncMeshes();\r\n    }\r\n\r\n    private _resyncMeshes() {\r\n        for (var mesh of this.getScene().meshes) {\r\n            mesh._resyncLightSource(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Forces the meshes to update their light related information in their rendering used effects\r\n     * @hidden Internal Use Only\r\n     */\r\n    public _markMeshesAsLightDirty() {\r\n        for (var mesh of this.getScene().meshes) {\r\n            if (mesh.lightSources.indexOf(this) !== -1) {\r\n                mesh._markSubMeshesAsLightDirty();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Recomputes the cached photometric scale if needed.\r\n     */\r\n    private _computePhotometricScale(): void {\r\n        this._photometricScale = this._getPhotometricScale();\r\n        this.getScene().resetCachedMaterial();\r\n    }\r\n\r\n    /**\r\n     * Returns the Photometric Scale according to the light type and intensity mode.\r\n     */\r\n    private _getPhotometricScale() {\r\n        let photometricScale = 0.0;\r\n        let lightTypeID = this.getTypeID();\r\n\r\n        //get photometric mode\r\n        let photometricMode = this.intensityMode;\r\n        if (photometricMode === Light.INTENSITYMODE_AUTOMATIC) {\r\n            if (lightTypeID === Light.LIGHTTYPEID_DIRECTIONALLIGHT) {\r\n                photometricMode = Light.INTENSITYMODE_ILLUMINANCE;\r\n            } else {\r\n                photometricMode = Light.INTENSITYMODE_LUMINOUSINTENSITY;\r\n            }\r\n        }\r\n\r\n        //compute photometric scale\r\n        switch (lightTypeID) {\r\n            case Light.LIGHTTYPEID_POINTLIGHT:\r\n            case Light.LIGHTTYPEID_SPOTLIGHT:\r\n                switch (photometricMode) {\r\n                    case Light.INTENSITYMODE_LUMINOUSPOWER:\r\n                        photometricScale = 1.0 / (4.0 * Math.PI);\r\n                        break;\r\n                    case Light.INTENSITYMODE_LUMINOUSINTENSITY:\r\n                        photometricScale = 1.0;\r\n                        break;\r\n                    case Light.INTENSITYMODE_LUMINANCE:\r\n                        photometricScale = this.radius * this.radius;\r\n                        break;\r\n                }\r\n                break;\r\n\r\n            case Light.LIGHTTYPEID_DIRECTIONALLIGHT:\r\n                switch (photometricMode) {\r\n                    case Light.INTENSITYMODE_ILLUMINANCE:\r\n                        photometricScale = 1.0;\r\n                        break;\r\n                    case Light.INTENSITYMODE_LUMINANCE:\r\n                        // When radius (and therefore solid angle) is non-zero a directional lights brightness can be specified via central (peak) luminance.\r\n                        // For a directional light the 'radius' defines the angular radius (in radians) rather than world-space radius (e.g. in metres).\r\n                        let apexAngleRadians = this.radius;\r\n                        // Impose a minimum light angular size to avoid the light becoming an infinitely small angular light source (i.e. a dirac delta function).\r\n                        apexAngleRadians = Math.max(apexAngleRadians, 0.001);\r\n                        let solidAngle = 2.0 * Math.PI * (1.0 - Math.cos(apexAngleRadians));\r\n                        photometricScale = solidAngle;\r\n                        break;\r\n                }\r\n                break;\r\n\r\n            case Light.LIGHTTYPEID_HEMISPHERICLIGHT:\r\n                // No fall off in hemisperic light.\r\n                photometricScale = 1.0;\r\n                break;\r\n        }\r\n        return photometricScale;\r\n    }\r\n\r\n    /**\r\n     * Reorder the light in the scene according to their defined priority.\r\n     * @hidden Internal Use Only\r\n     */\r\n    public _reorderLightsInScene(): void {\r\n        var scene = this.getScene();\r\n        if (this._renderPriority != 0) {\r\n            scene.requireLightSorting = true;\r\n        }\r\n        this.getScene().sortLightsByPriority();\r\n    }\r\n\r\n    /**\r\n     * Prepares the list of defines specific to the light type.\r\n     * @param defines the list of defines\r\n     * @param lightIndex defines the index of the light for the effect\r\n     */\r\n    public abstract prepareLightSpecificDefines(defines: any, lightIndex: number): void;\r\n}\r\n"]}