{"version":3,"file":"hemisphericLight.js","sourceRoot":"","sources":["../../../sourceES6/core/Lights/hemisphericLight.ts"],"names":[],"mappings":"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","sourcesContent":["import { serializeAsColor3, serializeAsVector3 } from \"../Misc/decorators\";\r\nimport { Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport { Node } from \"../node\";\r\nimport { Effect } from \"../Materials/effect\";\r\nimport { Light } from \"./light\";\r\nimport { IShadowGenerator } from \"./Shadows/shadowGenerator\";\r\n\r\nNode.AddNodeConstructor(\"Light_Type_3\", (name, scene) => {\r\n    return () => new HemisphericLight(name, Vector3.Zero(), scene);\r\n});\r\n\r\n/**\r\n * The HemisphericLight simulates the ambient environment light,\r\n * so the passed direction is the light reflection direction, not the incoming direction.\r\n */\r\nexport class HemisphericLight extends Light {\r\n    /**\r\n     * The groundColor is the light in the opposite direction to the one specified during creation.\r\n     * You can think of the diffuse and specular light as coming from the centre of the object in the given direction and the groundColor light in the opposite direction.\r\n     */\r\n    @serializeAsColor3()\r\n    public groundColor = new Color3(0.0, 0.0, 0.0);\r\n\r\n    /**\r\n     * The light reflection direction, not the incoming direction.\r\n     */\r\n    @serializeAsVector3()\r\n    public direction: Vector3;\r\n\r\n    /**\r\n     * Creates a HemisphericLight object in the scene according to the passed direction (Vector3).\r\n     * The HemisphericLight simulates the ambient environment light, so the passed direction is the light reflection direction, not the incoming direction.\r\n     * The HemisphericLight can't cast shadows.\r\n     * Documentation : https://doc.babylonjs.com/babylon101/lights\r\n     * @param name The friendly name of the light\r\n     * @param direction The direction of the light reflection\r\n     * @param scene The scene the light belongs to\r\n     */\r\n    constructor(name: string, direction: Vector3, scene: Scene) {\r\n        super(name, scene);\r\n        this.direction = direction || Vector3.Up();\r\n    }\r\n\r\n    protected _buildUniformLayout(): void {\r\n        this._uniformBuffer.addUniform(\"vLightData\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightDiffuse\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightSpecular\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightGround\", 3);\r\n        this._uniformBuffer.addUniform(\"shadowsInfo\", 3);\r\n        this._uniformBuffer.addUniform(\"depthValues\", 2);\r\n        this._uniformBuffer.create();\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"HemisphericLight\".\r\n     * @return The class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"HemisphericLight\";\r\n    }\r\n\r\n    /**\r\n     * Sets the HemisphericLight direction towards the passed target (Vector3).\r\n     * Returns the updated direction.\r\n     * @param target The target the direction should point to\r\n     * @return The computed direction\r\n     */\r\n    public setDirectionToTarget(target: Vector3): Vector3 {\r\n        this.direction = Vector3.Normalize(target.subtract(Vector3.Zero()));\r\n        return this.direction;\r\n    }\r\n\r\n    /**\r\n     * Returns the shadow generator associated to the light.\r\n     * @returns Always null for hemispheric lights because it does not support shadows.\r\n     */\r\n    public getShadowGenerator(): Nullable<IShadowGenerator> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Sets the passed Effect object with the HemisphericLight normalized direction and color and the passed name (string).\r\n     * @param effect The effect to update\r\n     * @param lightIndex The index of the light in the effect to update\r\n     * @returns The hemispheric light\r\n     */\r\n    public transferToEffect(effect: Effect, lightIndex: string): HemisphericLight {\r\n        var normalizeDirection = Vector3.Normalize(this.direction);\r\n        this._uniformBuffer.updateFloat4(\"vLightData\",\r\n            normalizeDirection.x,\r\n            normalizeDirection.y,\r\n            normalizeDirection.z,\r\n            0.0,\r\n            lightIndex);\r\n        this._uniformBuffer.updateColor3(\"vLightGround\", this.groundColor.scale(this.intensity), lightIndex);\r\n        return this;\r\n    }\r\n\r\n    public transferToNodeMaterialEffect(effect: Effect, lightDataUniformName: string) {\r\n        var normalizeDirection = Vector3.Normalize(this.direction);\r\n        effect.setFloat3(lightDataUniformName, normalizeDirection.x, normalizeDirection.y, normalizeDirection.z);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Computes the world matrix of the node\r\n     * @param force defines if the cache version should be invalidated forcing the world matrix to be created from scratch\r\n     * @param useWasUpdatedFlag defines a reserved property\r\n     * @returns the world matrix\r\n     */\r\n    public computeWorldMatrix(): Matrix {\r\n        if (!this._worldMatrix) {\r\n            this._worldMatrix = Matrix.Identity();\r\n        }\r\n        return this._worldMatrix;\r\n    }\r\n\r\n    /**\r\n     * Returns the integer 3.\r\n     * @return The light Type id as a constant defines in Light.LIGHTTYPEID_x\r\n     */\r\n    public getTypeID(): number {\r\n        return Light.LIGHTTYPEID_HEMISPHERICLIGHT;\r\n    }\r\n\r\n    /**\r\n     * Prepares the list of defines specific to the light type.\r\n     * @param defines the list of defines\r\n     * @param lightIndex defines the index of the light for the effect\r\n     */\r\n    public prepareLightSpecificDefines(defines: any, lightIndex: number): void {\r\n        defines[\"HEMILIGHT\" + lightIndex] = true;\r\n    }\r\n}\r\n"]}