{"version":3,"file":"dracoCompression.js","sourceRoot":"","sources":["../../../../sourceES6/core/Meshes/Compression/dracoCompression.ts"],"names":[],"mappings":"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","sourcesContent":["import { Tools } from \"../../Misc/tools\";\r\nimport { WorkerPool } from '../../Misc/workerPool';\r\nimport { Nullable } from \"../../types\";\r\nimport { IDisposable } from \"../../scene\";\r\nimport { VertexData } from \"../../Meshes/mesh.vertexData\";\r\n\r\ndeclare var DracoDecoderModule: any;\r\ndeclare var WebAssembly: any;\r\n\r\n// WorkerGlobalScope\r\ndeclare function importScripts(...urls: string[]): void;\r\ndeclare function postMessage(message: any, transfer?: any[]): void;\r\n\r\nfunction createDecoderAsync(wasmBinary?: ArrayBuffer): Promise<any> {\r\n    return new Promise((resolve) => {\r\n        DracoDecoderModule({ wasmBinary: wasmBinary }).then((module: any) => {\r\n            resolve({ module: module });\r\n        });\r\n    });\r\n}\r\n\r\nfunction decodeMesh(decoderModule: any, dataView: ArrayBufferView, attributes: { [kind: string]: number } | undefined, onIndicesData: (data: Uint32Array) => void, onAttributeData: (kind: string, data: Float32Array) => void): void {\r\n    const buffer = new decoderModule.DecoderBuffer();\r\n    buffer.Init(dataView, dataView.byteLength);\r\n\r\n    const decoder = new decoderModule.Decoder();\r\n    let geometry: any;\r\n    let status: any;\r\n\r\n    try {\r\n        const type = decoder.GetEncodedGeometryType(buffer);\r\n        switch (type) {\r\n            case decoderModule.TRIANGULAR_MESH:\r\n                geometry = new decoderModule.Mesh();\r\n                status = decoder.DecodeBufferToMesh(buffer, geometry);\r\n                break;\r\n            case decoderModule.POINT_CLOUD:\r\n                geometry = new decoderModule.PointCloud();\r\n                status = decoder.DecodeBufferToPointCloud(buffer, geometry);\r\n                break;\r\n            default:\r\n                throw new Error(`Invalid geometry type ${type}`);\r\n        }\r\n\r\n        if (!status.ok() || !geometry.ptr) {\r\n            throw new Error(status.error_msg());\r\n        }\r\n\r\n        const numPoints = geometry.num_points();\r\n\r\n        if (type === decoderModule.TRIANGULAR_MESH) {\r\n            const numFaces = geometry.num_faces();\r\n            const faceIndices = new decoderModule.DracoInt32Array();\r\n            try {\r\n                const indices = new Uint32Array(numFaces * 3);\r\n                for (let i = 0; i < numFaces; i++) {\r\n                    decoder.GetFaceFromMesh(geometry, i, faceIndices);\r\n                    const offset = i * 3;\r\n                    indices[offset + 0] = faceIndices.GetValue(0);\r\n                    indices[offset + 1] = faceIndices.GetValue(1);\r\n                    indices[offset + 2] = faceIndices.GetValue(2);\r\n                }\r\n                onIndicesData(indices);\r\n            }\r\n            finally {\r\n                decoderModule.destroy(faceIndices);\r\n            }\r\n        }\r\n\r\n        const processAttribute = (kind: string, attribute: any) => {\r\n            const dracoData = new decoderModule.DracoFloat32Array();\r\n            try {\r\n                decoder.GetAttributeFloatForAllPoints(geometry, attribute, dracoData);\r\n                const numComponents = attribute.num_components();\r\n                if (kind === \"color\" && numComponents === 3) {\r\n                    const babylonData = new Float32Array(numPoints * 4);\r\n                    for (let i = 0, j = 0; i < babylonData.length; i += 4, j += numComponents) {\r\n                        babylonData[i + 0] = dracoData.GetValue(j + 0);\r\n                        babylonData[i + 1] = dracoData.GetValue(j + 1);\r\n                        babylonData[i + 2] = dracoData.GetValue(j + 2);\r\n                        babylonData[i + 3] = 1;\r\n                    }\r\n                    onAttributeData(kind, babylonData);\r\n                }\r\n                else {\r\n                    const babylonData = new Float32Array(numPoints * numComponents);\r\n                    for (let i = 0; i < babylonData.length; i++) {\r\n                        babylonData[i] = dracoData.GetValue(i);\r\n                    }\r\n                    onAttributeData(kind, babylonData);\r\n                }\r\n            }\r\n            finally {\r\n                decoderModule.destroy(dracoData);\r\n            }\r\n        };\r\n\r\n        if (attributes) {\r\n            for (const kind in attributes) {\r\n                const id = attributes[kind];\r\n                const attribute = decoder.GetAttributeByUniqueId(geometry, id);\r\n                processAttribute(kind, attribute);\r\n            }\r\n        }\r\n        else {\r\n            const nativeAttributeTypes: { [kind: string]: string } = {\r\n                \"position\": \"POSITION\",\r\n                \"normal\": \"NORMAL\",\r\n                \"color\": \"COLOR\",\r\n                \"uv\": \"TEX_COORD\"\r\n            };\r\n\r\n            for (const kind in nativeAttributeTypes) {\r\n                const id = decoder.GetAttributeId(geometry, decoderModule[nativeAttributeTypes[kind]]);\r\n                if (id !== -1) {\r\n                    const attribute = decoder.GetAttribute(geometry, id);\r\n                    processAttribute(kind, attribute);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    finally {\r\n        if (geometry) {\r\n            decoderModule.destroy(geometry);\r\n        }\r\n\r\n        decoderModule.destroy(decoder);\r\n        decoderModule.destroy(buffer);\r\n    }\r\n}\r\n\r\n/**\r\n * The worker function that gets converted to a blob url to pass into a worker.\r\n */\r\nfunction worker(): void {\r\n    let decoderPromise: Promise<any> | undefined;\r\n\r\n    onmessage = (event) => {\r\n        const data = event.data;\r\n        switch (data.id) {\r\n            case \"init\": {\r\n                const decoder = data.decoder;\r\n                if (decoder.url) {\r\n                    importScripts(decoder.url);\r\n                    decoderPromise = createDecoderAsync(decoder.wasmBinary);\r\n                }\r\n                postMessage(\"done\");\r\n                break;\r\n            }\r\n            case \"decodeMesh\": {\r\n                if (!decoderPromise) {\r\n                    throw new Error(\"Draco decoder module is not available\");\r\n                }\r\n                decoderPromise.then((decoder) => {\r\n                    decodeMesh(decoder.module, data.dataView, data.attributes, (indices) => {\r\n                        postMessage({ id: \"indices\", value: indices }, [indices.buffer]);\r\n                    }, (kind, data) => {\r\n                        postMessage({ id: kind, value: data }, [data.buffer]);\r\n                    });\r\n                    postMessage(\"done\");\r\n                });\r\n                break;\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\nfunction getAbsoluteUrl<T>(url: T): T | string {\r\n    if (typeof document !== \"object\" || typeof url !== \"string\") {\r\n        return url;\r\n    }\r\n\r\n    return Tools.GetAbsoluteUrl(url);\r\n}\r\n\r\n/**\r\n * Configuration for Draco compression\r\n */\r\nexport interface IDracoCompressionConfiguration {\r\n    /**\r\n     * Configuration for the decoder.\r\n     */\r\n    decoder: {\r\n        /**\r\n         * The url to the WebAssembly module.\r\n         */\r\n        wasmUrl?: string;\r\n\r\n        /**\r\n         * The url to the WebAssembly binary.\r\n         */\r\n        wasmBinaryUrl?: string;\r\n\r\n        /**\r\n         * The url to the fallback JavaScript module.\r\n         */\r\n        fallbackUrl?: string;\r\n    };\r\n}\r\n\r\n/**\r\n * Draco compression (https://google.github.io/draco/)\r\n *\r\n * This class wraps the Draco module.\r\n *\r\n * **Encoder**\r\n *\r\n * The encoder is not currently implemented.\r\n *\r\n * **Decoder**\r\n *\r\n * By default, the configuration points to a copy of the Draco decoder files for glTF from the babylon.js preview cdn https://preview.babylonjs.com/draco_wasm_wrapper_gltf.js.\r\n *\r\n * To update the configuration, use the following code:\r\n * ```javascript\r\n *     DracoCompression.Configuration = {\r\n *         decoder: {\r\n *             wasmUrl: \"<url to the WebAssembly library>\",\r\n *             wasmBinaryUrl: \"<url to the WebAssembly binary>\",\r\n *             fallbackUrl: \"<url to the fallback JavaScript library>\",\r\n *         }\r\n *     };\r\n * ```\r\n *\r\n * Draco has two versions, one for WebAssembly and one for JavaScript. The decoder configuration can be set to only support Webssembly or only support the JavaScript version.\r\n * Decoding will automatically fallback to the JavaScript version if WebAssembly version is not configured or if WebAssembly is not supported by the browser.\r\n * Use `DracoCompression.DecoderAvailable` to determine if the decoder configuration is available for the current context.\r\n *\r\n * To decode Draco compressed data, get the default DracoCompression object and call decodeMeshAsync:\r\n * ```javascript\r\n *     var vertexData = await DracoCompression.Default.decodeMeshAsync(data);\r\n * ```\r\n *\r\n * @see https://www.babylonjs-playground.com/#N3EK4B#0\r\n */\r\nexport class DracoCompression implements IDisposable {\r\n    private _workerPoolPromise?: Promise<WorkerPool>;\r\n    private _decoderModulePromise?: Promise<any>;\r\n\r\n    /**\r\n     * The configuration. Defaults to the following urls:\r\n     * - wasmUrl: \"https://preview.babylonjs.com/draco_wasm_wrapper_gltf.js\"\r\n     * - wasmBinaryUrl: \"https://preview.babylonjs.com/draco_decoder_gltf.wasm\"\r\n     * - fallbackUrl: \"https://preview.babylonjs.com/draco_decoder_gltf.js\"\r\n     */\r\n    public static Configuration: IDracoCompressionConfiguration = {\r\n        decoder: {\r\n            wasmUrl: \"https://preview.babylonjs.com/draco_wasm_wrapper_gltf.js\",\r\n            wasmBinaryUrl: \"https://preview.babylonjs.com/draco_decoder_gltf.wasm\",\r\n            fallbackUrl: \"https://preview.babylonjs.com/draco_decoder_gltf.js\"\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Returns true if the decoder configuration is available.\r\n     */\r\n    public static get DecoderAvailable(): boolean {\r\n        const decoder = DracoCompression.Configuration.decoder;\r\n        return !!((decoder.wasmUrl && decoder.wasmBinaryUrl && typeof WebAssembly === \"object\") || decoder.fallbackUrl);\r\n    }\r\n\r\n    /**\r\n     * Default number of workers to create when creating the draco compression object.\r\n     */\r\n    public static DefaultNumWorkers = DracoCompression.GetDefaultNumWorkers();\r\n\r\n    private static GetDefaultNumWorkers(): number {\r\n        if (typeof navigator !== \"object\" || !navigator.hardwareConcurrency) {\r\n            return 1;\r\n        }\r\n\r\n        // Use 50% of the available logical processors but capped at 4.\r\n        return Math.min(Math.floor(navigator.hardwareConcurrency * 0.5), 4);\r\n    }\r\n\r\n    private static _Default: Nullable<DracoCompression> = null;\r\n\r\n    /**\r\n     * Default instance for the draco compression object.\r\n     */\r\n    public static get Default(): DracoCompression {\r\n        if (!DracoCompression._Default) {\r\n            DracoCompression._Default = new DracoCompression();\r\n        }\r\n\r\n        return DracoCompression._Default;\r\n    }\r\n\r\n    /**\r\n     * Constructor\r\n     * @param numWorkers The number of workers for async operations. Specify `0` to disable web workers and run synchronously in the current context.\r\n     */\r\n    constructor(numWorkers = DracoCompression.DefaultNumWorkers) {\r\n        const decoder = DracoCompression.Configuration.decoder;\r\n\r\n        const decoderInfo: { url: string | undefined, wasmBinaryPromise: Promise<ArrayBuffer | string | undefined> } =\r\n            (decoder.wasmUrl && decoder.wasmBinaryUrl && typeof WebAssembly === \"object\") ? {\r\n                url: decoder.wasmUrl,\r\n                wasmBinaryPromise: Tools.LoadFileAsync(getAbsoluteUrl(decoder.wasmBinaryUrl))\r\n            } : {\r\n                url: decoder.fallbackUrl,\r\n                wasmBinaryPromise: Promise.resolve(undefined)\r\n            };\r\n\r\n        if (numWorkers && typeof Worker === \"function\") {\r\n            this._workerPoolPromise = decoderInfo.wasmBinaryPromise.then((decoderWasmBinary) => {\r\n                const workerContent = `${createDecoderAsync}${decodeMesh}(${worker})()`;\r\n                const workerBlobUrl = URL.createObjectURL(new Blob([workerContent], { type: \"application/javascript\" }));\r\n                const workerPromises = new Array<Promise<Worker>>(numWorkers);\r\n                for (let i = 0; i < workerPromises.length; i++) {\r\n                    workerPromises[i] = new Promise((resolve, reject) => {\r\n                        const worker = new Worker(workerBlobUrl);\r\n                        const onError = (error: ErrorEvent) => {\r\n                            worker.removeEventListener(\"error\", onError);\r\n                            worker.removeEventListener(\"message\", onMessage);\r\n                            reject(error);\r\n                        };\r\n\r\n                        const onMessage = (message: MessageEvent) => {\r\n                            if (message.data === \"done\") {\r\n                                worker.removeEventListener(\"error\", onError);\r\n                                worker.removeEventListener(\"message\", onMessage);\r\n                                resolve(worker);\r\n                            }\r\n                        };\r\n\r\n                        worker.addEventListener(\"error\", onError);\r\n                        worker.addEventListener(\"message\", onMessage);\r\n\r\n                        worker.postMessage({\r\n                            id: \"init\",\r\n                            decoder: {\r\n                                url: getAbsoluteUrl(decoderInfo.url),\r\n                                wasmBinary: decoderWasmBinary,\r\n                            }\r\n                        });\r\n                    });\r\n                }\r\n\r\n                return Promise.all(workerPromises).then((workers) => {\r\n                    return new WorkerPool(workers);\r\n                });\r\n            });\r\n        }\r\n        else {\r\n            this._decoderModulePromise = decoderInfo.wasmBinaryPromise.then((decoderWasmBinary) => {\r\n                if (!decoderInfo.url) {\r\n                    throw new Error(\"Draco decoder module is not available\");\r\n                }\r\n\r\n                return Tools.LoadScriptAsync(decoderInfo.url).then(() => {\r\n                    return createDecoderAsync(decoderWasmBinary as ArrayBuffer);\r\n                });\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stop all async operations and release resources.\r\n     */\r\n    public dispose(): void {\r\n        if (this._workerPoolPromise) {\r\n            this._workerPoolPromise.then((workerPool) => {\r\n                workerPool.dispose();\r\n            });\r\n        }\r\n\r\n        delete this._workerPoolPromise;\r\n        delete this._decoderModulePromise;\r\n    }\r\n\r\n    /**\r\n     * Returns a promise that resolves when ready. Call this manually to ensure draco compression is ready before use.\r\n     * @returns a promise that resolves when ready\r\n     */\r\n    public whenReadyAsync(): Promise<void> {\r\n        if (this._workerPoolPromise) {\r\n            return this._workerPoolPromise.then(() => { });\r\n        }\r\n\r\n        if (this._decoderModulePromise) {\r\n            return this._decoderModulePromise.then(() => { });\r\n        }\r\n\r\n        return Promise.resolve();\r\n    }\r\n\r\n    /**\r\n      * Decode Draco compressed mesh data to vertex data.\r\n      * @param data The ArrayBuffer or ArrayBufferView for the Draco compression data\r\n      * @param attributes A map of attributes from vertex buffer kinds to Draco unique ids\r\n      * @returns A promise that resolves with the decoded vertex data\r\n      */\r\n    public decodeMeshAsync(data: ArrayBuffer | ArrayBufferView, attributes?: { [kind: string]: number }): Promise<VertexData> {\r\n        const dataView = data instanceof ArrayBuffer ? new Uint8Array(data) : data;\r\n\r\n        if (this._workerPoolPromise) {\r\n            return this._workerPoolPromise.then((workerPool) => {\r\n                return new Promise<VertexData>((resolve, reject) => {\r\n                    workerPool.push((worker, onComplete) => {\r\n                        const vertexData = new VertexData();\r\n\r\n                        const onError = (error: ErrorEvent) => {\r\n                            worker.removeEventListener(\"error\", onError);\r\n                            worker.removeEventListener(\"message\", onMessage);\r\n                            reject(error);\r\n                            onComplete();\r\n                        };\r\n\r\n                        const onMessage = (message: MessageEvent) => {\r\n                            if (message.data === \"done\") {\r\n                                worker.removeEventListener(\"error\", onError);\r\n                                worker.removeEventListener(\"message\", onMessage);\r\n                                resolve(vertexData);\r\n                                onComplete();\r\n                            }\r\n                            else if (message.data.id === \"indices\") {\r\n                                vertexData.indices = message.data.value;\r\n                            }\r\n                            else {\r\n                                vertexData.set(message.data.value, message.data.id);\r\n                            }\r\n                        };\r\n\r\n                        worker.addEventListener(\"error\", onError);\r\n                        worker.addEventListener(\"message\", onMessage);\r\n\r\n                        const dataViewCopy = new Uint8Array(dataView.byteLength);\r\n                        dataViewCopy.set(new Uint8Array(dataView.buffer, dataView.byteOffset, dataView.byteLength));\r\n\r\n                        worker.postMessage({ id: \"decodeMesh\", dataView: dataViewCopy, attributes: attributes }, [dataViewCopy.buffer]);\r\n                    });\r\n                });\r\n            });\r\n        }\r\n\r\n        if (this._decoderModulePromise) {\r\n            return this._decoderModulePromise.then((decoder) => {\r\n                const vertexData = new VertexData();\r\n                decodeMesh(decoder.module, dataView, attributes, (indices) => {\r\n                    vertexData.indices = indices;\r\n                }, (kind, data) => {\r\n                    vertexData.set(data, kind);\r\n                });\r\n                return vertexData;\r\n            });\r\n        }\r\n\r\n        throw new Error(\"Draco decoder module is not available\");\r\n    }\r\n}\r\n"]}