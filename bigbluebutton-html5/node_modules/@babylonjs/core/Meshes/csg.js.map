{"version":3,"file":"csg.js","sourceRoot":"","sources":["../../../sourceES6/core/Meshes/csg.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable, FloatArray, IndicesArray } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport { Quaternion, Matrix, Vector3, Vector2 } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Meshes/buffer\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { SubMesh } from \"../Meshes/subMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { Material } from \"../Materials/material\";\r\n/**\r\n * Unique ID when we import meshes from Babylon to CSG\r\n */\r\nvar currentCSGMeshId = 0;\r\n\r\n/**\r\n * Represents a vertex of a polygon. Use your own vertex class instead of this\r\n * one to provide additional features like texture coordinates and vertex\r\n * colors. Custom vertex classes need to provide a `pos` property and `clone()`,\r\n * `flip()`, and `interpolate()` methods that behave analogous to the ones\r\n * defined by `BABYLON.CSG.Vertex`. This class provides `normal` so convenience\r\n * functions like `BABYLON.CSG.sphere()` can return a smooth vertex normal, but `normal`\r\n * is not used anywhere else.\r\n * Same goes for uv, it allows to keep the original vertex uv coordinates of the 2 meshes\r\n */\r\nclass Vertex {\r\n    /**\r\n     * Initializes the vertex\r\n     * @param pos The position of the vertex\r\n     * @param normal The normal of the vertex\r\n     * @param uv The texture coordinate of the vertex\r\n     */\r\n    constructor(\r\n        /**\r\n         * The position of the vertex\r\n         */\r\n        public pos: Vector3,\r\n        /**\r\n         * The normal of the vertex\r\n         */\r\n        public normal: Vector3,\r\n        /**\r\n         * The texture coordinate of the vertex\r\n         */\r\n        public uv: Vector2) {\r\n    }\r\n\r\n    /**\r\n     * Make a clone, or deep copy, of the vertex\r\n     * @returns A new Vertex\r\n     */\r\n    public clone(): Vertex {\r\n        return new Vertex(this.pos.clone(), this.normal.clone(), this.uv.clone());\r\n    }\r\n\r\n    /**\r\n     * Invert all orientation-specific data (e.g. vertex normal). Called when the\r\n     * orientation of a polygon is flipped.\r\n     */\r\n    public flip(): void {\r\n        this.normal = this.normal.scale(-1);\r\n    }\r\n\r\n    /**\r\n     * Create a new vertex between this vertex and `other` by linearly\r\n     * interpolating all properties using a parameter of `t`. Subclasses should\r\n     * override this to interpolate additional properties.\r\n     * @param other the vertex to interpolate against\r\n     * @param t The factor used to linearly interpolate between the vertices\r\n     */\r\n    public interpolate(other: Vertex, t: number): Vertex {\r\n        return new Vertex(Vector3.Lerp(this.pos, other.pos, t),\r\n            Vector3.Lerp(this.normal, other.normal, t),\r\n            Vector2.Lerp(this.uv, other.uv, t)\r\n        );\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a plane in 3D space.\r\n */\r\nclass Plane {\r\n    /**\r\n     * Initializes the plane\r\n     * @param normal The normal for the plane\r\n     * @param w\r\n     */\r\n    constructor(public normal: Vector3, public w: number) {\r\n    }\r\n\r\n    /**\r\n     * `CSG.Plane.EPSILON` is the tolerance used by `splitPolygon()` to decide if a\r\n     * point is on the plane\r\n     */\r\n    static EPSILON = 1e-5;\r\n\r\n    /**\r\n     * Construct a plane from three points\r\n     * @param a Point a\r\n     * @param b Point b\r\n     * @param c Point c\r\n     */\r\n    public static FromPoints(a: Vector3, b: Vector3, c: Vector3): Nullable<Plane> {\r\n        var v0 = c.subtract(a);\r\n        var v1 = b.subtract(a);\r\n\r\n        if (v0.lengthSquared() === 0 || v1.lengthSquared() === 0) {\r\n            return null;\r\n        }\r\n\r\n        var n = Vector3.Normalize(Vector3.Cross(v0, v1));\r\n        return new Plane(n, Vector3.Dot(n, a));\r\n    }\r\n\r\n    /**\r\n     * Clone, or make a deep copy of the plane\r\n     * @returns a new Plane\r\n     */\r\n    public clone(): Plane {\r\n        return new Plane(this.normal.clone(), this.w);\r\n    }\r\n\r\n    /**\r\n     * Flip the face of the plane\r\n     */\r\n    public flip() {\r\n        this.normal.scaleInPlace(-1);\r\n        this.w = -this.w;\r\n    }\r\n\r\n    /**\r\n     * Split `polygon` by this plane if needed, then put the polygon or polygon\r\n     * fragments in the appropriate lists. Coplanar polygons go into either\r\n    `* coplanarFront` or `coplanarBack` depending on their orientation with\r\n     * respect to this plane. Polygons in front or in back of this plane go into\r\n     * either `front` or `back`\r\n     * @param polygon The polygon to be split\r\n     * @param coplanarFront Will contain polygons coplanar with the plane that are oriented to the front of the plane\r\n     * @param coplanarBack Will contain polygons coplanar with the plane that are oriented to the back of the plane\r\n     * @param front Will contain the polygons in front of the plane\r\n     * @param back Will contain the polygons begind the plane\r\n     */\r\n    public splitPolygon(polygon: Polygon, coplanarFront: Polygon[], coplanarBack: Polygon[], front: Polygon[], back: Polygon[]): void {\r\n        var COPLANAR = 0;\r\n        var FRONT = 1;\r\n        var BACK = 2;\r\n        var SPANNING = 3;\r\n\r\n        // Classify each point as well as the entire polygon into one of the above\r\n        // four classes.\r\n        var polygonType = 0;\r\n        var types = [];\r\n        var i: number;\r\n        var t: number;\r\n        for (i = 0; i < polygon.vertices.length; i++) {\r\n            t = Vector3.Dot(this.normal, polygon.vertices[i].pos) - this.w;\r\n            var type = (t < -Plane.EPSILON) ? BACK : (t > Plane.EPSILON) ? FRONT : COPLANAR;\r\n            polygonType |= type;\r\n            types.push(type);\r\n        }\r\n\r\n        // Put the polygon in the correct list, splitting it when necessary\r\n        switch (polygonType) {\r\n            case COPLANAR:\r\n                (Vector3.Dot(this.normal, polygon.plane.normal) > 0 ? coplanarFront : coplanarBack).push(polygon);\r\n                break;\r\n            case FRONT:\r\n                front.push(polygon);\r\n                break;\r\n            case BACK:\r\n                back.push(polygon);\r\n                break;\r\n            case SPANNING:\r\n                var f = [], b = [];\r\n                for (i = 0; i < polygon.vertices.length; i++) {\r\n                    var j = (i + 1) % polygon.vertices.length;\r\n                    var ti = types[i], tj = types[j];\r\n                    var vi = polygon.vertices[i], vj = polygon.vertices[j];\r\n                    if (ti !== BACK) { f.push(vi); }\r\n                    if (ti !== FRONT) { b.push(ti !== BACK ? vi.clone() : vi); }\r\n                    if ((ti | tj) === SPANNING) {\r\n                        t = (this.w - Vector3.Dot(this.normal, vi.pos)) / Vector3.Dot(this.normal, vj.pos.subtract(vi.pos));\r\n                        var v = vi.interpolate(vj, t);\r\n                        f.push(v);\r\n                        b.push(v.clone());\r\n                    }\r\n                }\r\n                var poly: Polygon;\r\n                if (f.length >= 3) {\r\n                    poly = new Polygon(f, polygon.shared);\r\n                    if (poly.plane) {\r\n                        front.push(poly);\r\n                    }\r\n                }\r\n\r\n                if (b.length >= 3) {\r\n                    poly = new Polygon(b, polygon.shared);\r\n\r\n                    if (poly.plane) {\r\n                        back.push(poly);\r\n                    }\r\n                }\r\n\r\n                break;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a convex polygon. The vertices used to initialize a polygon must\r\n * be coplanar and form a convex loop.\r\n *\r\n * Each convex polygon has a `shared` property, which is shared between all\r\n * polygons that are clones of each other or were split from the same polygon.\r\n * This can be used to define per-polygon properties (such as surface color)\r\n */\r\nclass Polygon {\r\n    /**\r\n     * Vertices of the polygon\r\n     */\r\n    public vertices: Vertex[];\r\n    /**\r\n     * Properties that are shared across all polygons\r\n     */\r\n    public shared: any;\r\n    /**\r\n     * A plane formed from the vertices of the polygon\r\n     */\r\n    public plane: Plane;\r\n\r\n    /**\r\n     * Initializes the polygon\r\n     * @param vertices The vertices of the polygon\r\n     * @param shared The properties shared across all polygons\r\n     */\r\n    constructor(vertices: Vertex[], shared: any) {\r\n        this.vertices = vertices;\r\n        this.shared = shared;\r\n        this.plane = <Plane>Plane.FromPoints(vertices[0].pos, vertices[1].pos, vertices[2].pos);\r\n\r\n    }\r\n\r\n    /**\r\n     * Clones, or makes a deep copy, or the polygon\r\n     */\r\n    public clone(): Polygon {\r\n        var vertices = this.vertices.map((v) => v.clone());\r\n        return new Polygon(vertices, this.shared);\r\n    }\r\n\r\n    /**\r\n     * Flips the faces of the polygon\r\n     */\r\n    public flip() {\r\n        this.vertices.reverse().map((v) => { v.flip(); });\r\n        this.plane.flip();\r\n    }\r\n}\r\n\r\n/**\r\n * Holds a node in a BSP tree. A BSP tree is built from a collection of polygons\r\n * by picking a polygon to split along. That polygon (and all other coplanar\r\n * polygons) are added directly to that node and the other polygons are added to\r\n * the front and/or back subtrees. This is not a leafy BSP tree since there is\r\n * no distinction between internal and leaf nodes\r\n */\r\nclass Node {\r\n    private plane: Nullable<Plane> = null;\r\n    private front: Nullable<Node> = null;\r\n    private back: Nullable<Node> = null;\r\n    private polygons = new Array<Polygon>();\r\n\r\n    /**\r\n     * Initializes the node\r\n     * @param polygons A collection of polygons held in the node\r\n     */\r\n    constructor(polygons?: Array<Polygon>) {\r\n        if (polygons) {\r\n            this.build(polygons);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clones, or makes a deep copy, of the node\r\n     * @returns The cloned node\r\n     */\r\n    public clone(): Node {\r\n        var node = new Node();\r\n        node.plane = this.plane && this.plane.clone();\r\n        node.front = this.front && this.front.clone();\r\n        node.back = this.back && this.back.clone();\r\n        node.polygons = this.polygons.map((p) => p.clone());\r\n        return node;\r\n    }\r\n\r\n    /**\r\n     * Convert solid space to empty space and empty space to solid space\r\n     */\r\n    public invert(): void {\r\n        for (var i = 0; i < this.polygons.length; i++) {\r\n            this.polygons[i].flip();\r\n        }\r\n        if (this.plane) {\r\n            this.plane.flip();\r\n        }\r\n        if (this.front) {\r\n            this.front.invert();\r\n        }\r\n        if (this.back) {\r\n            this.back.invert();\r\n        }\r\n        var temp = this.front;\r\n        this.front = this.back;\r\n        this.back = temp;\r\n    }\r\n\r\n    /**\r\n     * Recursively remove all polygons in `polygons` that are inside this BSP\r\n     * tree.\r\n     * @param polygons Polygons to remove from the BSP\r\n     * @returns Polygons clipped from the BSP\r\n     */\r\n    clipPolygons(polygons: Polygon[]): Polygon[] {\r\n        if (!this.plane) { return polygons.slice(); }\r\n        var front = new Array<Polygon>(), back = new Array<Polygon>();\r\n        for (var i = 0; i < polygons.length; i++) {\r\n            this.plane.splitPolygon(polygons[i], front, back, front, back);\r\n        }\r\n        if (this.front) {\r\n            front = this.front.clipPolygons(front);\r\n        }\r\n        if (this.back) {\r\n            back = this.back.clipPolygons(back);\r\n        } else {\r\n            back = [];\r\n        }\r\n        return front.concat(back);\r\n    }\r\n\r\n    /**\r\n     * Remove all polygons in this BSP tree that are inside the other BSP tree\r\n     * `bsp`.\r\n     * @param bsp BSP containing polygons to remove from this BSP\r\n     */\r\n    clipTo(bsp: Node): void {\r\n        this.polygons = bsp.clipPolygons(this.polygons);\r\n        if (this.front) { this.front.clipTo(bsp); }\r\n        if (this.back) { this.back.clipTo(bsp); }\r\n    }\r\n\r\n    /**\r\n     * Return a list of all polygons in this BSP tree\r\n     * @returns List of all polygons in this BSP tree\r\n     */\r\n    allPolygons(): Polygon[] {\r\n        var polygons = this.polygons.slice();\r\n        if (this.front) { polygons = polygons.concat(this.front.allPolygons()); }\r\n        if (this.back) { polygons = polygons.concat(this.back.allPolygons()); }\r\n        return polygons;\r\n    }\r\n\r\n    /**\r\n     * Build a BSP tree out of `polygons`. When called on an existing tree, the\r\n     * new polygons are filtered down to the bottom of the tree and become new\r\n     * nodes there. Each set of polygons is partitioned using the first polygon\r\n     * (no heuristic is used to pick a good split)\r\n     * @param polygons Polygons used to construct the BSP tree\r\n     */\r\n    build(polygons: Polygon[]): void {\r\n        if (!polygons.length) { return; }\r\n        if (!this.plane) { this.plane = polygons[0].plane.clone(); }\r\n        var front = new Array<Polygon>(), back = new Array<Polygon>();\r\n        for (var i = 0; i < polygons.length; i++) {\r\n            this.plane.splitPolygon(polygons[i], this.polygons, this.polygons, front, back);\r\n        }\r\n        if (front.length) {\r\n            if (!this.front) { this.front = new Node(); }\r\n            this.front.build(front);\r\n        }\r\n        if (back.length) {\r\n            if (!this.back) { this.back = new Node(); }\r\n            this.back.build(back);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Class for building Constructive Solid Geometry\r\n */\r\nexport class CSG {\r\n    private polygons = new Array<Polygon>();\r\n    /**\r\n     * The world matrix\r\n     */\r\n    public matrix: Matrix;\r\n    /**\r\n     * Stores the position\r\n     */\r\n    public position: Vector3;\r\n    /**\r\n     * Stores the rotation\r\n     */\r\n    public rotation: Vector3;\r\n    /**\r\n     * Stores the rotation quaternion\r\n     */\r\n    public rotationQuaternion: Nullable<Quaternion>;\r\n    /**\r\n     * Stores the scaling vector\r\n     */\r\n    public scaling: Vector3;\r\n\r\n    /**\r\n     * Convert the Mesh to CSG\r\n     * @param mesh The Mesh to convert to CSG\r\n     * @returns A new CSG from the Mesh\r\n     */\r\n    public static FromMesh(mesh: Mesh): CSG {\r\n        var vertex: Vertex, normal: Vector3, uv: Vector2, position: Vector3,\r\n            polygon: Polygon,\r\n            polygons = new Array<Polygon>(),\r\n            vertices;\r\n        var matrix: Matrix,\r\n            meshPosition: Vector3,\r\n            meshRotation: Vector3,\r\n            meshRotationQuaternion: Nullable<Quaternion> = null,\r\n            meshScaling: Vector3;\r\n\r\n        if (mesh instanceof Mesh) {\r\n            mesh.computeWorldMatrix(true);\r\n            matrix = mesh.getWorldMatrix();\r\n            meshPosition = mesh.position.clone();\r\n            meshRotation = mesh.rotation.clone();\r\n            if (mesh.rotationQuaternion) {\r\n                meshRotationQuaternion = mesh.rotationQuaternion.clone();\r\n            }\r\n            meshScaling = mesh.scaling.clone();\r\n        } else {\r\n            throw 'BABYLON.CSG: Wrong Mesh type, must be BABYLON.Mesh';\r\n        }\r\n\r\n        var indices = <IndicesArray>mesh.getIndices(),\r\n            positions = <FloatArray>mesh.getVerticesData(VertexBuffer.PositionKind),\r\n            normals = <FloatArray>mesh.getVerticesData(VertexBuffer.NormalKind),\r\n            uvs = <FloatArray>mesh.getVerticesData(VertexBuffer.UVKind);\r\n\r\n        var subMeshes = mesh.subMeshes;\r\n\r\n        for (var sm = 0, sml = subMeshes.length; sm < sml; sm++) {\r\n            for (var i = subMeshes[sm].indexStart, il = subMeshes[sm].indexCount + subMeshes[sm].indexStart; i < il; i += 3) {\r\n                vertices = [];\r\n                for (var j = 0; j < 3; j++) {\r\n                    var sourceNormal = new Vector3(normals[indices[i + j] * 3], normals[indices[i + j] * 3 + 1], normals[indices[i + j] * 3 + 2]);\r\n                    uv = new Vector2(uvs[indices[i + j] * 2], uvs[indices[i + j] * 2 + 1]);\r\n                    var sourcePosition = new Vector3(positions[indices[i + j] * 3], positions[indices[i + j] * 3 + 1], positions[indices[i + j] * 3 + 2]);\r\n                    position = Vector3.TransformCoordinates(sourcePosition, matrix);\r\n                    normal = Vector3.TransformNormal(sourceNormal, matrix);\r\n\r\n                    vertex = new Vertex(position, normal, uv);\r\n                    vertices.push(vertex);\r\n                }\r\n\r\n                polygon = new Polygon(vertices, { subMeshId: sm, meshId: currentCSGMeshId, materialIndex: subMeshes[sm].materialIndex });\r\n\r\n                // To handle the case of degenerated triangle\r\n                // polygon.plane == null <=> the polygon does not represent 1 single plane <=> the triangle is degenerated\r\n                if (polygon.plane) {\r\n                    polygons.push(polygon);\r\n                }\r\n            }\r\n        }\r\n\r\n        var csg = CSG.FromPolygons(polygons);\r\n        csg.matrix = matrix;\r\n        csg.position = meshPosition;\r\n        csg.rotation = meshRotation;\r\n        csg.scaling = meshScaling;\r\n        csg.rotationQuaternion = meshRotationQuaternion;\r\n        currentCSGMeshId++;\r\n\r\n        return csg;\r\n    }\r\n\r\n    /**\r\n     * Construct a CSG solid from a list of `CSG.Polygon` instances.\r\n     * @param polygons Polygons used to construct a CSG solid\r\n     */\r\n    private static FromPolygons(polygons: Polygon[]): CSG {\r\n        var csg = new CSG();\r\n        csg.polygons = polygons;\r\n        return csg;\r\n    }\r\n\r\n    /**\r\n     * Clones, or makes a deep copy, of the CSG\r\n     * @returns A new CSG\r\n     */\r\n    public clone(): CSG {\r\n        var csg = new CSG();\r\n        csg.polygons = this.polygons.map((p) => p.clone());\r\n        csg.copyTransformAttributes(this);\r\n        return csg;\r\n    }\r\n\r\n    /**\r\n     * Unions this CSG with another CSG\r\n     * @param csg The CSG to union against this CSG\r\n     * @returns The unioned CSG\r\n     */\r\n    public union(csg: CSG): CSG {\r\n        var a = new Node(this.clone().polygons);\r\n        var b = new Node(csg.clone().polygons);\r\n        a.clipTo(b);\r\n        b.clipTo(a);\r\n        b.invert();\r\n        b.clipTo(a);\r\n        b.invert();\r\n        a.build(b.allPolygons());\r\n        return CSG.FromPolygons(a.allPolygons()).copyTransformAttributes(this);\r\n    }\r\n\r\n    /**\r\n     * Unions this CSG with another CSG in place\r\n     * @param csg The CSG to union against this CSG\r\n     */\r\n    public unionInPlace(csg: CSG): void {\r\n        var a = new Node(this.polygons);\r\n        var b = new Node(csg.polygons);\r\n\r\n        a.clipTo(b);\r\n        b.clipTo(a);\r\n        b.invert();\r\n        b.clipTo(a);\r\n        b.invert();\r\n        a.build(b.allPolygons());\r\n\r\n        this.polygons = a.allPolygons();\r\n    }\r\n\r\n    /**\r\n     * Subtracts this CSG with another CSG\r\n     * @param csg The CSG to subtract against this CSG\r\n     * @returns A new CSG\r\n     */\r\n    public subtract(csg: CSG): CSG {\r\n        var a = new Node(this.clone().polygons);\r\n        var b = new Node(csg.clone().polygons);\r\n        a.invert();\r\n        a.clipTo(b);\r\n        b.clipTo(a);\r\n        b.invert();\r\n        b.clipTo(a);\r\n        b.invert();\r\n        a.build(b.allPolygons());\r\n        a.invert();\r\n        return CSG.FromPolygons(a.allPolygons()).copyTransformAttributes(this);\r\n    }\r\n\r\n    /**\r\n     * Subtracts this CSG with another CSG in place\r\n     * @param csg The CSG to subtact against this CSG\r\n     */\r\n    public subtractInPlace(csg: CSG): void {\r\n        var a = new Node(this.polygons);\r\n        var b = new Node(csg.polygons);\r\n\r\n        a.invert();\r\n        a.clipTo(b);\r\n        b.clipTo(a);\r\n        b.invert();\r\n        b.clipTo(a);\r\n        b.invert();\r\n        a.build(b.allPolygons());\r\n        a.invert();\r\n\r\n        this.polygons = a.allPolygons();\r\n    }\r\n\r\n    /**\r\n     * Intersect this CSG with another CSG\r\n     * @param csg The CSG to intersect against this CSG\r\n     * @returns A new CSG\r\n     */\r\n    public intersect(csg: CSG): CSG {\r\n        var a = new Node(this.clone().polygons);\r\n        var b = new Node(csg.clone().polygons);\r\n        a.invert();\r\n        b.clipTo(a);\r\n        b.invert();\r\n        a.clipTo(b);\r\n        b.clipTo(a);\r\n        a.build(b.allPolygons());\r\n        a.invert();\r\n        return CSG.FromPolygons(a.allPolygons()).copyTransformAttributes(this);\r\n    }\r\n\r\n    /**\r\n     * Intersects this CSG with another CSG in place\r\n     * @param csg The CSG to intersect against this CSG\r\n     */\r\n    public intersectInPlace(csg: CSG): void {\r\n        var a = new Node(this.polygons);\r\n        var b = new Node(csg.polygons);\r\n\r\n        a.invert();\r\n        b.clipTo(a);\r\n        b.invert();\r\n        a.clipTo(b);\r\n        b.clipTo(a);\r\n        a.build(b.allPolygons());\r\n        a.invert();\r\n\r\n        this.polygons = a.allPolygons();\r\n    }\r\n\r\n    /**\r\n     * Return a new CSG solid with solid and empty space switched. This solid is\r\n     * not modified.\r\n     * @returns A new CSG solid with solid and empty space switched\r\n     */\r\n    public inverse(): CSG {\r\n        var csg = this.clone();\r\n        csg.inverseInPlace();\r\n        return csg;\r\n    }\r\n\r\n    /**\r\n     * Inverses the CSG in place\r\n     */\r\n    public inverseInPlace(): void {\r\n        this.polygons.map((p) => { p.flip(); });\r\n    }\r\n\r\n    /**\r\n     * This is used to keep meshes transformations so they can be restored\r\n     * when we build back a Babylon Mesh\r\n     * NB : All CSG operations are performed in world coordinates\r\n     * @param csg The CSG to copy the transform attributes from\r\n     * @returns This CSG\r\n     */\r\n    public copyTransformAttributes(csg: CSG): CSG {\r\n        this.matrix = csg.matrix;\r\n        this.position = csg.position;\r\n        this.rotation = csg.rotation;\r\n        this.scaling = csg.scaling;\r\n        this.rotationQuaternion = csg.rotationQuaternion;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Build Raw mesh from CSG\r\n     * Coordinates here are in world space\r\n     * @param name The name of the mesh geometry\r\n     * @param scene The Scene\r\n     * @param keepSubMeshes Specifies if the submeshes should be kept\r\n     * @returns A new Mesh\r\n     */\r\n    public buildMeshGeometry(name: string, scene?: Scene, keepSubMeshes?: boolean): Mesh {\r\n        var matrix = this.matrix.clone();\r\n        matrix.invert();\r\n\r\n        var mesh = new Mesh(name, scene),\r\n            vertices = [],\r\n            indices = [],\r\n            normals = [],\r\n            uvs = [],\r\n            vertex = Vector3.Zero(),\r\n            normal = Vector3.Zero(),\r\n            uv = Vector2.Zero(),\r\n            polygons = this.polygons,\r\n            polygonIndices = [0, 0, 0], polygon,\r\n            vertice_dict = {},\r\n            vertex_idx,\r\n            currentIndex = 0,\r\n            subMesh_dict = {},\r\n            subMesh_obj;\r\n\r\n        if (keepSubMeshes) {\r\n            // Sort Polygons, since subMeshes are indices range\r\n            polygons.sort((a, b) => {\r\n                if (a.shared.meshId === b.shared.meshId) {\r\n                    return a.shared.subMeshId - b.shared.subMeshId;\r\n                } else {\r\n                    return a.shared.meshId - b.shared.meshId;\r\n                }\r\n            });\r\n        }\r\n\r\n        for (var i = 0, il = polygons.length; i < il; i++) {\r\n            polygon = polygons[i];\r\n\r\n            // Building SubMeshes\r\n            if (!(<any>subMesh_dict)[polygon.shared.meshId]) {\r\n                (<any>subMesh_dict)[polygon.shared.meshId] = {};\r\n            }\r\n            if (!(<any>subMesh_dict)[polygon.shared.meshId][polygon.shared.subMeshId]) {\r\n                (<any>subMesh_dict)[polygon.shared.meshId][polygon.shared.subMeshId] = {\r\n                    indexStart: +Infinity,\r\n                    indexEnd: -Infinity,\r\n                    materialIndex: polygon.shared.materialIndex\r\n                };\r\n            }\r\n            subMesh_obj = (<any>subMesh_dict)[polygon.shared.meshId][polygon.shared.subMeshId];\r\n\r\n            for (var j = 2, jl = polygon.vertices.length; j < jl; j++) {\r\n\r\n                polygonIndices[0] = 0;\r\n                polygonIndices[1] = j - 1;\r\n                polygonIndices[2] = j;\r\n\r\n                for (var k = 0; k < 3; k++) {\r\n                    vertex.copyFrom(polygon.vertices[polygonIndices[k]].pos);\r\n                    normal.copyFrom(polygon.vertices[polygonIndices[k]].normal);\r\n                    uv.copyFrom(polygon.vertices[polygonIndices[k]].uv);\r\n                    var localVertex = Vector3.TransformCoordinates(vertex, matrix);\r\n                    var localNormal = Vector3.TransformNormal(normal, matrix);\r\n\r\n                    vertex_idx = (<any>vertice_dict)[localVertex.x + ',' + localVertex.y + ',' + localVertex.z];\r\n\r\n                    // Check if 2 points can be merged\r\n                    if (!(typeof vertex_idx !== 'undefined' &&\r\n                        normals[vertex_idx * 3] === localNormal.x &&\r\n                        normals[vertex_idx * 3 + 1] === localNormal.y &&\r\n                        normals[vertex_idx * 3 + 2] === localNormal.z &&\r\n                        uvs[vertex_idx * 2] === uv.x &&\r\n                        uvs[vertex_idx * 2 + 1] === uv.y)) {\r\n                        vertices.push(localVertex.x, localVertex.y, localVertex.z);\r\n                        uvs.push(uv.x, uv.y);\r\n                        normals.push(normal.x, normal.y, normal.z);\r\n                        vertex_idx = (<any>vertice_dict)[localVertex.x + ',' + localVertex.y + ',' + localVertex.z] = (vertices.length / 3) - 1;\r\n                    }\r\n\r\n                    indices.push(vertex_idx);\r\n\r\n                    subMesh_obj.indexStart = Math.min(currentIndex, subMesh_obj.indexStart);\r\n                    subMesh_obj.indexEnd = Math.max(currentIndex, subMesh_obj.indexEnd);\r\n                    currentIndex++;\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n        mesh.setVerticesData(VertexBuffer.PositionKind, vertices);\r\n        mesh.setVerticesData(VertexBuffer.NormalKind, normals);\r\n        mesh.setVerticesData(VertexBuffer.UVKind, uvs);\r\n        mesh.setIndices(indices, null);\r\n\r\n        if (keepSubMeshes) {\r\n            // We offset the materialIndex by the previous number of materials in the CSG mixed meshes\r\n            var materialIndexOffset = 0,\r\n                materialMaxIndex;\r\n\r\n            mesh.subMeshes = new Array<SubMesh>();\r\n\r\n            for (var m in subMesh_dict) {\r\n                materialMaxIndex = -1;\r\n                for (var sm in (<any>subMesh_dict)[m]) {\r\n                    subMesh_obj = (<any>subMesh_dict)[m][sm];\r\n                    SubMesh.CreateFromIndices(subMesh_obj.materialIndex + materialIndexOffset, subMesh_obj.indexStart, subMesh_obj.indexEnd - subMesh_obj.indexStart + 1, <AbstractMesh>mesh);\r\n                    materialMaxIndex = Math.max(subMesh_obj.materialIndex, materialMaxIndex);\r\n                }\r\n                materialIndexOffset += ++materialMaxIndex;\r\n            }\r\n        }\r\n\r\n        return mesh;\r\n    }\r\n\r\n    /**\r\n     * Build Mesh from CSG taking material and transforms into account\r\n     * @param name The name of the Mesh\r\n     * @param material The material of the Mesh\r\n     * @param scene The Scene\r\n     * @param keepSubMeshes Specifies if submeshes should be kept\r\n     * @returns The new Mesh\r\n     */\r\n    public toMesh(name: string, material: Nullable<Material> = null, scene?: Scene, keepSubMeshes?: boolean): Mesh {\r\n        var mesh = this.buildMeshGeometry(name, scene, keepSubMeshes);\r\n\r\n        mesh.material = material;\r\n\r\n        mesh.position.copyFrom(this.position);\r\n        mesh.rotation.copyFrom(this.rotation);\r\n        if (this.rotationQuaternion) {\r\n            mesh.rotationQuaternion = this.rotationQuaternion.clone();\r\n        }\r\n        mesh.scaling.copyFrom(this.scaling);\r\n        mesh.computeWorldMatrix(true);\r\n\r\n        return mesh;\r\n    }\r\n}\r\n"]}