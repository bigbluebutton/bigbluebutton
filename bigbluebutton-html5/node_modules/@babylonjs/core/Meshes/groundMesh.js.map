{"version":3,"file":"groundMesh.js","sourceRoot":"","sources":["../../../sourceES6/core/Meshes/groundMesh.ts"],"names":[],"mappings":"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","sourcesContent":["import { Scene } from \"../scene\";\r\nimport { Vector3, Vector2, TmpVectors, Vector4 } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Meshes/buffer\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\n\r\nMesh._GroundMeshParser = (parsedMesh: any, scene: Scene): Mesh => {\r\n    return GroundMesh.Parse(parsedMesh, scene);\r\n};\r\n\r\n/**\r\n * Mesh representing the gorund\r\n */\r\nexport class GroundMesh extends Mesh {\r\n    /** If octree should be generated */\r\n    public generateOctree = false;\r\n\r\n    private _heightQuads: { slope: Vector2; facet1: Vector4; facet2: Vector4 }[];\r\n\r\n    /** @hidden */\r\n    public _subdivisionsX: number;\r\n    /** @hidden */\r\n    public _subdivisionsY: number;\r\n    /** @hidden */\r\n    public _width: number;\r\n    /** @hidden */\r\n    public _height: number;\r\n    /** @hidden */\r\n    public _minX: number;\r\n    /** @hidden */\r\n    public _maxX: number;\r\n    /** @hidden */\r\n    public _minZ: number;\r\n    /** @hidden */\r\n    public _maxZ: number;\r\n\r\n    constructor(name: string, scene: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    /**\r\n     * \"GroundMesh\"\r\n     * @returns \"GroundMesh\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"GroundMesh\";\r\n    }\r\n\r\n    /**\r\n     * The minimum of x and y subdivisions\r\n     */\r\n    public get subdivisions(): number {\r\n        return Math.min(this._subdivisionsX, this._subdivisionsY);\r\n    }\r\n\r\n    /**\r\n     * X subdivisions\r\n     */\r\n    public get subdivisionsX(): number {\r\n        return this._subdivisionsX;\r\n    }\r\n\r\n    /**\r\n     * Y subdivisions\r\n     */\r\n    public get subdivisionsY(): number {\r\n        return this._subdivisionsY;\r\n    }\r\n\r\n    /**\r\n     * This function will update an octree to help to select the right submeshes for rendering, picking and collision computations.\r\n     * Please note that you must have a decent number of submeshes to get performance improvements when using an octree\r\n     * @param chunksCount the number of subdivisions for x and y\r\n     * @param octreeBlocksSize (Default: 32)\r\n     */\r\n    public optimize(chunksCount: number, octreeBlocksSize = 32): void {\r\n        this._subdivisionsX = chunksCount;\r\n        this._subdivisionsY = chunksCount;\r\n        this.subdivide(chunksCount);\r\n\r\n        // Call the octree system optimization if it is defined.\r\n        const thisAsAny = this as any;\r\n        if (thisAsAny.createOrUpdateSubmeshesOctree) {\r\n            thisAsAny.createOrUpdateSubmeshesOctree(octreeBlocksSize);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a height (y) value in the Worl system :\r\n     * the ground altitude at the coordinates (x, z) expressed in the World system.\r\n     * @param x x coordinate\r\n     * @param z z coordinate\r\n     * @returns the ground y position if (x, z) are outside the ground surface.\r\n     */\r\n    public getHeightAtCoordinates(x: number, z: number): number {\r\n        var world = this.getWorldMatrix();\r\n        var invMat = TmpVectors.Matrix[5];\r\n        world.invertToRef(invMat);\r\n        var tmpVect = TmpVectors.Vector3[8];\r\n        Vector3.TransformCoordinatesFromFloatsToRef(x, 0.0, z, invMat, tmpVect); // transform x,z in the mesh local space\r\n        x = tmpVect.x;\r\n        z = tmpVect.z;\r\n        if (x < this._minX || x > this._maxX || z < this._minZ || z > this._maxZ) {\r\n            return this.position.y;\r\n        }\r\n        if (!this._heightQuads || this._heightQuads.length == 0) {\r\n            this._initHeightQuads();\r\n            this._computeHeightQuads();\r\n        }\r\n        var facet = this._getFacetAt(x, z);\r\n        var y = -(facet.x * x + facet.z * z + facet.w) / facet.y;\r\n        // return y in the World system\r\n        Vector3.TransformCoordinatesFromFloatsToRef(0.0, y, 0.0, world, tmpVect);\r\n        return tmpVect.y;\r\n    }\r\n\r\n    /**\r\n     * Returns a normalized vector (Vector3) orthogonal to the ground\r\n     * at the ground coordinates (x, z) expressed in the World system.\r\n     * @param x x coordinate\r\n     * @param z z coordinate\r\n     * @returns Vector3(0.0, 1.0, 0.0) if (x, z) are outside the ground surface.\r\n     */\r\n    public getNormalAtCoordinates(x: number, z: number): Vector3 {\r\n        var normal = new Vector3(0.0, 1.0, 0.0);\r\n        this.getNormalAtCoordinatesToRef(x, z, normal);\r\n        return normal;\r\n    }\r\n\r\n    /**\r\n     * Updates the Vector3 passed a reference with a normalized vector orthogonal to the ground\r\n     * at the ground coordinates (x, z) expressed in the World system.\r\n     * Doesn't uptade the reference Vector3 if (x, z) are outside the ground surface.\r\n     * @param x x coordinate\r\n     * @param z z coordinate\r\n     * @param ref vector to store the result\r\n     * @returns the GroundMesh.\r\n     */\r\n    public getNormalAtCoordinatesToRef(x: number, z: number, ref: Vector3): GroundMesh {\r\n        var world = this.getWorldMatrix();\r\n        var tmpMat = TmpVectors.Matrix[5];\r\n        world.invertToRef(tmpMat);\r\n        var tmpVect = TmpVectors.Vector3[8];\r\n        Vector3.TransformCoordinatesFromFloatsToRef(x, 0.0, z, tmpMat, tmpVect); // transform x,z in the mesh local space\r\n        x = tmpVect.x;\r\n        z = tmpVect.z;\r\n        if (x < this._minX || x > this._maxX || z < this._minZ || z > this._maxZ) {\r\n            return this;\r\n        }\r\n        if (!this._heightQuads || this._heightQuads.length == 0) {\r\n            this._initHeightQuads();\r\n            this._computeHeightQuads();\r\n        }\r\n        var facet = this._getFacetAt(x, z);\r\n        Vector3.TransformNormalFromFloatsToRef(facet.x, facet.y, facet.z, world, ref);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n    * Force the heights to be recomputed for getHeightAtCoordinates() or getNormalAtCoordinates()\r\n    * if the ground has been updated.\r\n    * This can be used in the render loop.\r\n    * @returns the GroundMesh.\r\n    */\r\n    public updateCoordinateHeights(): GroundMesh {\r\n        if (!this._heightQuads || this._heightQuads.length == 0) {\r\n            this._initHeightQuads();\r\n        }\r\n        this._computeHeightQuads();\r\n        return this;\r\n    }\r\n\r\n    // Returns the element \"facet\" from the heightQuads array relative to (x, z) local coordinates\r\n    private _getFacetAt(x: number, z: number): Vector4 {\r\n        // retrieve col and row from x, z coordinates in the ground local system\r\n        var col = Math.floor((x + this._maxX) * this._subdivisionsX / this._width);\r\n        var row = Math.floor(-(z + this._maxZ) * this._subdivisionsY / this._height + this._subdivisionsY);\r\n        var quad = this._heightQuads[row * this._subdivisionsX + col];\r\n        var facet;\r\n        if (z < quad.slope.x * x + quad.slope.y) {\r\n            facet = quad.facet1;\r\n        } else {\r\n            facet = quad.facet2;\r\n        }\r\n        return facet;\r\n    }\r\n\r\n    //  Creates and populates the heightMap array with \"facet\" elements :\r\n    // a quad is two triangular facets separated by a slope, so a \"facet\" element is 1 slope + 2 facets\r\n    // slope : Vector2(c, h) = 2D diagonal line equation setting appart two triangular facets in a quad : z = cx + h\r\n    // facet1 : Vector4(a, b, c, d) = first facet 3D plane equation : ax + by + cz + d = 0\r\n    // facet2 :  Vector4(a, b, c, d) = second facet 3D plane equation : ax + by + cz + d = 0\r\n    // Returns the GroundMesh.\r\n    private _initHeightQuads(): GroundMesh {\r\n        var subdivisionsX = this._subdivisionsX;\r\n        var subdivisionsY = this._subdivisionsY;\r\n        this._heightQuads = new Array();\r\n        for (var row = 0; row < subdivisionsY; row++) {\r\n            for (var col = 0; col < subdivisionsX; col++) {\r\n                var quad = { slope: Vector2.Zero(), facet1: new Vector4(0.0, 0.0, 0.0, 0.0), facet2: new Vector4(0.0, 0.0, 0.0, 0.0) };\r\n                this._heightQuads[row * subdivisionsX + col] = quad;\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    // Compute each quad element values and update the the heightMap array :\r\n    // slope : Vector2(c, h) = 2D diagonal line equation setting appart two triangular facets in a quad : z = cx + h\r\n    // facet1 : Vector4(a, b, c, d) = first facet 3D plane equation : ax + by + cz + d = 0\r\n    // facet2 :  Vector4(a, b, c, d) = second facet 3D plane equation : ax + by + cz + d = 0\r\n    // Returns the GroundMesh.\r\n    private _computeHeightQuads(): GroundMesh {\r\n        var positions = this.getVerticesData(VertexBuffer.PositionKind);\r\n\r\n        if (!positions) {\r\n            return this;\r\n        }\r\n\r\n        var v1 = TmpVectors.Vector3[3];\r\n        var v2 = TmpVectors.Vector3[2];\r\n        var v3 = TmpVectors.Vector3[1];\r\n        var v4 = TmpVectors.Vector3[0];\r\n        var v1v2 = TmpVectors.Vector3[4];\r\n        var v1v3 = TmpVectors.Vector3[5];\r\n        var v1v4 = TmpVectors.Vector3[6];\r\n        var norm1 = TmpVectors.Vector3[7];\r\n        var norm2 = TmpVectors.Vector3[8];\r\n        var i = 0;\r\n        var j = 0;\r\n        var k = 0;\r\n        var cd = 0;     // 2D slope coefficient : z = cd * x + h\r\n        var h = 0;\r\n        var d1 = 0;     // facet plane equation : ax + by + cz + d = 0\r\n        var d2 = 0;\r\n\r\n        var subdivisionsX = this._subdivisionsX;\r\n        var subdivisionsY = this._subdivisionsY;\r\n\r\n        for (var row = 0; row < subdivisionsY; row++) {\r\n            for (var col = 0; col < subdivisionsX; col++) {\r\n                i = col * 3;\r\n                j = row * (subdivisionsX + 1) * 3;\r\n                k = (row + 1) * (subdivisionsX + 1) * 3;\r\n                v1.x = positions[j + i];\r\n                v1.y = positions[j + i + 1];\r\n                v1.z = positions[j + i + 2];\r\n                v2.x = positions[j + i + 3];\r\n                v2.y = positions[j + i + 4];\r\n                v2.z = positions[j + i + 5];\r\n                v3.x = positions[k + i];\r\n                v3.y = positions[k + i + 1];\r\n                v3.z = positions[k + i + 2];\r\n                v4.x = positions[k + i + 3];\r\n                v4.y = positions[k + i + 4];\r\n                v4.z = positions[k + i + 5];\r\n\r\n                // 2D slope V1V4\r\n                cd = (v4.z - v1.z) / (v4.x - v1.x);\r\n                h = v1.z - cd * v1.x;             // v1 belongs to the slope\r\n\r\n                // facet equations :\r\n                // we compute each facet normal vector\r\n                // the equation of the facet plane is : norm.x * x + norm.y * y + norm.z * z + d = 0\r\n                // we compute the value d by applying the equation to v1 which belongs to the plane\r\n                // then we store the facet equation in a Vector4\r\n                v2.subtractToRef(v1, v1v2);\r\n                v3.subtractToRef(v1, v1v3);\r\n                v4.subtractToRef(v1, v1v4);\r\n                Vector3.CrossToRef(v1v4, v1v3, norm1);  // caution : CrossToRef uses the Tmp class\r\n                Vector3.CrossToRef(v1v2, v1v4, norm2);\r\n                norm1.normalize();\r\n                norm2.normalize();\r\n                d1 = -(norm1.x * v1.x + norm1.y * v1.y + norm1.z * v1.z);\r\n                d2 = -(norm2.x * v2.x + norm2.y * v2.y + norm2.z * v2.z);\r\n\r\n                var quad = this._heightQuads[row * subdivisionsX + col];\r\n                quad.slope.copyFromFloats(cd, h);\r\n                quad.facet1.copyFromFloats(norm1.x, norm1.y, norm1.z, d1);\r\n                quad.facet2.copyFromFloats(norm2.x, norm2.y, norm2.z, d2);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Serializes this ground mesh\r\n     * @param serializationObject object to write serialization to\r\n     */\r\n    public serialize(serializationObject: any): void {\r\n        super.serialize(serializationObject);\r\n        serializationObject.subdivisionsX = this._subdivisionsX;\r\n        serializationObject.subdivisionsY = this._subdivisionsY;\r\n\r\n        serializationObject.minX = this._minX;\r\n        serializationObject.maxX = this._maxX;\r\n\r\n        serializationObject.minZ = this._minZ;\r\n        serializationObject.maxZ = this._maxZ;\r\n\r\n        serializationObject.width = this._width;\r\n        serializationObject.height = this._height;\r\n    }\r\n\r\n    /**\r\n     * Parses a serialized ground mesh\r\n     * @param parsedMesh the serialized mesh\r\n     * @param scene the scene to create the ground mesh in\r\n     * @returns the created ground mesh\r\n     */\r\n    public static Parse(parsedMesh: any, scene: Scene): GroundMesh {\r\n        var result = new GroundMesh(parsedMesh.name, scene);\r\n\r\n        result._subdivisionsX = parsedMesh.subdivisionsX || 1;\r\n        result._subdivisionsY = parsedMesh.subdivisionsY || 1;\r\n\r\n        result._minX = parsedMesh.minX;\r\n        result._maxX = parsedMesh.maxX;\r\n\r\n        result._minZ = parsedMesh.minZ;\r\n        result._maxZ = parsedMesh.maxZ;\r\n\r\n        result._width = parsedMesh.width;\r\n        result._height = parsedMesh.height;\r\n\r\n        return result;\r\n    }\r\n}\r\n"]}