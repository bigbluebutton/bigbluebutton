{"version":3,"file":"polygonBuilder.js","sourceRoot":"","sources":["../../../../sourceES6/core/Meshes/Builders/polygonBuilder.ts"],"names":[],"mappings":"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","sourcesContent":["import { Scene } from \"../../scene\";\r\nimport { Vector3, Vector2, Vector4 } from \"../../Maths/math.vector\";\r\nimport { Color4 } from '../../Maths/math.color';\r\nimport { Mesh, _CreationDataStorage } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { PolygonMeshBuilder } from \"../polygonMesh\";\r\nimport { FloatArray, IndicesArray, Nullable } from \"../../types\";\r\nimport { VertexBuffer } from \"../../Meshes/buffer\";\r\nimport { EngineStore } from '../../Engines/engineStore';\r\n\r\ndeclare var earcut: any;\r\n\r\nVertexData.CreatePolygon = function(polygon: Mesh, sideOrientation: number, fUV?: Vector4[], fColors?: Color4[], frontUVs?: Vector4, backUVs?: Vector4) {\r\n    var faceUV: Vector4[] = fUV || new Array<Vector4>(3);\r\n    var faceColors = fColors;\r\n    var colors = [];\r\n\r\n    // default face colors and UV if undefined\r\n    for (var f = 0; f < 3; f++) {\r\n        if (faceUV[f] === undefined) {\r\n            faceUV[f] = new Vector4(0, 0, 1, 1);\r\n        }\r\n        if (faceColors && faceColors[f] === undefined) {\r\n            faceColors[f] = new Color4(1, 1, 1, 1);\r\n        }\r\n    }\r\n\r\n    var positions = <FloatArray>polygon.getVerticesData(VertexBuffer.PositionKind);\r\n    var normals = <FloatArray>polygon.getVerticesData(VertexBuffer.NormalKind);\r\n    var uvs = <FloatArray>polygon.getVerticesData(VertexBuffer.UVKind);\r\n    var indices = <IndicesArray>polygon.getIndices();\r\n\r\n    // set face colours and textures\r\n    var idx: number = 0;\r\n    var face: number = 0;\r\n    for (var index = 0; index < normals.length; index += 3) {\r\n        //Edge Face  no. 1\r\n        if (Math.abs(normals[index + 1]) < 0.001) {\r\n            face = 1;\r\n        }\r\n        //Top Face  no. 0\r\n        if (Math.abs(normals[index + 1] - 1) < 0.001) {\r\n            face = 0;\r\n        }\r\n        //Bottom Face  no. 2\r\n        if (Math.abs(normals[index + 1] + 1) < 0.001) {\r\n            face = 2;\r\n        }\r\n        idx = index / 3;\r\n        uvs[2 * idx] = (1 - uvs[2 * idx]) * faceUV[face].x + uvs[2 * idx] * faceUV[face].z;\r\n        uvs[2 * idx + 1] = (1 - uvs[2 * idx + 1]) * faceUV[face].y + uvs[2 * idx + 1] * faceUV[face].w;\r\n        if (faceColors) {\r\n            colors.push(faceColors[face].r, faceColors[face].g, faceColors[face].b, faceColors[face].a);\r\n        }\r\n    }\r\n\r\n    // sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, frontUVs, backUVs);\r\n\r\n    // Result\r\n    var vertexData = new VertexData();\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    if (faceColors) {\r\n        var totalColors = (sideOrientation === VertexData.DOUBLESIDE) ? colors.concat(colors) : colors;\r\n        vertexData.colors = totalColors;\r\n    }\r\n\r\n    return vertexData;\r\n};\r\n\r\nMesh.CreatePolygon = (name: string, shape: Vector3[], scene: Scene, holes?: Vector3[][], updatable?: boolean, sideOrientation?: number, earcutInjection = earcut): Mesh => {\r\n    var options = {\r\n        shape: shape,\r\n        holes: holes,\r\n        updatable: updatable,\r\n        sideOrientation: sideOrientation\r\n    };\r\n    return PolygonBuilder.CreatePolygon(name, options, scene, earcutInjection);\r\n};\r\n\r\nMesh.ExtrudePolygon = (name: string, shape: Vector3[], depth: number, scene: Scene, holes?: Vector3[][], updatable?: boolean, sideOrientation?: number, earcutInjection = earcut): Mesh => {\r\n    var options = {\r\n        shape: shape,\r\n        holes: holes,\r\n        depth: depth,\r\n        updatable: updatable,\r\n        sideOrientation: sideOrientation\r\n    };\r\n    return PolygonBuilder.ExtrudePolygon(name, options, scene, earcutInjection);\r\n};\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\r\nexport class PolygonBuilder {\r\n    /**\r\n     * Creates a polygon mesh\r\n     * The polygon's shape will depend on the input parameters and is constructed parallel to a ground mesh\r\n     * * The parameter `shape` is a required array of successive Vector3 representing the corners of the polygon in th XoZ plane, that is y = 0 for all vectors\r\n     * * You can set the mesh side orientation with the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4)\r\n     * * Remember you can only change the shape positions, not their number when updating a polygon\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @param earcutInjection can be used to inject your own earcut reference\r\n     * @returns the polygon mesh\r\n     */\r\n    public static CreatePolygon(name: string, options: { shape: Vector3[], holes?: Vector3[][], depth?: number, faceUV?: Vector4[], faceColors?: Color4[], updatable?: boolean, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4, }, scene: Nullable<Scene> = null, earcutInjection = earcut): Mesh {\r\n        options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n        var shape = options.shape;\r\n        var holes = options.holes || [];\r\n        var depth = options.depth || 0;\r\n        var contours: Array<Vector2> = [];\r\n        var hole: Array<Vector2> = [];\r\n\r\n        for (var i = 0; i < shape.length; i++) {\r\n            contours[i] = new Vector2(shape[i].x, shape[i].z);\r\n        }\r\n        var epsilon = 0.00000001;\r\n        if (contours[0].equalsWithEpsilon(contours[contours.length - 1], epsilon)) {\r\n            contours.pop();\r\n        }\r\n\r\n        var polygonTriangulation = new PolygonMeshBuilder(name, contours, scene || EngineStore.LastCreatedScene!, earcutInjection);\r\n        for (var hNb = 0; hNb < holes.length; hNb++) {\r\n            hole = [];\r\n            for (var hPoint = 0; hPoint < holes[hNb].length; hPoint++) {\r\n                hole.push(new Vector2(holes[hNb][hPoint].x, holes[hNb][hPoint].z));\r\n            }\r\n            polygonTriangulation.addHole(hole);\r\n        }\r\n        var polygon = polygonTriangulation.build(options.updatable, depth);\r\n        polygon._originalBuilderSideOrientation = options.sideOrientation;\r\n        var vertexData = VertexData.CreatePolygon(polygon, options.sideOrientation, options.faceUV, options.faceColors, options.frontUVs, options.backUVs);\r\n        vertexData.applyToMesh(polygon, options.updatable);\r\n\r\n        return polygon;\r\n    }\r\n\r\n    /**\r\n     * Creates an extruded polygon mesh, with depth in the Y direction.\r\n     * * You can set different colors and different images to the top, bottom and extruded side by using the parameters `faceColors` (an array of 3 Color3 elements) and `faceUV` (an array of 3 Vector4 elements)\r\n     * @see https://doc.babylonjs.com/how_to/createbox_per_face_textures_and_colors\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @param earcutInjection can be used to inject your own earcut reference\r\n     * @returns the polygon mesh\r\n     */\r\n    public static ExtrudePolygon(name: string, options: { shape: Vector3[], holes?: Vector3[][], depth?: number, faceUV?: Vector4[], faceColors?: Color4[], updatable?: boolean, sideOrientation?: number, frontUVs?: Vector4, backUVs?: Vector4 }, scene: Nullable<Scene> = null, earcutInjection = earcut): Mesh {\r\n        return PolygonBuilder.CreatePolygon(name, options, scene, earcutInjection);\r\n    }\r\n}"]}