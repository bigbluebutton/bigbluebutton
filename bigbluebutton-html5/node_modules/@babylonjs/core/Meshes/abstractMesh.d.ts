import { Observable } from "../Misc/observable";
import { Nullable, FloatArray, IndicesArray, DeepImmutable } from "../types";
import { Camera } from "../Cameras/camera";
import { Scene, IDisposable } from "../scene";
import { Matrix, Vector3, Vector2 } from "../Maths/math.vector";
import { Node } from "../node";
import { IGetSetVerticesData } from "../Meshes/mesh.vertexData";
import { TransformNode } from "../Meshes/transformNode";
import { SubMesh } from "../Meshes/subMesh";
import { PickingInfo } from "../Collisions/pickingInfo";
import { ICullable, BoundingInfo } from "../Culling/boundingInfo";
import { Material } from "../Materials/material";
import { Light } from "../Lights/light";
import { Skeleton } from "../Bones/skeleton";
import { IEdgesRenderer } from "../Rendering/edgesRenderer";
import { SolidParticle } from "../Particles/solidParticle";
import { AbstractActionManager } from '../Actions/abstractActionManager';
import { RawTexture } from '../Materials/Textures/rawTexture';
import { Color3, Color4 } from '../Maths/math.color';
import { Plane } from '../Maths/math.plane';
declare type Ray = import("../Culling/ray").Ray;
declare type Collider = import("../Collisions/collider").Collider;
declare type TrianglePickingPredicate = import("../Culling/ray").TrianglePickingPredicate;
declare type RenderingGroup = import("../Rendering/renderingGroup").RenderingGroup;
/** @hidden */
declare class _FacetDataStorage {
    facetPositions: Vector3[];
    facetNormals: Vector3[];
    facetPartitioning: number[][];
    facetNb: number;
    partitioningSubdivisions: number;
    partitioningBBoxRatio: number;
    facetDataEnabled: boolean;
    facetParameters: any;
    bbSize: Vector3;
    subDiv: {
        max: number;
        X: number;
        Y: number;
        Z: number;
    };
    facetDepthSort: boolean;
    facetDepthSortEnabled: boolean;
    depthSortedIndices: IndicesArray;
    depthSortedFacets: {
        ind: number;
        sqDistance: number;
    }[];
    facetDepthSortFunction: (f1: {
        ind: number;
        sqDistance: number;
    }, f2: {
        ind: number;
        sqDistance: number;
    }) => number;
    facetDepthSortFrom: Vector3;
    facetDepthSortOrigin: Vector3;
    invertedMatrix: Matrix;
}
/**
 * @hidden
 **/
declare class _InternalAbstractMeshDataInfo {
    _hasVertexAlpha: boolean;
    _useVertexColors: boolean;
    _numBoneInfluencers: number;
    _applyFog: boolean;
    _receiveShadows: boolean;
    _facetData: _FacetDataStorage;
    _visibility: number;
    _skeleton: Nullable<Skeleton>;
    _layerMask: number;
    _computeBonesUsingShaders: boolean;
    _isActive: boolean;
    _onlyForInstances: boolean;
    _isActiveIntermediate: boolean;
    _onlyForInstancesIntermediate: boolean;
    _actAsRegularMesh: boolean;
}
/**
 * Class used to store all common mesh properties
 */
export declare class AbstractMesh extends TransformNode implements IDisposable, ICullable, IGetSetVerticesData {
    /** No occlusion */
    static OCCLUSION_TYPE_NONE: number;
    /** Occlusion set to optimisitic */
    static OCCLUSION_TYPE_OPTIMISTIC: number;
    /** Occlusion set to strict */
    static OCCLUSION_TYPE_STRICT: number;
    /** Use an accurante occlusion algorithm */
    static OCCLUSION_ALGORITHM_TYPE_ACCURATE: number;
    /** Use a conservative occlusion algorithm */
    static OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE: number;
    /** Default culling strategy : this is an exclusion test and it's the more accurate.
     *  Test order :
     *  Is the bounding sphere outside the frustum ?
     *  If not, are the bounding box vertices outside the frustum ?
     *  It not, then the cullable object is in the frustum.
     */
    static readonly CULLINGSTRATEGY_STANDARD = 0;
    /** Culling strategy : Bounding Sphere Only.
     *  This is an exclusion test. It's faster than the standard strategy because the bounding box is not tested.
     *  It's also less accurate than the standard because some not visible objects can still be selected.
     *  Test : is the bounding sphere outside the frustum ?
     *  If not, then the cullable object is in the frustum.
     */
    static readonly CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY = 1;
    /** Culling strategy : Optimistic Inclusion.
     *  This in an inclusion test first, then the standard exclusion test.
     *  This can be faster when a cullable object is expected to be almost always in the camera frustum.
     *  This could also be a little slower than the standard test when the tested object center is not the frustum but one of its bounding box vertex is still inside.
     *  Anyway, it's as accurate as the standard strategy.
     *  Test :
     *  Is the cullable object bounding sphere center in the frustum ?
     *  If not, apply the default culling strategy.
     */
    static readonly CULLINGSTRATEGY_OPTIMISTIC_INCLUSION = 2;
    /** Culling strategy : Optimistic Inclusion then Bounding Sphere Only.
     *  This in an inclusion test first, then the bounding sphere only exclusion test.
     *  This can be the fastest test when a cullable object is expected to be almost always in the camera frustum.
     *  This could also be a little slower than the BoundingSphereOnly strategy when the tested object center is not in the frustum but its bounding sphere still intersects it.
     *  It's less accurate than the standard strategy and as accurate as the BoundingSphereOnly strategy.
     *  Test :
     *  Is the cullable object bounding sphere center in the frustum ?
     *  If not, apply the Bounding Sphere Only strategy. No Bounding Box is tested here.
     */
    static readonly CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY = 3;
    /**
     * No billboard
     */
    static get BILLBOARDMODE_NONE(): number;
    /** Billboard on X axis */
    static get BILLBOARDMODE_X(): number;
    /** Billboard on Y axis */
    static get BILLBOARDMODE_Y(): number;
    /** Billboard on Z axis */
    static get BILLBOARDMODE_Z(): number;
    /** Billboard on all axes */
    static get BILLBOARDMODE_ALL(): number;
    /** Billboard on using position instead of orientation */
    static get BILLBOARDMODE_USE_POSITION(): number;
    /** @hidden */
    _internalAbstractMeshDataInfo: _InternalAbstractMeshDataInfo;
    /**
     * The culling strategy to use to check whether the mesh must be rendered or not.
     * This value can be changed at any time and will be used on the next render mesh selection.
     * The possible values are :
     * - AbstractMesh.CULLINGSTRATEGY_STANDARD
     * - AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY
     * - AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION
     * - AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY
     * Please read each static variable documentation to get details about the culling process.
     * */
    cullingStrategy: number;
    /**
     * Gets the number of facets in the mesh
     * @see http://doc.babylonjs.com/how_to/how_to_use_facetdata#what-is-a-mesh-facet
     */
    get facetNb(): number;
    /**
     * Gets or set the number (integer) of subdivisions per axis in the partioning space
     * @see http://doc.babylonjs.com/how_to/how_to_use_facetdata#tweaking-the-partitioning
     */
    get partitioningSubdivisions(): number;
    set partitioningSubdivisions(nb: number);
    /**
     * The ratio (float) to apply to the bouding box size to set to the partioning space.
     * Ex : 1.01 (default) the partioning space is 1% bigger than the bounding box
     * @see http://doc.babylonjs.com/how_to/how_to_use_facetdata#tweaking-the-partitioning
     */
    get partitioningBBoxRatio(): number;
    set partitioningBBoxRatio(ratio: number);
    /**
     * Gets or sets a boolean indicating that the facets must be depth sorted on next call to `updateFacetData()`.
     * Works only for updatable meshes.
     * Doesn't work with multi-materials
     * @see http://doc.babylonjs.com/how_to/how_to_use_facetdata#facet-depth-sort
     */
    get mustDepthSortFacets(): boolean;
    set mustDepthSortFacets(sort: boolean);
    /**
     * The location (Vector3) where the facet depth sort must be computed from.
     * By default, the active camera position.
     * Used only when facet depth sort is enabled
     * @see http://doc.babylonjs.com/how_to/how_to_use_facetdata#facet-depth-sort
     */
    get facetDepthSortFrom(): Vector3;
    set facetDepthSortFrom(location: Vector3);
    /**
     * gets a boolean indicating if facetData is enabled
     * @see http://doc.babylonjs.com/how_to/how_to_use_facetdata#what-is-a-mesh-facet
     */
    get isFacetDataEnabled(): boolean;
    /** @hidden */
    _updateNonUniformScalingState(value: boolean): boolean;
    /**
    * An event triggered when this mesh collides with another one
    */
    onCollideObservable: Observable<AbstractMesh>;
    /** Set a function to call when this mesh collides with another one */
    set onCollide(callback: () => void);
    /**
    * An event triggered when the collision's position changes
    */
    onCollisionPositionChangeObservable: Observable<Vector3>;
    /** Set a function to call when the collision's position changes */
    set onCollisionPositionChange(callback: () => void);
    /**
    * An event triggered when material is changed
    */
    onMaterialChangedObservable: Observable<AbstractMesh>;
    /**
     * Gets or sets the orientation for POV movement & rotation
     */
    definedFacingForward: boolean;
    /** @hidden */
    _occlusionQuery: Nullable<WebGLQuery>;
    /** @hidden */
    _renderingGroup: Nullable<RenderingGroup>;
    /**
     * Gets or sets mesh visibility between 0 and 1 (default is 1)
     */
    get visibility(): number;
    /**
     * Gets or sets mesh visibility between 0 and 1 (default is 1)
     */
    set visibility(value: number);
    /** Gets or sets the alpha index used to sort transparent meshes
     * @see http://doc.babylonjs.com/resources/transparency_and_how_meshes_are_rendered#alpha-index
     */
    alphaIndex: number;
    /**
     * Gets or sets a boolean indicating if the mesh is visible (renderable). Default is true
     */
    isVisible: boolean;
    /**
     * Gets or sets a boolean indicating if the mesh can be picked (by scene.pick for instance or through actions). Default is true
     */
    isPickable: boolean;
    /** Gets or sets a boolean indicating that bounding boxes of subMeshes must be rendered as well (false by default) */
    showSubMeshesBoundingBox: boolean;
    /** Gets or sets a boolean indicating if the mesh must be considered as a ray blocker for lens flares (false by default)
     * @see http://doc.babylonjs.com/how_to/how_to_use_lens_flares
     */
    isBlocker: boolean;
    /**
     * Gets or sets a boolean indicating that pointer move events must be supported on this mesh (false by default)
     */
    enablePointerMoveEvents: boolean;
    /**
     * Specifies the rendering group id for this mesh (0 by default)
     * @see http://doc.babylonjs.com/resources/transparency_and_how_meshes_are_rendered#rendering-groups
     */
    renderingGroupId: number;
    private _material;
    /** Gets or sets current material */
    get material(): Nullable<Material>;
    set material(value: Nullable<Material>);
    /**
     * Gets or sets a boolean indicating that this mesh can receive realtime shadows
     * @see http://doc.babylonjs.com/babylon101/shadows
     */
    get receiveShadows(): boolean;
    set receiveShadows(value: boolean);
    /** Defines color to use when rendering outline */
    outlineColor: Color3;
    /** Define width to use when rendering outline */
    outlineWidth: number;
    /** Defines color to use when rendering overlay */
    overlayColor: Color3;
    /** Defines alpha to use when rendering overlay */
    overlayAlpha: number;
    /** Gets or sets a boolean indicating that this mesh contains vertex color data with alpha values */
    get hasVertexAlpha(): boolean;
    set hasVertexAlpha(value: boolean);
    /** Gets or sets a boolean indicating that this mesh needs to use vertex color data to render (if this kind of vertex data is available in the geometry) */
    get useVertexColors(): boolean;
    set useVertexColors(value: boolean);
    /**
     * Gets or sets a boolean indicating that bone animations must be computed by the CPU (false by default)
     */
    get computeBonesUsingShaders(): boolean;
    set computeBonesUsingShaders(value: boolean);
    /** Gets or sets the number of allowed bone influences per vertex (4 by default) */
    get numBoneInfluencers(): number;
    set numBoneInfluencers(value: number);
    /** Gets or sets a boolean indicating that this mesh will allow fog to be rendered on it (true by default) */
    get applyFog(): boolean;
    set applyFog(value: boolean);
    /** Gets or sets a boolean indicating that internal octree (if available) can be used to boost submeshes selection (true by default) */
    useOctreeForRenderingSelection: boolean;
    /** Gets or sets a boolean indicating that internal octree (if available) can be used to boost submeshes picking (true by default) */
    useOctreeForPicking: boolean;
    /** Gets or sets a boolean indicating that internal octree (if available) can be used to boost submeshes collision (true by default) */
    useOctreeForCollisions: boolean;
    /**
     * Gets or sets the current layer mask (default is 0x0FFFFFFF)
     * @see http://doc.babylonjs.com/how_to/layermasks_and_multi-cam_textures
     */
    get layerMask(): number;
    set layerMask(value: number);
    /**
     * True if the mesh must be rendered in any case (this will shortcut the frustum clipping phase)
     */
    alwaysSelectAsActiveMesh: boolean;
    /**
     * Gets or sets a boolean indicating that the bounding info does not need to be kept in sync (for performance reason)
     */
    doNotSyncBoundingInfo: boolean;
    /**
     * Gets or sets the current action manager
     * @see http://doc.babylonjs.com/how_to/how_to_use_actions
     */
    actionManager: Nullable<AbstractActionManager>;
    private _meshCollisionData;
    /**
     * Gets or sets the ellipsoid used to impersonate this mesh when using collision engine (default is (0.5, 1, 0.5))
     * @see http://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity
     */
    ellipsoid: Vector3;
    /**
     * Gets or sets the ellipsoid offset used to impersonate this mesh when using collision engine (default is (0, 0, 0))
     * @see http://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity
     */
    ellipsoidOffset: Vector3;
    /**
     * Gets or sets a collision mask used to mask collisions (default is -1).
     * A collision between A and B will happen if A.collisionGroup & b.collisionMask !== 0
     */
    get collisionMask(): number;
    set collisionMask(mask: number);
    /**
     * Gets or sets the current collision group mask (-1 by default).
     * A collision between A and B will happen if A.collisionGroup & b.collisionMask !== 0
     */
    get collisionGroup(): number;
    set collisionGroup(mask: number);
    /**
     * Defines edge width used when edgesRenderer is enabled
     * @see https://www.babylonjs-playground.com/#10OJSG#13
     */
    edgesWidth: number;
    /**
     * Defines edge color used when edgesRenderer is enabled
     * @see https://www.babylonjs-playground.com/#10OJSG#13
     */
    edgesColor: Color4;
    /** @hidden */
    _edgesRenderer: Nullable<IEdgesRenderer>;
    /** @hidden */
    _masterMesh: Nullable<AbstractMesh>;
    /** @hidden */
    _boundingInfo: Nullable<BoundingInfo>;
    /** @hidden */
    _renderId: number;
    /**
     * Gets or sets the list of subMeshes
     * @see http://doc.babylonjs.com/how_to/multi_materials
     */
    subMeshes: SubMesh[];
    /** @hidden */
    _intersectionsInProgress: AbstractMesh[];
    /** @hidden */
    _unIndexed: boolean;
    /** @hidden */
    _lightSources: Light[];
    /** Gets the list of lights affecting that mesh */
    get lightSources(): Light[];
    /** @hidden */
    get _positions(): Nullable<Vector3[]>;
    /** @hidden */
    _waitingData: {
        lods: Nullable<any>;
        actions: Nullable<any>;
        freezeWorldMatrix: Nullable<boolean>;
    };
    /** @hidden */
    _bonesTransformMatrices: Nullable<Float32Array>;
    /** @hidden */
    _transformMatrixTexture: Nullable<RawTexture>;
    /**
     * Gets or sets a skeleton to apply skining transformations
     * @see http://doc.babylonjs.com/how_to/how_to_use_bones_and_skeletons
     */
    set skeleton(value: Nullable<Skeleton>);
    get skeleton(): Nullable<Skeleton>;
    /**
     * An event triggered when the mesh is rebuilt.
     */
    onRebuildObservable: Observable<AbstractMesh>;
    /**
     * Creates a new AbstractMesh
     * @param name defines the name of the mesh
     * @param scene defines the hosting scene
     */
    constructor(name: string, scene?: Nullable<Scene>);
    /**
     * Returns the string "AbstractMesh"
     * @returns "AbstractMesh"
     */
    getClassName(): string;
    /**
     * Gets a string representation of the current mesh
     * @param fullDetails defines a boolean indicating if full details must be included
     * @returns a string representation of the current mesh
     */
    toString(fullDetails?: boolean): string;
    /**
     * @hidden
     */
    protected _getEffectiveParent(): Nullable<Node>;
    /** @hidden */
    _getActionManagerForTrigger(trigger?: number, initialCall?: boolean): Nullable<AbstractActionManager>;
    /** @hidden */
    _rebuild(): void;
    /** @hidden */
    _resyncLightSources(): void;
    /** @hidden */
    _resyncLightSource(light: Light): void;
    /** @hidden */
    _unBindEffect(): void;
    /** @hidden */
    _removeLightSource(light: Light, dispose: boolean): void;
    private _markSubMeshesAsDirty;
    /** @hidden */
    _markSubMeshesAsLightDirty(dispose?: boolean): void;
    /** @hidden */
    _markSubMeshesAsAttributesDirty(): void;
    /** @hidden */
    _markSubMeshesAsMiscDirty(): void;
    /**
    * Gets or sets a Vector3 depicting the mesh scaling along each local axis X, Y, Z.  Default is (1.0, 1.0, 1.0)
    */
    get scaling(): Vector3;
    set scaling(newScaling: Vector3);
    /**
     * Returns true if the mesh is blocked. Implemented by child classes
     */
    get isBlocked(): boolean;
    /**
     * Returns the mesh itself by default. Implemented by child classes
     * @param camera defines the camera to use to pick the right LOD level
     * @returns the currentAbstractMesh
     */
    getLOD(camera: Camera): Nullable<AbstractMesh>;
    /**
     * Returns 0 by default. Implemented by child classes
     * @returns an integer
     */
    getTotalVertices(): number;
    /**
     * Returns a positive integer : the total number of indices in this mesh geometry.
     * @returns the numner of indices or zero if the mesh has no geometry.
     */
    getTotalIndices(): number;
    /**
     * Returns null by default. Implemented by child classes
     * @returns null
     */
    getIndices(): Nullable<IndicesArray>;
    /**
     * Returns the array of the requested vertex data kind. Implemented by child classes
     * @param kind defines the vertex data kind to use
     * @returns null
     */
    getVerticesData(kind: string): Nullable<FloatArray>;
    /**
     * Sets the vertex data of the mesh geometry for the requested `kind`.
     * If the mesh has no geometry, a new Geometry object is set to the mesh and then passed this vertex data.
     * Note that a new underlying VertexBuffer object is created each call.
     * If the `kind` is the `PositionKind`, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.
     * @param kind defines vertex data kind:
     * * VertexBuffer.PositionKind
     * * VertexBuffer.UVKind
     * * VertexBuffer.UV2Kind
     * * VertexBuffer.UV3Kind
     * * VertexBuffer.UV4Kind
     * * VertexBuffer.UV5Kind
     * * VertexBuffer.UV6Kind
     * * VertexBuffer.ColorKind
     * * VertexBuffer.MatricesIndicesKind
     * * VertexBuffer.MatricesIndicesExtraKind
     * * VertexBuffer.MatricesWeightsKind
     * * VertexBuffer.MatricesWeightsExtraKind
     * @param data defines the data source
     * @param updatable defines if the data must be flagged as updatable (or static)
     * @param stride defines the vertex stride (size of an entire vertex). Can be null and in this case will be deduced from vertex data kind
     * @returns the current mesh
     */
    setVerticesData(kind: string, data: FloatArray, updatable?: boolean, stride?: number): AbstractMesh;
    /**
     * Updates the existing vertex data of the mesh geometry for the requested `kind`.
     * If the mesh has no geometry, it is simply returned as it is.
     * @param kind defines vertex data kind:
     * * VertexBuffer.PositionKind
     * * VertexBuffer.UVKind
     * * VertexBuffer.UV2Kind
     * * VertexBuffer.UV3Kind
     * * VertexBuffer.UV4Kind
     * * VertexBuffer.UV5Kind
     * * VertexBuffer.UV6Kind
     * * VertexBuffer.ColorKind
     * * VertexBuffer.MatricesIndicesKind
     * * VertexBuffer.MatricesIndicesExtraKind
     * * VertexBuffer.MatricesWeightsKind
     * * VertexBuffer.MatricesWeightsExtraKind
     * @param data defines the data source
     * @param updateExtends If `kind` is `PositionKind` and if `updateExtends` is true, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed
     * @param makeItUnique If true, a new global geometry is created from this data and is set to the mesh
     * @returns the current mesh
     */
    updateVerticesData(kind: string, data: FloatArray, updateExtends?: boolean, makeItUnique?: boolean): AbstractMesh;
    /**
     * Sets the mesh indices,
     * If the mesh has no geometry, a new Geometry object is created and set to the mesh.
     * @param indices Expects an array populated with integers or a typed array (Int32Array, Uint32Array, Uint16Array)
     * @param totalVertices Defines the total number of vertices
     * @returns the current mesh
     */
    setIndices(indices: IndicesArray, totalVertices: Nullable<number>): AbstractMesh;
    /**
     * Gets a boolean indicating if specific vertex data is present
     * @param kind defines the vertex data kind to use
     * @returns true is data kind is present
     */
    isVerticesDataPresent(kind: string): boolean;
    /**
     * Returns the mesh BoundingInfo object or creates a new one and returns if it was undefined.
     * Note that it returns a shallow bounding of the mesh (i.e. it does not include children).
     * To get the full bounding of all children, call `getHierarchyBoundingVectors` instead.
     * @returns a BoundingInfo
     */
    getBoundingInfo(): BoundingInfo;
    /**
     * Uniformly scales the mesh to fit inside of a unit cube (1 X 1 X 1 units)
     * @param includeDescendants Use the hierarchy's bounding box instead of the mesh's bounding box. Default is false
     * @param ignoreRotation ignore rotation when computing the scale (ie. object will be axis aligned). Default is false
     * @param predicate predicate that is passed in to getHierarchyBoundingVectors when selecting which object should be included when scaling
     * @returns the current mesh
     */
    normalizeToUnitCube(includeDescendants?: boolean, ignoreRotation?: boolean, predicate?: Nullable<(node: AbstractMesh) => boolean>): AbstractMesh;
    /**
     * Overwrite the current bounding info
     * @param boundingInfo defines the new bounding info
     * @returns the current mesh
     */
    setBoundingInfo(boundingInfo: BoundingInfo): AbstractMesh;
    /** Gets a boolean indicating if this mesh has skinning data and an attached skeleton */
    get useBones(): boolean;
    /** @hidden */
    _preActivate(): void;
    /** @hidden */
    _preActivateForIntermediateRendering(renderId: number): void;
    /** @hidden */
    _activate(renderId: number, intermediateRendering: boolean): boolean;
    /** @hidden */
    _postActivate(): void;
    /** @hidden */
    _freeze(): void;
    /** @hidden */
    _unFreeze(): void;
    /**
     * Gets the current world matrix
     * @returns a Matrix
     */
    getWorldMatrix(): Matrix;
    /** @hidden */
    _getWorldMatrixDeterminant(): number;
    /**
     * Gets a boolean indicating if this mesh is an instance or a regular mesh
     */
    get isAnInstance(): boolean;
    /**
     * Gets a boolean indicating if this mesh has instances
     */
    get hasInstances(): boolean;
    /**
     * Perform relative position change from the point of view of behind the front of the mesh.
     * This is performed taking into account the meshes current rotation, so you do not have to care.
     * Supports definition of mesh facing forward or backward
     * @param amountRight defines the distance on the right axis
     * @param amountUp defines the distance on the up axis
     * @param amountForward defines the distance on the forward axis
     * @returns the current mesh
     */
    movePOV(amountRight: number, amountUp: number, amountForward: number): AbstractMesh;
    /**
     * Calculate relative position change from the point of view of behind the front of the mesh.
     * This is performed taking into account the meshes current rotation, so you do not have to care.
     * Supports definition of mesh facing forward or backward
     * @param amountRight defines the distance on the right axis
     * @param amountUp defines the distance on the up axis
     * @param amountForward defines the distance on the forward axis
     * @returns the new displacement vector
     */
    calcMovePOV(amountRight: number, amountUp: number, amountForward: number): Vector3;
    /**
     * Perform relative rotation change from the point of view of behind the front of the mesh.
     * Supports definition of mesh facing forward or backward
     * @param flipBack defines the flip
     * @param twirlClockwise defines the twirl
     * @param tiltRight defines the tilt
     * @returns the current mesh
     */
    rotatePOV(flipBack: number, twirlClockwise: number, tiltRight: number): AbstractMesh;
    /**
     * Calculate relative rotation change from the point of view of behind the front of the mesh.
     * Supports definition of mesh facing forward or backward.
     * @param flipBack defines the flip
     * @param twirlClockwise defines the twirl
     * @param tiltRight defines the tilt
     * @returns the new rotation vector
     */
    calcRotatePOV(flipBack: number, twirlClockwise: number, tiltRight: number): Vector3;
    /**
     * This method recomputes and sets a new BoundingInfo to the mesh unless it is locked.
     * This means the mesh underlying bounding box and sphere are recomputed.
     * @param applySkeleton defines whether to apply the skeleton before computing the bounding info
     * @returns the current mesh
     */
    refreshBoundingInfo(applySkeleton?: boolean): AbstractMesh;
    /** @hidden */
    _refreshBoundingInfo(data: Nullable<FloatArray>, bias: Nullable<Vector2>): void;
    /** @hidden */
    _getPositionData(applySkeleton: boolean): Nullable<FloatArray>;
    /** @hidden */
    _updateBoundingInfo(): AbstractMesh;
    /** @hidden */
    _updateSubMeshesBoundingInfo(matrix: DeepImmutable<Matrix>): AbstractMesh;
    /** @hidden */
    protected _afterComputeWorldMatrix(): void;
    /** @hidden */
    get _effectiveMesh(): AbstractMesh;
    /**
     * Returns `true` if the mesh is within the frustum defined by the passed array of planes.
     * A mesh is in the frustum if its bounding box intersects the frustum
     * @param frustumPlanes defines the frustum to test
     * @returns true if the mesh is in the frustum planes
     */
    isInFrustum(frustumPlanes: Plane[]): boolean;
    /**
     * Returns `true` if the mesh is completely in the frustum defined be the passed array of planes.
     * A mesh is completely in the frustum if its bounding box it completely inside the frustum.
     * @param frustumPlanes defines the frustum to test
     * @returns true if the mesh is completely in the frustum planes
     */
    isCompletelyInFrustum(frustumPlanes: Plane[]): boolean;
    /**
     * True if the mesh intersects another mesh or a SolidParticle object
     * @param mesh defines a target mesh or SolidParticle to test
     * @param precise Unless the parameter `precise` is set to `true` the intersection is computed according to Axis Aligned Bounding Boxes (AABB), else according to OBB (Oriented BBoxes)
     * @param includeDescendants Can be set to true to test if the mesh defined in parameters intersects with the current mesh or any child meshes
     * @returns true if there is an intersection
     */
    intersectsMesh(mesh: AbstractMesh | SolidParticle, precise?: boolean, includeDescendants?: boolean): boolean;
    /**
     * Returns true if the passed point (Vector3) is inside the mesh bounding box
     * @param point defines the point to test
     * @returns true if there is an intersection
     */
    intersectsPoint(point: Vector3): boolean;
    /**
     * Gets or sets a boolean indicating that this mesh can be used in the collision engine
     * @see http://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity
     */
    get checkCollisions(): boolean;
    set checkCollisions(collisionEnabled: boolean);
    /**
     * Gets Collider object used to compute collisions (not physics)
     * @see http://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity
     */
    get collider(): Nullable<Collider>;
    /**
     * Move the mesh using collision engine
     * @see http://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity
     * @param displacement defines the requested displacement vector
     * @returns the current mesh
     */
    moveWithCollisions(displacement: Vector3): AbstractMesh;
    private _onCollisionPositionChange;
    /** @hidden */
    _collideForSubMesh(subMesh: SubMesh, transformMatrix: Matrix, collider: Collider): AbstractMesh;
    /** @hidden */
    _processCollisionsForSubMeshes(collider: Collider, transformMatrix: Matrix): AbstractMesh;
    /** @hidden */
    _checkCollision(collider: Collider): AbstractMesh;
    /** @hidden */
    _generatePointsArray(): boolean;
    /**
     * Checks if the passed Ray intersects with the mesh
     * @param ray defines the ray to use
     * @param fastCheck defines if fast mode (but less precise) must be used (false by default)
     * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected
     * @returns the picking info
     * @see http://doc.babylonjs.com/babylon101/intersect_collisions_-_mesh
     */
    intersects(ray: Ray, fastCheck?: boolean, trianglePredicate?: TrianglePickingPredicate): PickingInfo;
    /**
     * Clones the current mesh
     * @param name defines the mesh name
     * @param newParent defines the new mesh parent
     * @param doNotCloneChildren defines a boolean indicating that children must not be cloned (false by default)
     * @returns the new mesh
     */
    clone(name: string, newParent: Nullable<Node>, doNotCloneChildren?: boolean): Nullable<AbstractMesh>;
    /**
     * Disposes all the submeshes of the current meshnp
     * @returns the current mesh
     */
    releaseSubMeshes(): AbstractMesh;
    /**
     * Releases resources associated with this abstract mesh.
     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)
     * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)
     */
    dispose(doNotRecurse?: boolean, disposeMaterialAndTextures?: boolean): void;
    /**
     * Adds the passed mesh as a child to the current mesh
     * @param mesh defines the child mesh
     * @returns the current mesh
     */
    addChild(mesh: AbstractMesh): AbstractMesh;
    /**
     * Removes the passed mesh from the current mesh children list
     * @param mesh defines the child mesh
     * @returns the current mesh
     */
    removeChild(mesh: AbstractMesh): AbstractMesh;
    /** @hidden */
    private _initFacetData;
    /**
     * Updates the mesh facetData arrays and the internal partitioning when the mesh is morphed or updated.
     * This method can be called within the render loop.
     * You don't need to call this method by yourself in the render loop when you update/morph a mesh with the methods CreateXXX() as they automatically manage this computation
     * @returns the current mesh
     * @see http://doc.babylonjs.com/how_to/how_to_use_facetdata
     */
    updateFacetData(): AbstractMesh;
    /**
     * Returns the facetLocalNormals array.
     * The normals are expressed in the mesh local spac
     * @returns an array of Vector3
     * @see http://doc.babylonjs.com/how_to/how_to_use_facetdata
     */
    getFacetLocalNormals(): Vector3[];
    /**
     * Returns the facetLocalPositions array.
     * The facet positions are expressed in the mesh local space
     * @returns an array of Vector3
     * @see http://doc.babylonjs.com/how_to/how_to_use_facetdata
     */
    getFacetLocalPositions(): Vector3[];
    /**
     * Returns the facetLocalPartioning array
     * @returns an array of array of numbers
     * @see http://doc.babylonjs.com/how_to/how_to_use_facetdata
     */
    getFacetLocalPartitioning(): number[][];
    /**
     * Returns the i-th facet position in the world system.
     * This method allocates a new Vector3 per call
     * @param i defines the facet index
     * @returns a new Vector3
     * @see http://doc.babylonjs.com/how_to/how_to_use_facetdata
     */
    getFacetPosition(i: number): Vector3;
    /**
     * Sets the reference Vector3 with the i-th facet position in the world system
     * @param i defines the facet index
     * @param ref defines the target vector
     * @returns the current mesh
     * @see http://doc.babylonjs.com/how_to/how_to_use_facetdata
     */
    getFacetPositionToRef(i: number, ref: Vector3): AbstractMesh;
    /**
     * Returns the i-th facet normal in the world system.
     * This method allocates a new Vector3 per call
     * @param i defines the facet index
     * @returns a new Vector3
     * @see http://doc.babylonjs.com/how_to/how_to_use_facetdata
     */
    getFacetNormal(i: number): Vector3;
    /**
     * Sets the reference Vector3 with the i-th facet normal in the world system
     * @param i defines the facet index
     * @param ref defines the target vector
     * @returns the current mesh
     * @see http://doc.babylonjs.com/how_to/how_to_use_facetdata
     */
    getFacetNormalToRef(i: number, ref: Vector3): this;
    /**
     * Returns the facets (in an array) in the same partitioning block than the one the passed coordinates are located (expressed in the mesh local system)
     * @param x defines x coordinate
     * @param y defines y coordinate
     * @param z defines z coordinate
     * @returns the array of facet indexes
     * @see http://doc.babylonjs.com/how_to/how_to_use_facetdata
     */
    getFacetsAtLocalCoordinates(x: number, y: number, z: number): Nullable<number[]>;
    /**
     * Returns the closest mesh facet index at (x,y,z) World coordinates, null if not found
     * @param projected sets as the (x,y,z) world projection on the facet
     * @param checkFace if true (default false), only the facet "facing" to (x,y,z) or only the ones "turning their backs", according to the parameter "facing" are returned
     * @param facing if facing and checkFace are true, only the facet "facing" to (x, y, z) are returned : positive dot (x, y, z) * facet position. If facing si false and checkFace is true, only the facet "turning their backs" to (x, y, z) are returned : negative dot (x, y, z) * facet position
     * @param x defines x coordinate
     * @param y defines y coordinate
     * @param z defines z coordinate
     * @returns the face index if found (or null instead)
     * @see http://doc.babylonjs.com/how_to/how_to_use_facetdata
     */
    getClosestFacetAtCoordinates(x: number, y: number, z: number, projected?: Vector3, checkFace?: boolean, facing?: boolean): Nullable<number>;
    /**
     * Returns the closest mesh facet index at (x,y,z) local coordinates, null if not found
     * @param projected sets as the (x,y,z) local projection on the facet
     * @param checkFace if true (default false), only the facet "facing" to (x,y,z) or only the ones "turning their backs", according to the parameter "facing" are returned
     * @param facing if facing and checkFace are true, only the facet "facing" to (x, y, z) are returned : positive dot (x, y, z) * facet position. If facing si false and checkFace is true, only the facet "turning their backs" to (x, y, z) are returned : negative dot (x, y, z) * facet position
     * @param x defines x coordinate
     * @param y defines y coordinate
     * @param z defines z coordinate
     * @returns the face index if found (or null instead)
     * @see http://doc.babylonjs.com/how_to/how_to_use_facetdata
     */
    getClosestFacetAtLocalCoordinates(x: number, y: number, z: number, projected?: Vector3, checkFace?: boolean, facing?: boolean): Nullable<number>;
    /**
     * Returns the object "parameter" set with all the expected parameters for facetData computation by ComputeNormals()
     * @returns the parameters
     * @see http://doc.babylonjs.com/how_to/how_to_use_facetdata
     */
    getFacetDataParameters(): any;
    /**
     * Disables the feature FacetData and frees the related memory
     * @returns the current mesh
     * @see http://doc.babylonjs.com/how_to/how_to_use_facetdata
     */
    disableFacetData(): AbstractMesh;
    /**
     * Updates the AbstractMesh indices array
     * @param indices defines the data source
     * @param offset defines the offset in the index buffer where to store the new data (can be null)
     * @param gpuMemoryOnly defines a boolean indicating that only the GPU memory must be updated leaving the CPU version of the indices unchanged (false by default)
     * @returns the current mesh
     */
    updateIndices(indices: IndicesArray, offset?: number, gpuMemoryOnly?: boolean): AbstractMesh;
    /**
     * Creates new normals data for the mesh
     * @param updatable defines if the normal vertex buffer must be flagged as updatable
     * @returns the current mesh
     */
    createNormals(updatable: boolean): AbstractMesh;
    /**
     * Align the mesh with a normal
     * @param normal defines the normal to use
     * @param upDirection can be used to redefined the up vector to use (will use the (0, 1, 0) by default)
     * @returns the current mesh
     */
    alignWithNormal(normal: Vector3, upDirection?: Vector3): AbstractMesh;
    /** @hidden */
    _checkOcclusionQuery(): boolean;
    /**
     * Disables the mesh edge rendering mode
     * @returns the currentAbstractMesh
     */
    disableEdgesRendering(): AbstractMesh;
    /**
     * Enables the edge rendering mode on the mesh.
     * This mode makes the mesh edges visible
     * @param epsilon defines the maximal distance between two angles to detect a face
     * @param checkVerticesInsteadOfIndices indicates that we should check vertex list directly instead of faces
     * @returns the currentAbstractMesh
     * @see https://www.babylonjs-playground.com/#19O9TU#0
     */
    enableEdgesRendering(epsilon?: number, checkVerticesInsteadOfIndices?: boolean): AbstractMesh;
}
export {};
