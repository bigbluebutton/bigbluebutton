import { Nullable, IndicesArray, DeepImmutable, FloatArray } from "../types";
import { Matrix, Vector3 } from "../Maths/math.vector";
import { Engine } from "../Engines/engine";
import { IntersectionInfo } from "../Collisions/intersectionInfo";
import { ICullable, BoundingInfo } from "../Culling/boundingInfo";
import { Effect } from "../Materials/effect";
import { DataBuffer } from './dataBuffer';
import { Plane } from '../Maths/math.plane';
declare type Collider = import("../Collisions/collider").Collider;
declare type Material = import("../Materials/material").Material;
declare type MaterialDefines = import("../Materials/materialDefines").MaterialDefines;
declare type AbstractMesh = import("./abstractMesh").AbstractMesh;
declare type Mesh = import("./mesh").Mesh;
declare type Ray = import("../Culling/ray").Ray;
declare type TrianglePickingPredicate = import("../Culling/ray").TrianglePickingPredicate;
/**
 * Base class for submeshes
 */
export declare class BaseSubMesh {
    /** @hidden */
    _materialDefines: Nullable<MaterialDefines>;
    /** @hidden */
    _materialEffect: Nullable<Effect>;
    /**
     * Gets material defines used by the effect associated to the sub mesh
     */
    get materialDefines(): Nullable<MaterialDefines>;
    /**
     * Sets material defines used by the effect associated to the sub mesh
     */
    set materialDefines(defines: Nullable<MaterialDefines>);
    /**
     * Gets associated effect
     */
    get effect(): Nullable<Effect>;
    /**
     * Sets associated effect (effect used to render this submesh)
     * @param effect defines the effect to associate with
     * @param defines defines the set of defines used to compile this effect
     */
    setEffect(effect: Nullable<Effect>, defines?: Nullable<MaterialDefines>): void;
}
/**
 * Defines a subdivision inside a mesh
 */
export declare class SubMesh extends BaseSubMesh implements ICullable {
    /** the material index to use */
    materialIndex: number;
    /** vertex index start */
    verticesStart: number;
    /** vertices count */
    verticesCount: number;
    /** index start */
    indexStart: number;
    /** indices count */
    indexCount: number;
    /** @hidden */
    _linesIndexCount: number;
    private _mesh;
    private _renderingMesh;
    private _boundingInfo;
    private _linesIndexBuffer;
    /** @hidden */
    _lastColliderWorldVertices: Nullable<Vector3[]>;
    /** @hidden */
    _trianglePlanes: Plane[];
    /** @hidden */
    _lastColliderTransformMatrix: Nullable<Matrix>;
    /** @hidden */
    _renderId: number;
    /** @hidden */
    _alphaIndex: number;
    /** @hidden */
    _distanceToCamera: number;
    /** @hidden */
    _id: number;
    private _currentMaterial;
    /**
     * Add a new submesh to a mesh
     * @param materialIndex defines the material index to use
     * @param verticesStart defines vertex index start
     * @param verticesCount defines vertices count
     * @param indexStart defines index start
     * @param indexCount defines indices count
     * @param mesh defines the parent mesh
     * @param renderingMesh defines an optional rendering mesh
     * @param createBoundingBox defines if bounding box should be created for this submesh
     * @returns the new submesh
     */
    static AddToMesh(materialIndex: number, verticesStart: number, verticesCount: number, indexStart: number, indexCount: number, mesh: AbstractMesh, renderingMesh?: Mesh, createBoundingBox?: boolean): SubMesh;
    /**
     * Creates a new submesh
     * @param materialIndex defines the material index to use
     * @param verticesStart defines vertex index start
     * @param verticesCount defines vertices count
     * @param indexStart defines index start
     * @param indexCount defines indices count
     * @param mesh defines the parent mesh
     * @param renderingMesh defines an optional rendering mesh
     * @param createBoundingBox defines if bounding box should be created for this submesh
     */
    constructor(
    /** the material index to use */
    materialIndex: number, 
    /** vertex index start */
    verticesStart: number, 
    /** vertices count */
    verticesCount: number, 
    /** index start */
    indexStart: number, 
    /** indices count */
    indexCount: number, mesh: AbstractMesh, renderingMesh?: Mesh, createBoundingBox?: boolean);
    /**
     * Returns true if this submesh covers the entire parent mesh
     * @ignorenaming
     */
    get IsGlobal(): boolean;
    /**
     * Returns the submesh BoudingInfo object
     * @returns current bounding info (or mesh's one if the submesh is global)
     */
    getBoundingInfo(): BoundingInfo;
    /**
     * Sets the submesh BoundingInfo
     * @param boundingInfo defines the new bounding info to use
     * @returns the SubMesh
     */
    setBoundingInfo(boundingInfo: BoundingInfo): SubMesh;
    /**
     * Returns the mesh of the current submesh
     * @return the parent mesh
     */
    getMesh(): AbstractMesh;
    /**
     * Returns the rendering mesh of the submesh
     * @returns the rendering mesh (could be different from parent mesh)
     */
    getRenderingMesh(): Mesh;
    /**
     * Returns the submesh material
     * @returns null or the current material
     */
    getMaterial(): Nullable<Material>;
    /**
     * Sets a new updated BoundingInfo object to the submesh
     * @param data defines an optional position array to use to determine the bounding info
     * @returns the SubMesh
     */
    refreshBoundingInfo(data?: Nullable<FloatArray>): SubMesh;
    /** @hidden */
    _checkCollision(collider: Collider): boolean;
    /**
     * Updates the submesh BoundingInfo
     * @param world defines the world matrix to use to update the bounding info
     * @returns the submesh
     */
    updateBoundingInfo(world: DeepImmutable<Matrix>): SubMesh;
    /**
     * True is the submesh bounding box intersects the frustum defined by the passed array of planes.
     * @param frustumPlanes defines the frustum planes
     * @returns true if the submesh is intersecting with the frustum
     */
    isInFrustum(frustumPlanes: Plane[]): boolean;
    /**
     * True is the submesh bounding box is completely inside the frustum defined by the passed array of planes
     * @param frustumPlanes defines the frustum planes
     * @returns true if the submesh is inside the frustum
     */
    isCompletelyInFrustum(frustumPlanes: Plane[]): boolean;
    /**
     * Renders the submesh
     * @param enableAlphaMode defines if alpha needs to be used
     * @returns the submesh
     */
    render(enableAlphaMode: boolean): SubMesh;
    /**
     * @hidden
     */
    _getLinesIndexBuffer(indices: IndicesArray, engine: Engine): DataBuffer;
    /**
     * Checks if the submesh intersects with a ray
     * @param ray defines the ray to test
     * @returns true is the passed ray intersects the submesh bounding box
     */
    canIntersects(ray: Ray): boolean;
    /**
     * Intersects current submesh with a ray
     * @param ray defines the ray to test
     * @param positions defines mesh's positions array
     * @param indices defines mesh's indices array
     * @param fastCheck defines if only bounding info should be used
     * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected
     * @returns intersection info or null if no intersection
     */
    intersects(ray: Ray, positions: Vector3[], indices: IndicesArray, fastCheck?: boolean, trianglePredicate?: TrianglePickingPredicate): Nullable<IntersectionInfo>;
    /** @hidden */
    private _intersectLines;
    /** @hidden */
    private _intersectUnIndexedLines;
    /** @hidden */
    private _intersectTriangles;
    /** @hidden */
    private _intersectUnIndexedTriangles;
    /** @hidden */
    _rebuild(): void;
    /**
     * Creates a new submesh from the passed mesh
     * @param newMesh defines the new hosting mesh
     * @param newRenderingMesh defines an optional rendering mesh
     * @returns the new submesh
     */
    clone(newMesh: AbstractMesh, newRenderingMesh?: Mesh): SubMesh;
    /**
     * Release associated resources
     */
    dispose(): void;
    /**
     * Gets the class name
     * @returns the string "SubMesh".
     */
    getClassName(): string;
    /**
     * Creates a new submesh from indices data
     * @param materialIndex the index of the main mesh material
     * @param startIndex the index where to start the copy in the mesh indices array
     * @param indexCount the number of indices to copy then from the startIndex
     * @param mesh the main mesh to create the submesh from
     * @param renderingMesh the optional rendering mesh
     * @returns a new submesh
     */
    static CreateFromIndices(materialIndex: number, startIndex: number, indexCount: number, mesh: AbstractMesh, renderingMesh?: Mesh): SubMesh;
}
export {};
