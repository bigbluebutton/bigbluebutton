{"version":3,"file":"buffer.js","sourceRoot":"","sources":["../../../sourceES6/core/Meshes/buffer.ts"],"names":[],"mappings":"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","sourcesContent":["import { Nullable, DataArray } from \"../types\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { DataBuffer } from './dataBuffer';\r\n\r\n/**\r\n * Class used to store data that will be store in GPU memory\r\n */\r\nexport class Buffer {\r\n    private _engine: Engine;\r\n    private _buffer: Nullable<DataBuffer>;\r\n    /** @hidden */\r\n    public _data: Nullable<DataArray>;\r\n    private _updatable: boolean;\r\n    private _instanced: boolean;\r\n    private _divisor: number;\r\n\r\n    /**\r\n     * Gets the byte stride.\r\n     */\r\n    public readonly byteStride: number;\r\n\r\n    /**\r\n     * Constructor\r\n     * @param engine the engine\r\n     * @param data the data to use for this buffer\r\n     * @param updatable whether the data is updatable\r\n     * @param stride the stride (optional)\r\n     * @param postponeInternalCreation whether to postpone creating the internal WebGL buffer (optional)\r\n     * @param instanced whether the buffer is instanced (optional)\r\n     * @param useBytes set to true if the stride in in bytes (optional)\r\n     * @param divisor sets an optional divisor for instances (1 by default)\r\n     */\r\n    constructor(engine: any, data: DataArray, updatable: boolean, stride = 0, postponeInternalCreation = false, instanced = false, useBytes = false, divisor?: number) {\r\n        if (engine.getScene) { // old versions of VertexBuffer accepted 'mesh' instead of 'engine'\r\n            this._engine = engine.getScene().getEngine();\r\n        }\r\n        else {\r\n            this._engine = engine;\r\n        }\r\n\r\n        this._updatable = updatable;\r\n        this._instanced = instanced;\r\n        this._divisor = divisor || 1;\r\n\r\n        this._data = data;\r\n\r\n        this.byteStride = useBytes ? stride : stride * Float32Array.BYTES_PER_ELEMENT;\r\n\r\n        if (!postponeInternalCreation) { // by default\r\n            this.create();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new VertexBuffer based on the current buffer\r\n     * @param kind defines the vertex buffer kind (position, normal, etc.)\r\n     * @param offset defines offset in the buffer (0 by default)\r\n     * @param size defines the size in floats of attributes (position is 3 for instance)\r\n     * @param stride defines the stride size in floats in the buffer (the offset to apply to reach next value when data is interleaved)\r\n     * @param instanced defines if the vertex buffer contains indexed data\r\n     * @param useBytes defines if the offset and stride are in bytes     *\r\n     * @param divisor sets an optional divisor for instances (1 by default)\r\n     * @returns the new vertex buffer\r\n     */\r\n    public createVertexBuffer(kind: string, offset: number, size: number, stride?: number, instanced?: boolean, useBytes = false, divisor?: number): VertexBuffer {\r\n        const byteOffset = useBytes ? offset : offset * Float32Array.BYTES_PER_ELEMENT;\r\n        const byteStride = stride ? (useBytes ? stride : stride * Float32Array.BYTES_PER_ELEMENT) : this.byteStride;\r\n\r\n        // a lot of these parameters are ignored as they are overriden by the buffer\r\n        return new VertexBuffer(this._engine, this, kind, this._updatable, true, byteStride, instanced === undefined ? this._instanced : instanced, byteOffset, size, undefined, undefined, true, this._divisor || divisor);\r\n    }\r\n\r\n    // Properties\r\n\r\n    /**\r\n     * Gets a boolean indicating if the Buffer is updatable?\r\n     * @returns true if the buffer is updatable\r\n     */\r\n    public isUpdatable(): boolean {\r\n        return this._updatable;\r\n    }\r\n\r\n    /**\r\n     * Gets current buffer's data\r\n     * @returns a DataArray or null\r\n     */\r\n    public getData(): Nullable<DataArray> {\r\n        return this._data;\r\n    }\r\n\r\n    /**\r\n     * Gets underlying native buffer\r\n     * @returns underlying native buffer\r\n     */\r\n    public getBuffer(): Nullable<DataBuffer> {\r\n        return this._buffer;\r\n    }\r\n\r\n    /**\r\n     * Gets the stride in float32 units (i.e. byte stride / 4).\r\n     * May not be an integer if the byte stride is not divisible by 4.\r\n     * @returns the stride in float32 units\r\n     * @deprecated Please use byteStride instead.\r\n     */\r\n    public getStrideSize(): number {\r\n        return this.byteStride / Float32Array.BYTES_PER_ELEMENT;\r\n    }\r\n\r\n    // Methods\r\n\r\n    /**\r\n     * Store data into the buffer. If the buffer was already used it will be either recreated or updated depending on isUpdatable property\r\n     * @param data defines the data to store\r\n     */\r\n    public create(data: Nullable<DataArray> = null): void {\r\n        if (!data && this._buffer) {\r\n            return; // nothing to do\r\n        }\r\n\r\n        data = data || this._data;\r\n\r\n        if (!data) {\r\n            return;\r\n        }\r\n\r\n        if (!this._buffer) { // create buffer\r\n            if (this._updatable) {\r\n                this._buffer = this._engine.createDynamicVertexBuffer(data);\r\n                this._data = data;\r\n            } else {\r\n                this._buffer = this._engine.createVertexBuffer(data);\r\n            }\r\n        } else if (this._updatable) { // update buffer\r\n            this._engine.updateDynamicVertexBuffer(this._buffer, data);\r\n            this._data = data;\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    public _rebuild(): void {\r\n        this._buffer = null;\r\n        this.create(this._data);\r\n    }\r\n\r\n    /**\r\n     * Update current buffer data\r\n     * @param data defines the data to store\r\n     */\r\n    public update(data: DataArray): void {\r\n        this.create(data);\r\n    }\r\n\r\n    /**\r\n     * Updates the data directly.\r\n     * @param data the new data\r\n     * @param offset the new offset\r\n     * @param vertexCount the vertex count (optional)\r\n     * @param useBytes set to true if the offset is in bytes\r\n     */\r\n    public updateDirectly(data: DataArray, offset: number, vertexCount?: number, useBytes: boolean = false): void {\r\n        if (!this._buffer) {\r\n            return;\r\n        }\r\n\r\n        if (this._updatable) { // update buffer\r\n            this._engine.updateDynamicVertexBuffer(this._buffer, data, useBytes ? offset : offset * Float32Array.BYTES_PER_ELEMENT, (vertexCount ? vertexCount * this.byteStride : undefined));\r\n            this._data = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release all resources\r\n     */\r\n    public dispose(): void {\r\n        if (!this._buffer) {\r\n            return;\r\n        }\r\n        if (this._engine._releaseBuffer(this._buffer)) {\r\n            this._buffer = null;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n     * Specialized buffer used to store vertex data\r\n     */\r\nexport class VertexBuffer {\r\n    /** @hidden */\r\n    public _buffer: Buffer;\r\n    private _kind: string;\r\n    private _size: number;\r\n    private _ownsBuffer: boolean;\r\n    private _instanced: boolean;\r\n    private _instanceDivisor: number;\r\n\r\n    /**\r\n     * The byte type.\r\n     */\r\n    public static readonly BYTE = 5120;\r\n\r\n    /**\r\n     * The unsigned byte type.\r\n     */\r\n    public static readonly UNSIGNED_BYTE = 5121;\r\n\r\n    /**\r\n     * The short type.\r\n     */\r\n    public static readonly SHORT = 5122;\r\n\r\n    /**\r\n     * The unsigned short type.\r\n     */\r\n    public static readonly UNSIGNED_SHORT = 5123;\r\n\r\n    /**\r\n     * The integer type.\r\n     */\r\n    public static readonly INT = 5124;\r\n\r\n    /**\r\n     * The unsigned integer type.\r\n     */\r\n    public static readonly UNSIGNED_INT = 5125;\r\n\r\n    /**\r\n     * The float type.\r\n     */\r\n    public static readonly FLOAT = 5126;\r\n\r\n    /**\r\n     * Gets or sets the instance divisor when in instanced mode\r\n     */\r\n    public get instanceDivisor(): number {\r\n        return this._instanceDivisor;\r\n    }\r\n\r\n    public set instanceDivisor(value: number) {\r\n        this._instanceDivisor = value;\r\n        if (value == 0) {\r\n            this._instanced = false;\r\n        } else {\r\n            this._instanced = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the byte stride.\r\n     */\r\n    public readonly byteStride: number;\r\n\r\n    /**\r\n     * Gets the byte offset.\r\n     */\r\n    public readonly byteOffset: number;\r\n\r\n    /**\r\n     * Gets whether integer data values should be normalized into a certain range when being casted to a float.\r\n     */\r\n    public readonly normalized: boolean;\r\n\r\n    /**\r\n     * Gets the data type of each component in the array.\r\n     */\r\n    public readonly type: number;\r\n\r\n    /**\r\n     * Constructor\r\n     * @param engine the engine\r\n     * @param data the data to use for this vertex buffer\r\n     * @param kind the vertex buffer kind\r\n     * @param updatable whether the data is updatable\r\n     * @param postponeInternalCreation whether to postpone creating the internal WebGL buffer (optional)\r\n     * @param stride the stride (optional)\r\n     * @param instanced whether the buffer is instanced (optional)\r\n     * @param offset the offset of the data (optional)\r\n     * @param size the number of components (optional)\r\n     * @param type the type of the component (optional)\r\n     * @param normalized whether the data contains normalized data (optional)\r\n     * @param useBytes set to true if stride and offset are in bytes (optional)\r\n     * @param divisor defines the instance divisor to use (1 by default)\r\n     */\r\n    constructor(engine: any, data: DataArray | Buffer, kind: string, updatable: boolean, postponeInternalCreation?: boolean, stride?: number,\r\n        instanced?: boolean, offset?: number, size?: number, type?: number, normalized = false, useBytes = false, divisor = 1) {\r\n        if (data instanceof Buffer) {\r\n            this._buffer = data;\r\n            this._ownsBuffer = false;\r\n        } else {\r\n            this._buffer = new Buffer(engine, data, updatable, stride, postponeInternalCreation, instanced, useBytes);\r\n            this._ownsBuffer = true;\r\n        }\r\n\r\n        this._kind = kind;\r\n\r\n        if (type == undefined) {\r\n            const data = this.getData();\r\n            this.type = VertexBuffer.FLOAT;\r\n            if (data instanceof Int8Array) { this.type = VertexBuffer.BYTE; }\r\n            else if (data instanceof Uint8Array) { this.type = VertexBuffer.UNSIGNED_BYTE; }\r\n            else if (data instanceof Int16Array) { this.type = VertexBuffer.SHORT; }\r\n            else if (data instanceof Uint16Array) { this.type = VertexBuffer.UNSIGNED_SHORT; }\r\n            else if (data instanceof Int32Array) { this.type = VertexBuffer.INT; }\r\n            else if (data instanceof Uint32Array) { this.type = VertexBuffer.UNSIGNED_INT; }\r\n        }\r\n        else {\r\n            this.type = type;\r\n        }\r\n\r\n        const typeByteLength = VertexBuffer.GetTypeByteLength(this.type);\r\n\r\n        if (useBytes) {\r\n            this._size = size || (stride ? (stride / typeByteLength) : VertexBuffer.DeduceStride(kind));\r\n            this.byteStride = stride || this._buffer.byteStride || (this._size * typeByteLength);\r\n            this.byteOffset = offset || 0;\r\n        }\r\n        else {\r\n            this._size = size || stride || VertexBuffer.DeduceStride(kind);\r\n            this.byteStride = stride ? (stride * typeByteLength) : (this._buffer.byteStride || (this._size * typeByteLength));\r\n            this.byteOffset = (offset || 0) * typeByteLength;\r\n        }\r\n\r\n        this.normalized = normalized;\r\n\r\n        this._instanced = instanced !== undefined ? instanced : false;\r\n        this._instanceDivisor = instanced ? divisor : 0;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _rebuild(): void {\r\n        if (!this._buffer) {\r\n            return;\r\n        }\r\n\r\n        this._buffer._rebuild();\r\n    }\r\n\r\n    /**\r\n     * Returns the kind of the VertexBuffer (string)\r\n     * @returns a string\r\n     */\r\n    public getKind(): string {\r\n        return this._kind;\r\n    }\r\n\r\n    // Properties\r\n\r\n    /**\r\n     * Gets a boolean indicating if the VertexBuffer is updatable?\r\n     * @returns true if the buffer is updatable\r\n     */\r\n    public isUpdatable(): boolean {\r\n        return this._buffer.isUpdatable();\r\n    }\r\n\r\n    /**\r\n     * Gets current buffer's data\r\n     * @returns a DataArray or null\r\n     */\r\n    public getData(): Nullable<DataArray> {\r\n        return this._buffer.getData();\r\n    }\r\n\r\n    /**\r\n     * Gets underlying native buffer\r\n     * @returns underlying native buffer\r\n     */\r\n    public getBuffer(): Nullable<DataBuffer> {\r\n        return this._buffer.getBuffer();\r\n    }\r\n\r\n    /**\r\n     * Gets the stride in float32 units (i.e. byte stride / 4).\r\n     * May not be an integer if the byte stride is not divisible by 4.\r\n     * @returns the stride in float32 units\r\n     * @deprecated Please use byteStride instead.\r\n     */\r\n    public getStrideSize(): number {\r\n        return this.byteStride / VertexBuffer.GetTypeByteLength(this.type);\r\n    }\r\n\r\n    /**\r\n     * Returns the offset as a multiple of the type byte length.\r\n     * @returns the offset in bytes\r\n     * @deprecated Please use byteOffset instead.\r\n     */\r\n    public getOffset(): number {\r\n        return this.byteOffset / VertexBuffer.GetTypeByteLength(this.type);\r\n    }\r\n\r\n    /**\r\n     * Returns the number of components per vertex attribute (integer)\r\n     * @returns the size in float\r\n     */\r\n    public getSize(): number {\r\n        return this._size;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating is the internal buffer of the VertexBuffer is instanced\r\n     * @returns true if this buffer is instanced\r\n     */\r\n    public getIsInstanced(): boolean {\r\n        return this._instanced;\r\n    }\r\n\r\n    /**\r\n     * Returns the instancing divisor, zero for non-instanced (integer).\r\n     * @returns a number\r\n     */\r\n    public getInstanceDivisor(): number {\r\n        return this._instanceDivisor;\r\n    }\r\n\r\n    // Methods\r\n\r\n    /**\r\n     * Store data into the buffer. If the buffer was already used it will be either recreated or updated depending on isUpdatable property\r\n     * @param data defines the data to store\r\n     */\r\n    public create(data?: DataArray): void {\r\n        this._buffer.create(data);\r\n    }\r\n\r\n    /**\r\n     * Updates the underlying buffer according to the passed numeric array or Float32Array.\r\n     * This function will create a new buffer if the current one is not updatable\r\n     * @param data defines the data to store\r\n     */\r\n    public update(data: DataArray): void {\r\n        this._buffer.update(data);\r\n    }\r\n\r\n    /**\r\n     * Updates directly the underlying WebGLBuffer according to the passed numeric array or Float32Array.\r\n     * Returns the directly updated WebGLBuffer.\r\n     * @param data the new data\r\n     * @param offset the new offset\r\n     * @param useBytes set to true if the offset is in bytes\r\n     */\r\n    public updateDirectly(data: DataArray, offset: number, useBytes: boolean = false): void {\r\n        this._buffer.updateDirectly(data, offset, undefined, useBytes);\r\n    }\r\n\r\n    /**\r\n     * Disposes the VertexBuffer and the underlying WebGLBuffer.\r\n     */\r\n    public dispose(): void {\r\n        if (this._ownsBuffer) {\r\n            this._buffer.dispose();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enumerates each value of this vertex buffer as numbers.\r\n     * @param count the number of values to enumerate\r\n     * @param callback the callback function called for each value\r\n     */\r\n    public forEach(count: number, callback: (value: number, index: number) => void): void {\r\n        VertexBuffer.ForEach(this._buffer.getData()!, this.byteOffset, this.byteStride, this._size, this.type, count, this.normalized, callback);\r\n    }\r\n\r\n    // Enums\r\n    /**\r\n     * Positions\r\n     */\r\n    public static readonly PositionKind = \"position\";\r\n    /**\r\n     * Normals\r\n     */\r\n    public static readonly NormalKind = \"normal\";\r\n    /**\r\n     * Tangents\r\n     */\r\n    public static readonly TangentKind = \"tangent\";\r\n    /**\r\n     * Texture coordinates\r\n     */\r\n    public static readonly UVKind = \"uv\";\r\n    /**\r\n     * Texture coordinates 2\r\n     */\r\n    public static readonly UV2Kind = \"uv2\";\r\n    /**\r\n     * Texture coordinates 3\r\n     */\r\n    public static readonly UV3Kind = \"uv3\";\r\n    /**\r\n     * Texture coordinates 4\r\n     */\r\n    public static readonly UV4Kind = \"uv4\";\r\n    /**\r\n     * Texture coordinates 5\r\n     */\r\n    public static readonly UV5Kind = \"uv5\";\r\n    /**\r\n     * Texture coordinates 6\r\n     */\r\n    public static readonly UV6Kind = \"uv6\";\r\n    /**\r\n     * Colors\r\n     */\r\n    public static readonly ColorKind = \"color\";\r\n    /**\r\n     * Matrix indices (for bones)\r\n     */\r\n    public static readonly MatricesIndicesKind = \"matricesIndices\";\r\n    /**\r\n     * Matrix weights (for bones)\r\n     */\r\n    public static readonly MatricesWeightsKind = \"matricesWeights\";\r\n    /**\r\n     * Additional matrix indices (for bones)\r\n     */\r\n    public static readonly MatricesIndicesExtraKind = \"matricesIndicesExtra\";\r\n    /**\r\n     * Additional matrix weights (for bones)\r\n     */\r\n    public static readonly MatricesWeightsExtraKind = \"matricesWeightsExtra\";\r\n\r\n    /**\r\n     * Deduces the stride given a kind.\r\n     * @param kind The kind string to deduce\r\n     * @returns The deduced stride\r\n     */\r\n    public static DeduceStride(kind: string): number {\r\n        switch (kind) {\r\n            case VertexBuffer.UVKind:\r\n            case VertexBuffer.UV2Kind:\r\n            case VertexBuffer.UV3Kind:\r\n            case VertexBuffer.UV4Kind:\r\n            case VertexBuffer.UV5Kind:\r\n            case VertexBuffer.UV6Kind:\r\n                return 2;\r\n            case VertexBuffer.NormalKind:\r\n            case VertexBuffer.PositionKind:\r\n                return 3;\r\n            case VertexBuffer.ColorKind:\r\n            case VertexBuffer.MatricesIndicesKind:\r\n            case VertexBuffer.MatricesIndicesExtraKind:\r\n            case VertexBuffer.MatricesWeightsKind:\r\n            case VertexBuffer.MatricesWeightsExtraKind:\r\n            case VertexBuffer.TangentKind:\r\n                return 4;\r\n            default:\r\n                throw new Error(\"Invalid kind '\" + kind + \"'\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the byte length of the given type.\r\n     * @param type the type\r\n     * @returns the number of bytes\r\n     */\r\n    public static GetTypeByteLength(type: number): number {\r\n        switch (type) {\r\n            case VertexBuffer.BYTE:\r\n            case VertexBuffer.UNSIGNED_BYTE:\r\n                return 1;\r\n            case VertexBuffer.SHORT:\r\n            case VertexBuffer.UNSIGNED_SHORT:\r\n                return 2;\r\n            case VertexBuffer.INT:\r\n            case VertexBuffer.UNSIGNED_INT:\r\n            case VertexBuffer.FLOAT:\r\n                return 4;\r\n            default:\r\n                throw new Error(`Invalid type '${type}'`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enumerates each value of the given parameters as numbers.\r\n     * @param data the data to enumerate\r\n     * @param byteOffset the byte offset of the data\r\n     * @param byteStride the byte stride of the data\r\n     * @param componentCount the number of components per element\r\n     * @param componentType the type of the component\r\n     * @param count the number of values to enumerate\r\n     * @param normalized whether the data is normalized\r\n     * @param callback the callback function called for each value\r\n     */\r\n    public static ForEach(data: DataArray, byteOffset: number, byteStride: number, componentCount: number, componentType: number, count: number, normalized: boolean, callback: (value: number, index: number) => void): void {\r\n        if (data instanceof Array) {\r\n            let offset = byteOffset / 4;\r\n            const stride = byteStride / 4;\r\n            for (let index = 0; index < count; index += componentCount) {\r\n                for (let componentIndex = 0; componentIndex < componentCount; componentIndex++) {\r\n                    callback(data[offset + componentIndex], index + componentIndex);\r\n                }\r\n                offset += stride;\r\n            }\r\n        }\r\n        else {\r\n            const dataView = data instanceof ArrayBuffer ? new DataView(data) : new DataView(data.buffer, data.byteOffset, data.byteLength);\r\n            const componentByteLength = VertexBuffer.GetTypeByteLength(componentType);\r\n            for (let index = 0; index < count; index += componentCount) {\r\n                let componentByteOffset = byteOffset;\r\n                for (let componentIndex = 0; componentIndex < componentCount; componentIndex++) {\r\n                    const value = VertexBuffer._GetFloatValue(dataView, componentType, componentByteOffset, normalized);\r\n                    callback(value, index + componentIndex);\r\n                    componentByteOffset += componentByteLength;\r\n                }\r\n                byteOffset += byteStride;\r\n            }\r\n        }\r\n    }\r\n\r\n    private static _GetFloatValue(dataView: DataView, type: number, byteOffset: number, normalized: boolean): number {\r\n        switch (type) {\r\n            case VertexBuffer.BYTE: {\r\n                let value = dataView.getInt8(byteOffset);\r\n                if (normalized) {\r\n                    value = Math.max(value / 127, -1);\r\n                }\r\n                return value;\r\n            }\r\n            case VertexBuffer.UNSIGNED_BYTE: {\r\n                let value = dataView.getUint8(byteOffset);\r\n                if (normalized) {\r\n                    value = value / 255;\r\n                }\r\n                return value;\r\n            }\r\n            case VertexBuffer.SHORT: {\r\n                let value = dataView.getInt16(byteOffset, true);\r\n                if (normalized) {\r\n                    value = Math.max(value / 32767, -1);\r\n                }\r\n                return value;\r\n            }\r\n            case VertexBuffer.UNSIGNED_SHORT: {\r\n                let value = dataView.getUint16(byteOffset, true);\r\n                if (normalized) {\r\n                    value = value / 65535;\r\n                }\r\n                return value;\r\n            }\r\n            case VertexBuffer.INT: {\r\n                return dataView.getInt32(byteOffset, true);\r\n            }\r\n            case VertexBuffer.UNSIGNED_INT: {\r\n                return dataView.getUint32(byteOffset, true);\r\n            }\r\n            case VertexBuffer.FLOAT: {\r\n                return dataView.getFloat32(byteOffset, true);\r\n            }\r\n            default: {\r\n                throw new Error(`Invalid component type ${type}`);\r\n            }\r\n        }\r\n    }\r\n}"]}