import { NodeMaterialBlockConnectionPointTypes } from './Enums/nodeMaterialBlockConnectionPointTypes';
import { NodeMaterialBlockTargets } from './Enums/nodeMaterialBlockTargets';
import { Nullable } from '../../types';
import { InputBlock } from './Blocks/Input/inputBlock';
import { Observable } from '../../Misc/observable';
declare type NodeMaterialBlock = import("./nodeMaterialBlock").NodeMaterialBlock;
/**
 * Enum used to define the compatibility state between two connection points
 */
export declare enum NodeMaterialConnectionPointCompatibilityStates {
    /** Points are compatibles */
    Compatible = 0,
    /** Points are incompatible because of their types */
    TypeIncompatible = 1,
    /** Points are incompatible because of their targets (vertex vs fragment) */
    TargetIncompatible = 2
}
/**
 * Defines the direction of a connection point
 */
export declare enum NodeMaterialConnectionPointDirection {
    /** Input */
    Input = 0,
    /** Output */
    Output = 1
}
/**
 * Defines a connection point for a block
 */
export declare class NodeMaterialConnectionPoint {
    /** @hidden */
    _ownerBlock: NodeMaterialBlock;
    /** @hidden */
    _connectedPoint: Nullable<NodeMaterialConnectionPoint>;
    private _endpoints;
    private _associatedVariableName;
    private _direction;
    /** @hidden */
    _typeConnectionSource: Nullable<NodeMaterialConnectionPoint>;
    /** @hidden */
    _linkedConnectionSource: Nullable<NodeMaterialConnectionPoint>;
    private _type;
    /** @hidden */
    _enforceAssociatedVariableName: boolean;
    /** Gets the direction of the point */
    get direction(): NodeMaterialConnectionPointDirection;
    /**
     * Gets or sets the additional types supported by this connection point
     */
    acceptedConnectionPointTypes: NodeMaterialBlockConnectionPointTypes[];
    /**
     * Gets or sets the additional types excluded by this connection point
     */
    excludedConnectionPointTypes: NodeMaterialBlockConnectionPointTypes[];
    /**
     * Observable triggered when this point is connected
     */
    onConnectionObservable: Observable<NodeMaterialConnectionPoint>;
    /**
     * Gets or sets the associated variable name in the shader
     */
    get associatedVariableName(): string;
    set associatedVariableName(value: string);
    /** Get the inner type (ie AutoDetect for instance instead of the inferred one) */
    get innerType(): NodeMaterialBlockConnectionPointTypes;
    /**
     * Gets or sets the connection point type (default is float)
     */
    get type(): NodeMaterialBlockConnectionPointTypes;
    set type(value: NodeMaterialBlockConnectionPointTypes);
    /**
     * Gets or sets the connection point name
     */
    name: string;
    /**
     * Gets or sets a boolean indicating that this connection point can be omitted
     */
    isOptional: boolean;
    /**
     * Gets or sets a string indicating that this uniform must be defined under a #ifdef
     */
    define: string;
    /** @hidden */
    _prioritizeVertex: boolean;
    private _target;
    /** Gets or sets the target of that connection point */
    get target(): NodeMaterialBlockTargets;
    set target(value: NodeMaterialBlockTargets);
    /**
     * Gets a boolean indicating that the current point is connected
     */
    get isConnected(): boolean;
    /**
     * Gets a boolean indicating that the current point is connected to an input block
     */
    get isConnectedToInputBlock(): boolean;
    /**
     * Gets a the connected input block (if any)
     */
    get connectInputBlock(): Nullable<InputBlock>;
    /** Get the other side of the connection (if any) */
    get connectedPoint(): Nullable<NodeMaterialConnectionPoint>;
    /** Get the block that owns this connection point */
    get ownerBlock(): NodeMaterialBlock;
    /** Get the block connected on the other side of this connection (if any) */
    get sourceBlock(): Nullable<NodeMaterialBlock>;
    /** Get the block connected on the endpoints of this connection (if any) */
    get connectedBlocks(): Array<NodeMaterialBlock>;
    /** Gets the list of connected endpoints */
    get endpoints(): NodeMaterialConnectionPoint[];
    /** Gets a boolean indicating if that output point is connected to at least one input */
    get hasEndpoints(): boolean;
    /** Gets a boolean indicating that this connection will be used in the vertex shader */
    get isConnectedInVertexShader(): boolean;
    /** Gets a boolean indicating that this connection will be used in the fragment shader */
    get isConnectedInFragmentShader(): boolean;
    /**
     * Creates a new connection point
     * @param name defines the connection point name
     * @param ownerBlock defines the block hosting this connection point
     * @param direction defines the direction of the connection point
     */
    constructor(name: string, ownerBlock: NodeMaterialBlock, direction: NodeMaterialConnectionPointDirection);
    /**
     * Gets the current class name e.g. "NodeMaterialConnectionPoint"
     * @returns the class name
     */
    getClassName(): string;
    /**
     * Gets a boolean indicating if the current point can be connected to another point
     * @param connectionPoint defines the other connection point
     * @returns a boolean
     */
    canConnectTo(connectionPoint: NodeMaterialConnectionPoint): boolean;
    /**
     * Gets a number indicating if the current point can be connected to another point
     * @param connectionPoint defines the other connection point
     * @returns a number defining the compatibility state
     */
    checkCompatibilityState(connectionPoint: NodeMaterialConnectionPoint): NodeMaterialConnectionPointCompatibilityStates;
    /**
     * Connect this point to another connection point
     * @param connectionPoint defines the other connection point
     * @param ignoreConstraints defines if the system will ignore connection type constraints (default is false)
     * @returns the current connection point
     */
    connectTo(connectionPoint: NodeMaterialConnectionPoint, ignoreConstraints?: boolean): NodeMaterialConnectionPoint;
    /**
     * Disconnect this point from one of his endpoint
     * @param endpoint defines the other connection point
     * @returns the current connection point
     */
    disconnectFrom(endpoint: NodeMaterialConnectionPoint): NodeMaterialConnectionPoint;
    /**
     * Serializes this point in a JSON representation
     * @returns the serialized point object
     */
    serialize(): any;
    /**
     * Release resources
     */
    dispose(): void;
}
export {};
