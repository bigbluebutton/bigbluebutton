import { NodeMaterialBlock } from './nodeMaterialBlock';
import { PushMaterial } from '../pushMaterial';
import { Scene } from '../../scene';
import { AbstractMesh } from '../../Meshes/abstractMesh';
import { Matrix } from '../../Maths/math.vector';
import { Mesh } from '../../Meshes/mesh';
import { BaseTexture } from '../../Materials/Textures/baseTexture';
import { Observable } from '../../Misc/observable';
import { SubMesh } from '../../Meshes/subMesh';
import { MaterialDefines } from '../../Materials/materialDefines';
import { NodeMaterialOptimizer } from './Optimizers/nodeMaterialOptimizer';
import { ImageProcessingConfiguration, IImageProcessingConfigurationDefines } from '../imageProcessingConfiguration';
import { Nullable } from '../../types';
import { InputBlock } from './Blocks/Input/inputBlock';
import { TextureBlock } from './Blocks/Dual/textureBlock';
import { ReflectionTextureBlock } from './Blocks/Dual/reflectionTextureBlock';
/**
 * Interface used to configure the node material editor
 */
export interface INodeMaterialEditorOptions {
    /** Define the URl to load node editor script */
    editorURL?: string;
}
/** @hidden */
export declare class NodeMaterialDefines extends MaterialDefines implements IImageProcessingConfigurationDefines {
    NORMAL: boolean;
    TANGENT: boolean;
    UV1: boolean;
    /** BONES */
    NUM_BONE_INFLUENCERS: number;
    BonesPerMesh: number;
    BONETEXTURE: boolean;
    /** MORPH TARGETS */
    MORPHTARGETS: boolean;
    MORPHTARGETS_NORMAL: boolean;
    MORPHTARGETS_TANGENT: boolean;
    MORPHTARGETS_UV: boolean;
    NUM_MORPH_INFLUENCERS: number;
    /** IMAGE PROCESSING */
    IMAGEPROCESSING: boolean;
    VIGNETTE: boolean;
    VIGNETTEBLENDMODEMULTIPLY: boolean;
    VIGNETTEBLENDMODEOPAQUE: boolean;
    TONEMAPPING: boolean;
    TONEMAPPING_ACES: boolean;
    CONTRAST: boolean;
    EXPOSURE: boolean;
    COLORCURVES: boolean;
    COLORGRADING: boolean;
    COLORGRADING3D: boolean;
    SAMPLER3DGREENDEPTH: boolean;
    SAMPLER3DBGRMAP: boolean;
    IMAGEPROCESSINGPOSTPROCESS: boolean;
    /** MISC. */
    BUMPDIRECTUV: number;
    constructor();
    setValue(name: string, value: boolean): void;
}
/**
 * Class used to configure NodeMaterial
 */
export interface INodeMaterialOptions {
    /**
     * Defines if blocks should emit comments
     */
    emitComments: boolean;
}
/**
 * Class used to create a node based material built by assembling shader blocks
 */
export declare class NodeMaterial extends PushMaterial {
    private static _BuildIdGenerator;
    private _options;
    private _vertexCompilationState;
    private _fragmentCompilationState;
    private _sharedData;
    private _buildId;
    private _buildWasSuccessful;
    private _cachedWorldViewMatrix;
    private _cachedWorldViewProjectionMatrix;
    private _optimizers;
    private _animationFrame;
    /** Define the Url to load node editor script */
    static EditorURL: string;
    /** Define the Url to load snippets */
    static SnippetUrl: string;
    private BJSNODEMATERIALEDITOR;
    /** Get the inspector from bundle or global */
    private _getGlobalNodeMaterialEditor;
    /**
     * Gets or sets data used by visual editor
     * @see https://nme.babylonjs.com
     */
    editorData: any;
    /**
     * Gets or sets a boolean indicating that alpha value must be ignored (This will turn alpha blending off even if an alpha value is produced by the material)
     */
    ignoreAlpha: boolean;
    /**
    * Defines the maximum number of lights that can be used in the material
    */
    maxSimultaneousLights: number;
    /**
     * Observable raised when the material is built
     */
    onBuildObservable: Observable<NodeMaterial>;
    /**
     * Gets or sets the root nodes of the material vertex shader
     */
    _vertexOutputNodes: NodeMaterialBlock[];
    /**
     * Gets or sets the root nodes of the material fragment (pixel) shader
     */
    _fragmentOutputNodes: NodeMaterialBlock[];
    /** Gets or sets options to control the node material overall behavior */
    get options(): INodeMaterialOptions;
    set options(options: INodeMaterialOptions);
    /**
     * Default configuration related to image processing available in the standard Material.
     */
    protected _imageProcessingConfiguration: ImageProcessingConfiguration;
    /**
     * Gets the image processing configuration used either in this material.
     */
    get imageProcessingConfiguration(): ImageProcessingConfiguration;
    /**
     * Sets the Default image processing configuration used either in the this material.
     *
     * If sets to null, the scene one is in use.
     */
    set imageProcessingConfiguration(value: ImageProcessingConfiguration);
    /**
     * Gets an array of blocks that needs to be serialized even if they are not yet connected
     */
    attachedBlocks: NodeMaterialBlock[];
    /**
     * Create a new node based material
     * @param name defines the material name
     * @param scene defines the hosting scene
     * @param options defines creation option
     */
    constructor(name: string, scene?: Scene, options?: Partial<INodeMaterialOptions>);
    /**
     * Gets the current class name of the material e.g. "NodeMaterial"
     * @returns the class name
     */
    getClassName(): string;
    /**
     * Keep track of the image processing observer to allow dispose and replace.
     */
    private _imageProcessingObserver;
    /**
     * Attaches a new image processing configuration to the Standard Material.
     * @param configuration
     */
    protected _attachImageProcessingConfiguration(configuration: Nullable<ImageProcessingConfiguration>): void;
    /**
     * Get a block by its name
     * @param name defines the name of the block to retrieve
     * @returns the required block or null if not found
     */
    getBlockByName(name: string): Nullable<NodeMaterialBlock>;
    /**
     * Get a block by its name
     * @param predicate defines the predicate used to find the good candidate
     * @returns the required block or null if not found
     */
    getBlockByPredicate(predicate: (block: NodeMaterialBlock) => boolean): Nullable<NodeMaterialBlock>;
    /**
     * Get an input block by its name
     * @param predicate defines the predicate used to find the good candidate
     * @returns the required input block or null if not found
     */
    getInputBlockByPredicate(predicate: (block: InputBlock) => boolean): Nullable<InputBlock>;
    /**
     * Gets the list of input blocks attached to this material
     * @returns an array of InputBlocks
     */
    getInputBlocks(): InputBlock[];
    /**
     * Adds a new optimizer to the list of optimizers
     * @param optimizer defines the optimizers to add
     * @returns the current material
     */
    registerOptimizer(optimizer: NodeMaterialOptimizer): this | undefined;
    /**
     * Remove an optimizer from the list of optimizers
     * @param optimizer defines the optimizers to remove
     * @returns the current material
     */
    unregisterOptimizer(optimizer: NodeMaterialOptimizer): this | undefined;
    /**
     * Add a new block to the list of output nodes
     * @param node defines the node to add
     * @returns the current material
     */
    addOutputNode(node: NodeMaterialBlock): this;
    /**
     * Remove a block from the list of root nodes
     * @param node defines the node to remove
     * @returns the current material
     */
    removeOutputNode(node: NodeMaterialBlock): this;
    private _addVertexOutputNode;
    private _removeVertexOutputNode;
    private _addFragmentOutputNode;
    private _removeFragmentOutputNode;
    /**
     * Specifies if the material will require alpha blending
     * @returns a boolean specifying if alpha blending is needed
     */
    needAlphaBlending(): boolean;
    /**
     * Specifies if this material should be rendered in alpha test mode
     * @returns a boolean specifying if an alpha test is needed.
     */
    needAlphaTesting(): boolean;
    private _initializeBlock;
    private _resetDualBlocks;
    /**
     * Remove a block from the current node material
     * @param block defines the block to remove
     */
    removeBlock(block: NodeMaterialBlock): void;
    /**
     * Build the material and generates the inner effect
     * @param verbose defines if the build should log activity
     */
    build(verbose?: boolean): void;
    /**
     * Runs an otpimization phase to try to improve the shader code
     */
    optimize(): void;
    private _prepareDefinesForAttributes;
    /**
      * Get if the submesh is ready to be used and all its information available.
      * Child classes can use it to update shaders
      * @param mesh defines the mesh to check
      * @param subMesh defines which submesh to check
      * @param useInstances specifies that instances should be used
      * @returns a boolean indicating that the submesh is ready or not
      */
    isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean;
    /**
     * Get a string representing the shaders built by the current node graph
     */
    get compiledShaders(): string;
    /**
     * Binds the world matrix to the material
     * @param world defines the world transformation matrix
     */
    bindOnlyWorldMatrix(world: Matrix): void;
    /**
     * Binds the submesh to this material by preparing the effect and shader to draw
     * @param world defines the world transformation matrix
     * @param mesh defines the mesh containing the submesh
     * @param subMesh defines the submesh to bind the material to
     */
    bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void;
    /**
     * Gets the active textures from the material
     * @returns an array of textures
     */
    getActiveTextures(): BaseTexture[];
    /**
     * Gets the list of texture blocks
     * @returns an array of texture blocks
     */
    getTextureBlocks(): (TextureBlock | ReflectionTextureBlock)[];
    /**
     * Specifies if the material uses a texture
     * @param texture defines the texture to check against the material
     * @returns a boolean specifying if the material uses the texture
     */
    hasTexture(texture: BaseTexture): boolean;
    /**
     * Disposes the material
     * @param forceDisposeEffect specifies if effects should be forcefully disposed
     * @param forceDisposeTextures specifies if textures should be forcefully disposed
     * @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh
     */
    dispose(forceDisposeEffect?: boolean, forceDisposeTextures?: boolean, notBoundToMesh?: boolean): void;
    /** Creates the node editor window. */
    private _createNodeEditor;
    /**
     * Launch the node material editor
     * @param config Define the configuration of the editor
     * @return a promise fulfilled when the node editor is visible
     */
    edit(config?: INodeMaterialEditorOptions): Promise<void>;
    /**
     * Clear the current material
     */
    clear(): void;
    /**
     * Clear the current material and set it to a default state
     */
    setToDefault(): void;
    /**
     * Loads the current Node Material from a url pointing to a file save by the Node Material Editor
     * @param url defines the url to load from
     * @returns a promise that will fullfil when the material is fully loaded
     */
    loadAsync(url: string): Promise<void>;
    private _gatherBlocks;
    /**
     * Generate a string containing the code declaration required to create an equivalent of this material
     * @returns a string
     */
    generateCode(): string;
    /**
     * Serializes this material in a JSON representation
     * @returns the serialized material object
     */
    serialize(selectedBlocks?: NodeMaterialBlock[]): any;
    private _restoreConnections;
    /**
     * Clear the current graph and load a new one from a serialization object
     * @param source defines the JSON representation of the material
     * @param rootUrl defines the root URL to use to load textures and relative dependencies
     */
    loadFromSerialization(source: any, rootUrl?: string): void;
    /**
     * Creates a node material from parsed material data
     * @param source defines the JSON representation of the material
     * @param scene defines the hosting scene
     * @param rootUrl defines the root URL to use to load textures and relative dependencies
     * @returns a new node material
     */
    static Parse(source: any, scene: Scene, rootUrl?: string): NodeMaterial;
    /**
     * Creates a node material from a snippet saved in a remote file
     * @param name defines the name of the material to create
     * @param url defines the url to load from
     * @param scene defines the hosting scene
     * @returns a promise that will resolve to the new node material
     */
    static ParseFromFileAsync(name: string, url: string, scene: Scene): Promise<NodeMaterial>;
    /**
     * Creates a node material from a snippet saved by the node material editor
     * @param snippetId defines the snippet to load
     * @param scene defines the hosting scene
     * @param rootUrl defines the root URL to use to load textures and relative dependencies
     * @returns a promise that will resolve to the new node material
     */
    static ParseFromSnippetAsync(snippetId: string, scene: Scene, rootUrl?: string): Promise<NodeMaterial>;
    /**
     * Creates a new node material set to default basic configuration
     * @param name defines the name of the material
     * @param scene defines the hosting scene
     * @returns a new NodeMaterial
     */
    static CreateDefault(name: string, scene?: Scene): NodeMaterial;
}
