import { __extends } from "tslib";
import { NodeMaterialBlock } from '../../nodeMaterialBlock';
import { NodeMaterialBlockConnectionPointTypes } from '../../Enums/nodeMaterialBlockConnectionPointTypes';
import { NodeMaterialBlockTargets } from '../../Enums/nodeMaterialBlockTargets';
import { InputBlock } from '../Input/inputBlock';
import { _TypeStore } from '../../../../Misc/typeStore';
import { Texture } from '../../../Textures/texture';
import "../../../../Shaders/ShadersInclude/helperFunctions";
/**
 * Block used to read a texture from a sampler
 */
var TextureBlock = /** @class */ (function (_super) {
    __extends(TextureBlock, _super);
    /**
     * Create a new TextureBlock
     * @param name defines the block name
     */
    function TextureBlock(name) {
        var _this = _super.call(this, name, NodeMaterialBlockTargets.VertexAndFragment) || this;
        /**
         * Gets or sets a boolean indicating if content needs to be converted to gamma space
         */
        _this.convertToGammaSpace = false;
        _this.registerInput("uv", NodeMaterialBlockConnectionPointTypes.Vector2, false, NodeMaterialBlockTargets.VertexAndFragment);
        _this.registerOutput("rgba", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Neutral);
        _this.registerOutput("rgb", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Neutral);
        _this.registerOutput("r", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
        _this.registerOutput("g", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
        _this.registerOutput("b", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
        _this.registerOutput("a", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);
        _this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector3);
        _this._inputs[0].acceptedConnectionPointTypes.push(NodeMaterialBlockConnectionPointTypes.Vector4);
        _this._inputs[0]._prioritizeVertex = true;
        return _this;
    }
    /**
     * Gets the current class name
     * @returns the class name
     */
    TextureBlock.prototype.getClassName = function () {
        return "TextureBlock";
    };
    Object.defineProperty(TextureBlock.prototype, "uv", {
        /**
         * Gets the uv input component
         */
        get: function () {
            return this._inputs[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextureBlock.prototype, "rgba", {
        /**
         * Gets the rgba output component
         */
        get: function () {
            return this._outputs[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextureBlock.prototype, "rgb", {
        /**
         * Gets the rgb output component
         */
        get: function () {
            return this._outputs[1];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextureBlock.prototype, "r", {
        /**
         * Gets the r output component
         */
        get: function () {
            return this._outputs[2];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextureBlock.prototype, "g", {
        /**
         * Gets the g output component
         */
        get: function () {
            return this._outputs[3];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextureBlock.prototype, "b", {
        /**
         * Gets the b output component
         */
        get: function () {
            return this._outputs[4];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextureBlock.prototype, "a", {
        /**
         * Gets the a output component
         */
        get: function () {
            return this._outputs[5];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextureBlock.prototype, "target", {
        get: function () {
            // TextureBlock has a special optimizations for uvs that come from the vertex shaders as they can be packed into a single varyings.
            // But we need to detect uvs coming from fragment then
            if (!this.uv.isConnected) {
                return NodeMaterialBlockTargets.VertexAndFragment;
            }
            if (this.uv.sourceBlock.isInput) {
                return NodeMaterialBlockTargets.VertexAndFragment;
            }
            var parent = this.uv.connectedPoint;
            while (parent) {
                if (parent.target === NodeMaterialBlockTargets.Fragment) {
                    return NodeMaterialBlockTargets.Fragment;
                }
                if (parent.target === NodeMaterialBlockTargets.Vertex) {
                    return NodeMaterialBlockTargets.VertexAndFragment;
                }
                if (parent.target === NodeMaterialBlockTargets.Neutral || parent.target === NodeMaterialBlockTargets.VertexAndFragment) {
                    var parentBlock = parent.ownerBlock;
                    parent = null;
                    for (var _i = 0, _a = parentBlock.inputs; _i < _a.length; _i++) {
                        var input = _a[_i];
                        if (input.connectedPoint) {
                            parent = input.connectedPoint;
                            break;
                        }
                    }
                }
            }
            return NodeMaterialBlockTargets.VertexAndFragment;
        },
        enumerable: true,
        configurable: true
    });
    TextureBlock.prototype.autoConfigure = function (material) {
        if (!this.uv.isConnected) {
            var uvInput = material.getInputBlockByPredicate(function (b) { return b.isAttribute && b.name === "uv"; });
            if (!uvInput) {
                uvInput = new InputBlock("uv");
                uvInput.setAsAttribute();
            }
            uvInput.output.connectTo(this.uv);
        }
    };
    TextureBlock.prototype.initializeDefines = function (mesh, nodeMaterial, defines, useInstances) {
        if (useInstances === void 0) { useInstances = false; }
        if (!defines._areTexturesDirty) {
            return;
        }
        defines.setValue(this._mainUVDefineName, false);
    };
    TextureBlock.prototype.prepareDefines = function (mesh, nodeMaterial, defines) {
        if (!defines._areTexturesDirty) {
            return;
        }
        if (!this.texture || !this.texture.getTextureMatrix) {
            defines.setValue(this._defineName, false);
            defines.setValue(this._mainUVDefineName, true);
            return;
        }
        defines.setValue(this._linearDefineName, this.convertToGammaSpace);
        if (this._isMixed) {
            if (!this.texture.getTextureMatrix().isIdentityAs3x2()) {
                defines.setValue(this._defineName, true);
            }
            else {
                defines.setValue(this._defineName, false);
                defines.setValue(this._mainUVDefineName, true);
            }
        }
    };
    TextureBlock.prototype.isReady = function () {
        if (this.texture && !this.texture.isReadyOrNotBlocking()) {
            return false;
        }
        return true;
    };
    TextureBlock.prototype.bind = function (effect, nodeMaterial, mesh) {
        if (!mesh || !this.texture) {
            return;
        }
        if (this._isMixed) {
            effect.setFloat(this._textureInfoName, this.texture.level);
            effect.setMatrix(this._textureTransformName, this.texture.getTextureMatrix());
        }
        effect.setTexture(this._samplerName, this.texture);
    };
    Object.defineProperty(TextureBlock.prototype, "_isMixed", {
        get: function () {
            return this.target !== NodeMaterialBlockTargets.Fragment;
        },
        enumerable: true,
        configurable: true
    });
    TextureBlock.prototype._injectVertexCode = function (state) {
        var uvInput = this.uv;
        // Inject code in vertex
        this._defineName = state._getFreeDefineName("UVTRANSFORM");
        this._mainUVDefineName = "VMAIN" + uvInput.associatedVariableName.toUpperCase();
        if (uvInput.connectedPoint.ownerBlock.isInput) {
            var uvInputOwnerBlock = uvInput.connectedPoint.ownerBlock;
            if (!uvInputOwnerBlock.isAttribute) {
                state._emitUniformFromString(uvInput.associatedVariableName, "vec2");
            }
        }
        this._mainUVName = "vMain" + uvInput.associatedVariableName;
        this._transformedUVName = state._getFreeVariableName("transformedUV");
        this._textureTransformName = state._getFreeVariableName("textureTransform");
        this._textureInfoName = state._getFreeVariableName("textureInfoName");
        state._emitVaryingFromString(this._transformedUVName, "vec2", this._defineName);
        state._emitVaryingFromString(this._mainUVName, "vec2", this._mainUVDefineName);
        state._emitUniformFromString(this._textureTransformName, "mat4", this._defineName);
        state.compilationString += "#ifdef " + this._defineName + "\r\n";
        state.compilationString += this._transformedUVName + " = vec2(" + this._textureTransformName + " * vec4(" + uvInput.associatedVariableName + ".xy, 1.0, 0.0));\r\n";
        state.compilationString += "#elif defined(" + this._mainUVDefineName + ")\r\n";
        state.compilationString += this._mainUVName + " = " + uvInput.associatedVariableName + ".xy;\r\n";
        state.compilationString += "#endif\r\n";
        if (!this._outputs.some(function (o) { return o.isConnectedInVertexShader; })) {
            return;
        }
        this._writeTextureRead(state, true);
        for (var _i = 0, _a = this._outputs; _i < _a.length; _i++) {
            var output = _a[_i];
            if (output.hasEndpoints) {
                this._writeOutput(state, output, output.name, true);
            }
        }
    };
    TextureBlock.prototype._writeTextureRead = function (state, vertexMode) {
        if (vertexMode === void 0) { vertexMode = false; }
        var uvInput = this.uv;
        if (vertexMode) {
            if (state.target === NodeMaterialBlockTargets.Fragment) {
                return;
            }
            state.compilationString += "vec4 " + this._tempTextureRead + " = texture2D(" + this._samplerName + ", " + uvInput.associatedVariableName + ");\r\n";
            return;
        }
        if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {
            state.compilationString += "vec4 " + this._tempTextureRead + " = texture2D(" + this._samplerName + ", " + uvInput.associatedVariableName + ");\r\n";
            return;
        }
        state.compilationString += "#ifdef " + this._defineName + "\r\n";
        state.compilationString += "vec4 " + this._tempTextureRead + " = texture2D(" + this._samplerName + ", " + this._transformedUVName + ");\r\n";
        state.compilationString += "#elif defined(" + this._mainUVDefineName + ")\r\n";
        state.compilationString += "vec4 " + this._tempTextureRead + " = texture2D(" + this._samplerName + ", " + this._mainUVName + ");\r\n";
        state.compilationString += "#endif\r\n";
    };
    TextureBlock.prototype._writeOutput = function (state, output, swizzle, vertexMode) {
        if (vertexMode === void 0) { vertexMode = false; }
        if (vertexMode) {
            if (state.target === NodeMaterialBlockTargets.Fragment) {
                return;
            }
            state.compilationString += this._declareOutput(output, state) + " = " + this._tempTextureRead + "." + swizzle + ";\r\n";
            return;
        }
        if (this.uv.ownerBlock.target === NodeMaterialBlockTargets.Fragment) {
            state.compilationString += this._declareOutput(output, state) + " = " + this._tempTextureRead + "." + swizzle + ";\r\n";
            return;
        }
        var complement = " * " + this._textureInfoName;
        state.compilationString += this._declareOutput(output, state) + " = " + this._tempTextureRead + "." + swizzle + complement + ";\r\n";
        state.compilationString += "#ifdef " + this._linearDefineName + "\r\n";
        state.compilationString += output.associatedVariableName + " = toGammaSpace(" + output.associatedVariableName + ");\r\n";
        state.compilationString += "#endif\r\n";
    };
    TextureBlock.prototype._buildBlock = function (state) {
        _super.prototype._buildBlock.call(this, state);
        if (state.target === NodeMaterialBlockTargets.Vertex) {
            this._tempTextureRead = state._getFreeVariableName("tempTextureRead");
        }
        if (!this._isMixed && state.target === NodeMaterialBlockTargets.Fragment || this._isMixed && state.target === NodeMaterialBlockTargets.Vertex) {
            this._samplerName = state._getFreeVariableName(this.name + "Sampler");
            state._emit2DSampler(this._samplerName);
            // Declarations
            state.sharedData.blockingBlocks.push(this);
            state.sharedData.textureBlocks.push(this);
            state.sharedData.blocksWithDefines.push(this);
            state.sharedData.bindableBlocks.push(this);
        }
        if (state.target !== NodeMaterialBlockTargets.Fragment) {
            // Vertex
            this._injectVertexCode(state);
            return;
        }
        // Fragment
        if (!this._outputs.some(function (o) { return o.isConnectedInFragmentShader; })) {
            return;
        }
        if (this._isMixed) {
            // Reexport the sampler
            state._emit2DSampler(this._samplerName);
        }
        this._linearDefineName = state._getFreeDefineName("ISLINEAR");
        var comments = "//" + this.name;
        state._emitFunctionFromInclude("helperFunctions", comments);
        if (this._isMixed) {
            state._emitUniformFromString(this._textureInfoName, "float");
        }
        this._writeTextureRead(state);
        for (var _i = 0, _a = this._outputs; _i < _a.length; _i++) {
            var output = _a[_i];
            if (output.hasEndpoints) {
                this._writeOutput(state, output, output.name);
            }
        }
        return this;
    };
    TextureBlock.prototype._dumpPropertiesCode = function () {
        if (!this.texture) {
            return "";
        }
        var codeString = this._codeVariableName + ".texture = new BABYLON.Texture(\"" + this.texture.name + "\");\r\n";
        codeString += this._codeVariableName + ".texture.wrapU = " + this.texture.wrapU + ";\r\n";
        codeString += this._codeVariableName + ".texture.wrapV = " + this.texture.wrapV + ";\r\n";
        codeString += this._codeVariableName + ".texture.uAng = " + this.texture.uAng + ";\r\n";
        codeString += this._codeVariableName + ".texture.vAng = " + this.texture.vAng + ";\r\n";
        codeString += this._codeVariableName + ".texture.wAng = " + this.texture.wAng + ";\r\n";
        codeString += this._codeVariableName + ".texture.uOffset = " + this.texture.uOffset + ";\r\n";
        codeString += this._codeVariableName + ".texture.vOffset = " + this.texture.vOffset + ";\r\n";
        codeString += this._codeVariableName + ".texture.uScale = " + this.texture.uScale + ";\r\n";
        codeString += this._codeVariableName + ".texture.vScale = " + this.texture.vScale + ";\r\n";
        codeString += this._codeVariableName + ".convertToGammaSpace = " + this.convertToGammaSpace + ";\r\n";
        return codeString;
    };
    TextureBlock.prototype.serialize = function () {
        var serializationObject = _super.prototype.serialize.call(this);
        serializationObject.convertToGammaSpace = this.convertToGammaSpace;
        if (this.texture) {
            serializationObject.texture = this.texture.serialize();
        }
        return serializationObject;
    };
    TextureBlock.prototype._deserialize = function (serializationObject, scene, rootUrl) {
        _super.prototype._deserialize.call(this, serializationObject, scene, rootUrl);
        this.convertToGammaSpace = serializationObject.convertToGammaSpace;
        if (serializationObject.texture) {
            rootUrl = serializationObject.texture.url.indexOf("data:") === 0 ? "" : rootUrl;
            this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);
        }
    };
    return TextureBlock;
}(NodeMaterialBlock));
export { TextureBlock };
_TypeStore.RegisteredTypes["BABYLON.TextureBlock"] = TextureBlock;
//# sourceMappingURL=textureBlock.js.map