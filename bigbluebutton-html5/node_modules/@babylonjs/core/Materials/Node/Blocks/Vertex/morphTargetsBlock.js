import { __extends } from "tslib";
import { NodeMaterialBlock } from '../../nodeMaterialBlock';
import { NodeMaterialBlockConnectionPointTypes } from '../../Enums/nodeMaterialBlockConnectionPointTypes';
import { NodeMaterialBlockTargets } from '../../Enums/nodeMaterialBlockTargets';
import { MaterialHelper } from '../../../materialHelper';
import { VertexBuffer } from '../../../../Meshes/buffer';
import { InputBlock } from '../Input/inputBlock';
import { _TypeStore } from '../../../../Misc/typeStore';
import "../../../../Shaders/ShadersInclude/morphTargetsVertexDeclaration";
import "../../../../Shaders/ShadersInclude/morphTargetsVertexGlobalDeclaration";
/**
 * Block used to add morph targets support to vertex shader
 */
var MorphTargetsBlock = /** @class */ (function (_super) {
    __extends(MorphTargetsBlock, _super);
    /**
     * Create a new MorphTargetsBlock
     * @param name defines the block name
     */
    function MorphTargetsBlock(name) {
        var _this = _super.call(this, name, NodeMaterialBlockTargets.Vertex) || this;
        _this.registerInput("position", NodeMaterialBlockConnectionPointTypes.Vector3);
        _this.registerInput("normal", NodeMaterialBlockConnectionPointTypes.Vector3);
        _this.registerInput("tangent", NodeMaterialBlockConnectionPointTypes.Vector3);
        _this.registerInput("uv", NodeMaterialBlockConnectionPointTypes.Vector2);
        _this.registerOutput("positionOutput", NodeMaterialBlockConnectionPointTypes.Vector3);
        _this.registerOutput("normalOutput", NodeMaterialBlockConnectionPointTypes.Vector3);
        _this.registerOutput("tangentOutput", NodeMaterialBlockConnectionPointTypes.Vector3);
        _this.registerOutput("uvOutput", NodeMaterialBlockConnectionPointTypes.Vector2);
        return _this;
    }
    /**
     * Gets the current class name
     * @returns the class name
     */
    MorphTargetsBlock.prototype.getClassName = function () {
        return "MorphTargetsBlock";
    };
    Object.defineProperty(MorphTargetsBlock.prototype, "position", {
        /**
         * Gets the position input component
         */
        get: function () {
            return this._inputs[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MorphTargetsBlock.prototype, "normal", {
        /**
         * Gets the normal input component
         */
        get: function () {
            return this._inputs[1];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MorphTargetsBlock.prototype, "tangent", {
        /**
         * Gets the tangent input component
         */
        get: function () {
            return this._inputs[2];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MorphTargetsBlock.prototype, "uv", {
        /**
         * Gets the tangent input component
         */
        get: function () {
            return this._inputs[3];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MorphTargetsBlock.prototype, "positionOutput", {
        /**
         * Gets the position output component
         */
        get: function () {
            return this._outputs[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MorphTargetsBlock.prototype, "normalOutput", {
        /**
         * Gets the normal output component
         */
        get: function () {
            return this._outputs[1];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MorphTargetsBlock.prototype, "tangentOutput", {
        /**
         * Gets the tangent output component
         */
        get: function () {
            return this._outputs[2];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MorphTargetsBlock.prototype, "uvOutput", {
        /**
         * Gets the tangent output component
         */
        get: function () {
            return this._outputs[3];
        },
        enumerable: true,
        configurable: true
    });
    MorphTargetsBlock.prototype.initialize = function (state) {
        state._excludeVariableName("morphTargetInfluences");
    };
    MorphTargetsBlock.prototype.autoConfigure = function (material) {
        if (!this.position.isConnected) {
            var positionInput = material.getInputBlockByPredicate(function (b) { return b.isAttribute && b.name === "position"; });
            if (!positionInput) {
                positionInput = new InputBlock("position");
                positionInput.setAsAttribute();
            }
            positionInput.output.connectTo(this.position);
        }
        if (!this.normal.isConnected) {
            var normalInput = material.getInputBlockByPredicate(function (b) { return b.isAttribute && b.name === "normal"; });
            if (!normalInput) {
                normalInput = new InputBlock("normal");
                normalInput.setAsAttribute("normal");
            }
            normalInput.output.connectTo(this.normal);
        }
        if (!this.tangent.isConnected) {
            var tangentInput = material.getInputBlockByPredicate(function (b) { return b.isAttribute && b.name === "tangent"; });
            if (!tangentInput) {
                tangentInput = new InputBlock("tangent");
                tangentInput.setAsAttribute("tangent");
            }
            tangentInput.output.connectTo(this.tangent);
        }
        if (!this.uv.isConnected) {
            var uvInput = material.getInputBlockByPredicate(function (b) { return b.isAttribute && b.name === "uv"; });
            if (!uvInput) {
                uvInput = new InputBlock("uv");
                uvInput.setAsAttribute("uv");
            }
            uvInput.output.connectTo(this.uv);
        }
    };
    MorphTargetsBlock.prototype.prepareDefines = function (mesh, nodeMaterial, defines) {
        if (!defines._areAttributesDirty) {
            return;
        }
        MaterialHelper.PrepareDefinesForMorphTargets(mesh, defines);
    };
    MorphTargetsBlock.prototype.bind = function (effect, nodeMaterial, mesh) {
        if (mesh && mesh.morphTargetManager && mesh.morphTargetManager.numInfluencers > 0) {
            MaterialHelper.BindMorphTargetParameters(mesh, effect);
        }
    };
    MorphTargetsBlock.prototype.replaceRepeatableContent = function (vertexShaderState, fragmentShaderState, mesh, defines) {
        var position = this.position;
        var normal = this.normal;
        var tangent = this.tangent;
        var uv = this.uv;
        var positionOutput = this.positionOutput;
        var normalOutput = this.normalOutput;
        var tangentOutput = this.tangentOutput;
        var uvOutput = this.uvOutput;
        var state = vertexShaderState;
        var repeatCount = defines.NUM_MORPH_INFLUENCERS;
        var manager = mesh.morphTargetManager;
        var hasNormals = manager && manager.supportsNormals && defines["NORMAL"];
        var hasTangents = manager && manager.supportsTangents && defines["TANGENT"];
        var hasUVs = manager && manager.supportsUVs && defines["UV1"];
        var injectionCode = "";
        for (var index = 0; index < repeatCount; index++) {
            injectionCode += "#ifdef MORPHTARGETS\r\n";
            injectionCode += positionOutput.associatedVariableName + " += (position" + index + " - " + position.associatedVariableName + ") * morphTargetInfluences[" + index + "];\r\n";
            if (hasNormals) {
                injectionCode += "#ifdef MORPHTARGETS_NORMAL\r\n";
                injectionCode += normalOutput.associatedVariableName + " += (normal" + index + " - " + normal.associatedVariableName + ") * morphTargetInfluences[" + index + "];\r\n";
                injectionCode += "#endif\r\n";
            }
            if (hasTangents) {
                injectionCode += "#ifdef MORPHTARGETS_TANGENT\r\n";
                injectionCode += tangentOutput.associatedVariableName + ".xyz += (tangent" + index + " - " + tangent.associatedVariableName + ".xyz) * morphTargetInfluences[" + index + "];\r\n";
                injectionCode += "#endif\r\n";
            }
            if (hasUVs) {
                injectionCode += "#ifdef MORPHTARGETS_UV\r\n";
                injectionCode += uvOutput.associatedVariableName + ".xy += (uv_" + index + " - " + uv.associatedVariableName + ".xy) * morphTargetInfluences[" + index + "];\r\n";
                injectionCode += "#endif\r\n";
            }
            injectionCode += "#endif\r\n";
        }
        state.compilationString = state.compilationString.replace(this._repeatableContentAnchor, injectionCode);
        if (repeatCount > 0) {
            for (var index = 0; index < repeatCount; index++) {
                state.attributes.push(VertexBuffer.PositionKind + index);
                if (hasNormals) {
                    state.attributes.push(VertexBuffer.NormalKind + index);
                }
                if (hasTangents) {
                    state.attributes.push(VertexBuffer.TangentKind + index);
                }
                if (hasUVs) {
                    state.attributes.push(VertexBuffer.UVKind + "_" + index);
                }
            }
        }
    };
    MorphTargetsBlock.prototype._buildBlock = function (state) {
        _super.prototype._buildBlock.call(this, state);
        // Register for defines
        state.sharedData.blocksWithDefines.push(this);
        // Register for binding
        state.sharedData.bindableBlocks.push(this);
        // Register for repeatable content generation
        state.sharedData.repeatableContentBlocks.push(this);
        // Emit code
        var position = this.position;
        var normal = this.normal;
        var tangent = this.tangent;
        var uv = this.uv;
        var positionOutput = this.positionOutput;
        var normalOutput = this.normalOutput;
        var tangentOutput = this.tangentOutput;
        var uvOutput = this.uvOutput;
        var comments = "//" + this.name;
        state.uniforms.push("morphTargetInfluences");
        state._emitFunctionFromInclude("morphTargetsVertexGlobalDeclaration", comments);
        state._emitFunctionFromInclude("morphTargetsVertexDeclaration", comments, {
            repeatKey: "maxSimultaneousMorphTargets"
        });
        state.compilationString += this._declareOutput(positionOutput, state) + " = " + position.associatedVariableName + ";\r\n";
        state.compilationString += "#ifdef NORMAL\r\n";
        state.compilationString += this._declareOutput(normalOutput, state) + " = " + normal.associatedVariableName + ";\r\n";
        state.compilationString += "#else\r\n";
        state.compilationString += this._declareOutput(normalOutput, state) + " = vec3(0., 0., 0.);\r\n";
        state.compilationString += "#endif\r\n";
        state.compilationString += "#ifdef TANGENT\r\n";
        state.compilationString += this._declareOutput(tangentOutput, state) + " = " + tangent.associatedVariableName + ";\r\n";
        state.compilationString += "#else\r\n";
        state.compilationString += this._declareOutput(tangentOutput, state) + " = vec3(0., 0., 0.);\r\n";
        state.compilationString += "#endif\r\n";
        state.compilationString += "#ifdef UV1\r\n";
        state.compilationString += this._declareOutput(uvOutput, state) + " = " + uv.associatedVariableName + ";\r\n";
        state.compilationString += "#else\r\n";
        state.compilationString += this._declareOutput(uvOutput, state) + " = vec2(0., 0.);\r\n";
        state.compilationString += "#endif\r\n";
        // Repeatable content
        this._repeatableContentAnchor = state._repeatableContentAnchor;
        state.compilationString += this._repeatableContentAnchor;
        return this;
    };
    return MorphTargetsBlock;
}(NodeMaterialBlock));
export { MorphTargetsBlock };
_TypeStore.RegisteredTypes["BABYLON.MorphTargetsBlock"] = MorphTargetsBlock;
//# sourceMappingURL=morphTargetsBlock.js.map