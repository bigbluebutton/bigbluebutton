import { NodeMaterialBlock } from '../../nodeMaterialBlock';
import { NodeMaterialBlockConnectionPointTypes } from '../../Enums/nodeMaterialBlockConnectionPointTypes';
import { NodeMaterialSystemValues } from '../../Enums/nodeMaterialSystemValues';
import { Nullable } from '../../../../types';
import { Effect } from '../../../../Materials/effect';
import { Matrix } from '../../../../Maths/math.vector';
import { Scene } from '../../../../scene';
import { NodeMaterialConnectionPoint } from '../../nodeMaterialBlockConnectionPoint';
import { NodeMaterialBuildState } from '../../nodeMaterialBuildState';
import { NodeMaterialBlockTargets } from '../../Enums/nodeMaterialBlockTargets';
import { AnimatedInputBlockTypes } from './animatedInputBlockTypes';
import { Observable } from '../../../../Misc/observable';
/**
 * Block used to expose an input value
 */
export declare class InputBlock extends NodeMaterialBlock {
    private _mode;
    private _associatedVariableName;
    private _storedValue;
    private _valueCallback;
    private _type;
    private _animationType;
    /** Gets or set a value used to limit the range of float values */
    min: number;
    /** Gets or set a value used to limit the range of float values */
    max: number;
    /** Gets or set a value indicating that this input can only get 0 and 1 values */
    isBoolean: boolean;
    /** Gets or sets a value used by the Node Material editor to determine how to configure the current value if it is a matrix */
    matrixMode: number;
    /** @hidden */
    _systemValue: Nullable<NodeMaterialSystemValues>;
    /** Gets or sets a boolean indicating that this input can be edited in the Inspector (false by default) */
    visibleInInspector: boolean;
    /** Gets or sets a boolean indicating that the value of this input will not change after a build */
    isConstant: boolean;
    /** Gets or sets the group to use to display this block in the Inspector */
    groupInInspector: string;
    /** Gets an observable raised when the value is changed */
    onValueChangedObservable: Observable<InputBlock>;
    /**
     * Gets or sets the connection point type (default is float)
     */
    get type(): NodeMaterialBlockConnectionPointTypes;
    /**
     * Creates a new InputBlock
     * @param name defines the block name
     * @param target defines the target of that block (Vertex by default)
     * @param type defines the type of the input (can be set to NodeMaterialBlockConnectionPointTypes.AutoDetect)
     */
    constructor(name: string, target?: NodeMaterialBlockTargets, type?: NodeMaterialBlockConnectionPointTypes);
    /**
     * Gets the output component
     */
    get output(): NodeMaterialConnectionPoint;
    /**
     * Set the source of this connection point to a vertex attribute
     * @param attributeName defines the attribute name (position, uv, normal, etc...). If not specified it will take the connection point name
     * @returns the current connection point
     */
    setAsAttribute(attributeName?: string): InputBlock;
    /**
     * Set the source of this connection point to a system value
     * @param value define the system value to use (world, view, etc...) or null to switch to manual value
     * @returns the current connection point
     */
    setAsSystemValue(value: Nullable<NodeMaterialSystemValues>): InputBlock;
    /**
     * Gets or sets the value of that point.
     * Please note that this value will be ignored if valueCallback is defined
     */
    get value(): any;
    set value(value: any);
    /**
     * Gets or sets a callback used to get the value of that point.
     * Please note that setting this value will force the connection point to ignore the value property
     */
    get valueCallback(): () => any;
    set valueCallback(value: () => any);
    /**
     * Gets or sets the associated variable name in the shader
     */
    get associatedVariableName(): string;
    set associatedVariableName(value: string);
    /** Gets or sets the type of animation applied to the input */
    get animationType(): AnimatedInputBlockTypes;
    set animationType(value: AnimatedInputBlockTypes);
    /**
     * Gets a boolean indicating that this connection point not defined yet
     */
    get isUndefined(): boolean;
    /**
     * Gets or sets a boolean indicating that this connection point is coming from an uniform.
     * In this case the connection point name must be the name of the uniform to use.
     * Can only be set on inputs
     */
    get isUniform(): boolean;
    set isUniform(value: boolean);
    /**
     * Gets or sets a boolean indicating that this connection point is coming from an attribute.
     * In this case the connection point name must be the name of the attribute to use
     * Can only be set on inputs
     */
    get isAttribute(): boolean;
    set isAttribute(value: boolean);
    /**
     * Gets or sets a boolean indicating that this connection point is generating a varying variable.
     * Can only be set on exit points
     */
    get isVarying(): boolean;
    set isVarying(value: boolean);
    /**
     * Gets a boolean indicating that the current connection point is a system value
     */
    get isSystemValue(): boolean;
    /**
     * Gets or sets the current well known value or null if not defined as a system value
     */
    get systemValue(): Nullable<NodeMaterialSystemValues>;
    set systemValue(value: Nullable<NodeMaterialSystemValues>);
    /**
     * Gets the current class name
     * @returns the class name
     */
    getClassName(): string;
    /**
     * Animate the input if animationType !== None
     * @param scene defines the rendering scene
     */
    animate(scene: Scene): void;
    private _emitDefine;
    initialize(state: NodeMaterialBuildState): void;
    /**
     * Set the input block to its default value (based on its type)
     */
    setDefaultValue(): void;
    private _emitConstant;
    private _emit;
    /** @hidden */
    _transmitWorld(effect: Effect, world: Matrix, worldView: Matrix, worldViewProjection: Matrix): void;
    /** @hidden */
    _transmit(effect: Effect, scene: Scene): void;
    protected _buildBlock(state: NodeMaterialBuildState): void;
    protected _dumpPropertiesCode(): string;
    dispose(): void;
    serialize(): any;
    _deserialize(serializationObject: any, scene: Scene, rootUrl: string): void;
}
