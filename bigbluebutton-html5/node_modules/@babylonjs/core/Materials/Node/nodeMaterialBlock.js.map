{"version":3,"file":"nodeMaterialBlock.js","sourceRoot":"","sources":["../../../../sourceES6/core/Materials/Node/nodeMaterialBlock.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,qCAAqC,EAAE,MAAM,+CAA+C,CAAC;AAGtG,OAAO,EAAE,2BAA2B,EAAE,oCAAoC,EAAE,MAAM,oCAAoC,CAAC;AACvH,OAAO,EAAE,wBAAwB,EAAE,MAAM,kCAAkC,CAAC;AAM5E,OAAO,EAAE,iBAAiB,EAAE,MAAM,8BAA8B,CAAC;AAEjE,OAAO,EAAE,UAAU,EAAE,MAAM,sBAAsB,CAAC;AAGlD;;GAEG;AACH;IA6HI;;;;;;OAMG;IACH,2BAAmB,IAAY,EAAE,MAAwC,EAAE,aAAqB,EAAE,OAAe;QAAhF,uBAAA,EAAA,SAAS,wBAAwB,CAAC,MAAM;QAAE,8BAAA,EAAA,qBAAqB;QAAE,wBAAA,EAAA,eAAe;QAhIzG,mBAAc,GAAG,KAAK,CAAC;QACvB,aAAQ,GAAG,KAAK,CAAC;QACf,cAAS,GAAG,KAAK,CAAC;QAE5B,uFAAuF;QAChF,uBAAkB,GAAG,KAAK,CAAC;QAElC,cAAc;QACP,sBAAiB,GAAG,EAAE,CAAC;QAE9B,cAAc;QACP,YAAO,GAAG,IAAI,KAAK,EAA+B,CAAC;QAC1D,cAAc;QACP,aAAQ,GAAG,IAAI,KAAK,EAA+B,CAAC;QAe3D;;WAEG;QACI,aAAQ,GAAW,EAAE,CAAC;QAkGzB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;QAEjB,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;QAEtB,IAAI,CAAC,cAAc,GAAG,aAAa,CAAC;QACpC,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;QACxB,IAAI,CAAC,QAAQ,GAAG,iBAAiB,CAAC,QAAQ,CAAC;IAC/C,CAAC;IApGD,sBAAW,uCAAQ;QAHnB;;WAEG;aACH;YACI,OAAO,IAAI,CAAC,SAAS,CAAC;QAC1B,CAAC;;;OAAA;IAKD,sBAAW,4CAAa;QAHxB;;WAEG;aACH;YACI,OAAO,IAAI,CAAC,cAAc,CAAC;QAC/B,CAAC;;;OAAA;IAKD,sBAAW,sCAAO;QAHlB;;WAEG;aACH;YACI,OAAO,IAAI,CAAC,QAAQ,CAAC;QACzB,CAAC;;;OAAA;IAKD,sBAAW,sCAAO;QAHlB;;WAEG;aACH;YACI,OAAO,IAAI,CAAC,QAAQ,CAAC;QACzB,CAAC;aAED,UAAmB,KAAa;YAC5B,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC;QAC1B,CAAC;;;OAJA;IASD,sBAAW,qCAAM;QAHjB;;WAEG;aACH;YACI,OAAO,IAAI,CAAC,OAAO,CAAC;QACxB,CAAC;aAED,UAAkB,KAA+B;YAC7C,IAAI,CAAC,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC,KAAK,CAAC,EAAE;gBAC9B,OAAO;aACV;YACD,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;QACzB,CAAC;;;OAPA;IAYD,sBAAW,qCAAM;QAHjB;;WAEG;aACH;YACI,OAAO,IAAI,CAAC,OAAO,CAAC;QACxB,CAAC;;;OAAA;IAGD,sBAAW,sCAAO;QADlB,qCAAqC;aACrC;YACI,OAAO,IAAI,CAAC,QAAQ,CAAC;QACzB,CAAC;;;OAAA;IAED;;;;OAIG;IACI,0CAAc,GAArB,UAAsB,IAAY;QAC9B,IAAI,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,UAAC,CAAC,IAAK,OAAA,CAAC,CAAC,IAAI,KAAK,IAAI,EAAf,CAAe,CAAC,CAAC;QAEzD,IAAI,MAAM,CAAC,MAAM,EAAE;YACf,OAAO,MAAM,CAAC,CAAC,CAAC,CAAC;SACpB;QAED,OAAO,IAAI,CAAC;IAChB,CAAC;IAED;;;;OAIG;IACI,2CAAe,GAAtB,UAAuB,IAAY;QAC/B,IAAI,MAAM,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,UAAC,CAAC,IAAK,OAAA,CAAC,CAAC,IAAI,KAAK,IAAI,EAAf,CAAe,CAAC,CAAC;QAE1D,IAAI,MAAM,CAAC,MAAM,EAAE;YACf,OAAO,MAAM,CAAC,CAAC,CAAC,CAAC;SACpB;QAED,OAAO,IAAI,CAAC;IAChB,CAAC;IAmBD;;;OAGG;IACI,sCAAU,GAAjB,UAAkB,KAA6B;QAC3C,aAAa;IACjB,CAAC;IAED;;;;;OAKG;IACI,gCAAI,GAAX,UAAY,MAAc,EAAE,YAA0B,EAAE,IAAW;QAC/D,aAAa;IACjB,CAAC;IAES,0CAAc,GAAxB,UAAyB,MAAmC,EAAE,KAA6B;QACvF,OAAU,KAAK,CAAC,UAAU,CAAC,MAAM,CAAC,IAAI,CAAC,SAAI,MAAM,CAAC,sBAAwB,CAAC;IAC/E,CAAC;IAES,0CAAc,GAAxB,UAAyB,YAAyC;QAC9D,IAAI,eAAe,GAAG,YAAY,CAAC,cAAc,CAAC;QAElD,IAAI,eAAe,EAAE;YACjB,OAAO,KAAG,YAAY,CAAC,sBAAwB,CAAC;SACnD;QAED,OAAO,IAAI,CAAC;IAChB,CAAC;IAES,uCAAW,GAArB,UAAsB,KAAa;QAC/B,IAAI,aAAa,GAAG,KAAK,CAAC,QAAQ,EAAE,CAAC;QAErC,IAAI,aAAa,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE;YACnC,aAAa,IAAI,IAAI,CAAC;SACzB;QACD,OAAO,KAAG,aAAe,CAAC;IAC9B,CAAC;IAED;;;OAGG;IACI,wCAAY,GAAnB;QACI,OAAO,mBAAmB,CAAC;IAC/B,CAAC;IAED;;;;;;;OAOG;IACI,yCAAa,GAApB,UAAqB,IAAY,EAAE,IAA2C,EAAE,UAA2B,EAAE,MAAiC;QAA9D,2BAAA,EAAA,kBAA2B;QACvG,IAAI,KAAK,GAAG,IAAI,2BAA2B,CAAC,IAAI,EAAE,IAAI,EAAE,oCAAoC,CAAC,KAAK,CAAC,CAAC;QACpG,KAAK,CAAC,IAAI,GAAG,IAAI,CAAC;QAClB,KAAK,CAAC,UAAU,GAAG,UAAU,CAAC;QAC9B,IAAI,MAAM,EAAE;YACR,KAAK,CAAC,MAAM,GAAG,MAAM,CAAC;SACzB;QAED,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QAEzB,OAAO,IAAI,CAAC;IAChB,CAAC;IAED;;;;;;OAMG;IACI,0CAAc,GAArB,UAAsB,IAAY,EAAE,IAA2C,EAAE,MAAiC;QAC9G,IAAI,KAAK,GAAG,IAAI,2BAA2B,CAAC,IAAI,EAAE,IAAI,EAAE,oCAAoC,CAAC,MAAM,CAAC,CAAC;QACrG,KAAK,CAAC,IAAI,GAAG,IAAI,CAAC;QAClB,IAAI,MAAM,EAAE;YACR,KAAK,CAAC,MAAM,GAAG,MAAM,CAAC;SACzB;QAED,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QAE1B,OAAO,IAAI,CAAC;IAChB,CAAC;IAED;;;;OAIG;IACI,kDAAsB,GAA7B,UAA8B,SAAuD;QAAvD,0BAAA,EAAA,gBAAuD;QACjF,KAAkB,UAAY,EAAZ,KAAA,IAAI,CAAC,OAAO,EAAZ,cAAY,EAAZ,IAAY,EAAE;YAA3B,IAAI,KAAK,SAAA;YACV,IAAI,CAAC,KAAK,CAAC,cAAc,EAAE;gBACvB,IAAI,CAAC,SAAS,IAAI,CAAC,SAAS,CAAC,IAAI,KAAK,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,KAAK,qCAAqC,CAAC,UAAU,CAAC,EAAE;oBACpH,OAAO,KAAK,CAAC;iBAChB;aACJ;SACJ;QAED,OAAO,IAAI,CAAC;IAChB,CAAC;IAED;;;;OAIG;IACI,mDAAuB,GAA9B,UAA+B,QAA4C;QAA5C,yBAAA,EAAA,eAA4C;QACvE,KAAmB,UAAa,EAAb,KAAA,IAAI,CAAC,QAAQ,EAAb,cAAa,EAAb,IAAa,EAAE;YAA7B,IAAI,MAAM,SAAA;YACX,IAAI,CAAC,QAAQ,IAAI,CAAC,QAAQ,CAAC,MAAM,IAAI,QAAQ,CAAC,MAAM,KAAK,wBAAwB,CAAC,OAAO,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE;gBAClI,OAAO,MAAM,CAAC;aACjB;SACJ;QAED,OAAO,IAAI,CAAC;IAChB,CAAC;IAED;;;;OAIG;IACI,4CAAgB,GAAvB,UAAwB,OAAoC;QACxD,IAAI,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;QAE3C,IAAI,KAAK,KAAK,CAAC,CAAC,IAAI,KAAK,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE;YAC/C,OAAO,IAAI,CAAC;SACf;QAED,OAAO,IAAI,CAAC,QAAQ,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC;IACpC,CAAC;IAED;;;;;OAKG;IACI,qCAAS,GAAhB,UAAiB,KAAwB,EAAE,OAI1C;QACG,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,KAAK,CAAC,EAAE;YAC5B,OAAO;SACV;QAED,IAAI,MAAM,GAAG,OAAO,IAAI,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,eAAe,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,uBAAuB,CAAC,KAAK,CAAC,CAAC;QAEpH,IAAI,QAAQ,GAAG,IAAI,CAAC;QACpB,OAAO,QAAQ,EAAE;YACb,IAAI,KAAK,GAAG,OAAO,IAAI,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,cAAc,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,sBAAsB,CAAC,MAAM,CAAC,CAAC;YAElH,IAAI,MAAM,IAAI,KAAK,IAAI,MAAM,CAAC,YAAY,CAAC,KAAK,CAAC,EAAE;gBAC/C,MAAM,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;gBACxB,QAAQ,GAAG,KAAK,CAAC;aACpB;iBAAM,IAAI,CAAC,MAAM,EAAE;gBAChB,MAAM,mCAAmC,CAAC;aAC7C;iBAAM;gBACH,MAAM,GAAG,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,CAAC;aAC1C;SACJ;QAED,OAAO,IAAI,CAAC;IAChB,CAAC;IAES,uCAAW,GAArB,UAAsB,KAA6B;QAC/C,wCAAwC;IAC5C,CAAC;IAED;;;;;;OAMG;IACI,oDAAwB,GAA/B,UAAgC,KAA6B,EAAE,YAA0B,EAAE,OAA4B,EAAE,cAAwB;QAC7I,aAAa;IACjB,CAAC;IAED;;;;OAIG;IACI,4CAAgB,GAAvB,UAAwB,IAAkB,EAAE,SAA0B;QAClE,aAAa;IACjB,CAAC;IAED;;;;;;OAMG;IACI,6CAAiB,GAAxB,UAAyB,IAAkB,EAAE,YAA0B,EAAE,OAA4B,EAAE,YAA6B;QAA7B,6BAAA,EAAA,oBAA6B;IACpI,CAAC;IAED;;;;;;OAMG;IACI,0CAAc,GAArB,UAAsB,IAAkB,EAAE,YAA0B,EAAE,OAA4B,EAAE,YAA6B;QAA7B,6BAAA,EAAA,oBAA6B;QAC7H,aAAa;IACjB,CAAC;IAED;;;OAGG;IACI,yCAAa,GAApB,UAAqB,QAAsB;QACvC,aAAa;IACjB,CAAC;IAED;;;;;;OAMG;IACI,oDAAwB,GAA/B,UAAgC,iBAAyC,EAAE,mBAA2C,EAAE,IAAkB,EAAE,OAA4B;QACpK,aAAa;IACjB,CAAC;IAED;;;;;;;OAOG;IACI,mCAAO,GAAd,UAAe,IAAkB,EAAE,YAA0B,EAAE,OAA4B,EAAE,YAA6B;QAA7B,6BAAA,EAAA,oBAA6B;QACtH,OAAO,IAAI,CAAC;IAChB,CAAC;IAES,gDAAoB,GAA9B,UAA+B,WAAmB,EAAE,WAAmB;QACnE,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC,uBAAuB,GAAG,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC;QAC9E,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC,uBAAuB,GAAG,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC;IAClF,CAAC;IAEO,yCAAa,GAArB,UAAsB,KAAwB,EAAE,KAA6B,EAAE,KAAkC,EAAE,YAAiC;QAChJ,KAAK,CAAC,KAAK,CAAC,KAAK,EAAE,YAAY,CAAC,CAAC;QAEjC,IAAM,oBAAoB,GAAG,CAAC,KAAK,CAAC,YAAY,IAAI,IAAI,CAAC,CAAC;QAC1D,IAAM,oCAAoC,GAAG,KAAK,CAAC,YAAY,KAAK,wBAAwB,CAAC,MAAM,IAAI,KAAK,CAAC,MAAM,KAAK,wBAAwB,CAAC,iBAAiB,CAAC;QAEnK,IAAI,oBAAoB,IAAI,CACxB,CAAC,CAAC,KAAK,CAAC,MAAM,GAAG,KAAK,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC;YAC3C,CAAC,CAAC,KAAK,CAAC,MAAM,GAAG,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;YACrC,CAAC,IAAI,CAAC,MAAM,KAAK,wBAAwB,CAAC,iBAAiB,IAAI,oCAAoC,CAAC,CACnG,EAAE,EAAE,oCAAoC;YACzC,IAAI,CAAC,CAAC,KAAK,CAAC,OAAO,IAAI,KAAK,CAAC,MAAM,KAAK,KAAK,CAAC,YAAY,CAAC,CAAC,6CAA6C;mBAClG,CAAC,KAAK,CAAC,OAAO,IAAK,KAAoB,CAAC,WAAW,CAAC,CAAC,wBAAwB;cAClF;gBACE,IAAI,cAAc,GAAG,KAAK,CAAC,cAAe,CAAC;gBAC3C,IAAI,KAAK,CAAC,YAAY,CAAC,sBAAsB,CAAC,IAAI,GAAG,cAAc,CAAC,sBAAsB,EAAE,KAAK,CAAC,UAAU,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC,EAAE;oBAChI,KAAK,CAAC,YAAY,CAAC,iBAAiB,IAAO,IAAI,GAAG,cAAc,CAAC,sBAAsB,WAAM,cAAc,CAAC,sBAAsB,UAAO,CAAC;iBAC7I;gBACD,KAAK,CAAC,sBAAsB,GAAG,IAAI,GAAG,cAAc,CAAC,sBAAsB,CAAC;gBAC5E,KAAK,CAAC,8BAA8B,GAAG,IAAI,CAAC;aAC/C;SACJ;IACL,CAAC;IAED;;;;;OAKG;IACI,iCAAK,GAAZ,UAAa,KAA6B,EAAE,YAAiC;QACzE,IAAI,IAAI,CAAC,QAAQ,KAAK,KAAK,CAAC,UAAU,CAAC,OAAO,EAAE;YAC5C,OAAO,IAAI,CAAC;SACf;QAED,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;YACf,sBAAsB;YACtB,KAAmB,UAAa,EAAb,KAAA,IAAI,CAAC,QAAQ,EAAb,cAAa,EAAb,IAAa,EAAE;gBAA7B,IAAI,MAAM,SAAA;gBACX,IAAI,CAAC,MAAM,CAAC,sBAAsB,EAAE;oBAChC,MAAM,CAAC,sBAAsB,GAAG,KAAK,CAAC,oBAAoB,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;iBAC3E;aACJ;SACJ;QAED,wCAAwC;QACxC,KAAkB,UAAY,EAAZ,KAAA,IAAI,CAAC,OAAO,EAAZ,cAAY,EAAZ,IAAY,EAAE;YAA3B,IAAI,KAAK,SAAA;YACV,IAAI,CAAC,KAAK,CAAC,cAAc,EAAE;gBACvB,IAAI,CAAC,KAAK,CAAC,UAAU,EAAE,EAAE,iBAAiB;oBACtC,KAAK,CAAC,UAAU,CAAC,MAAM,CAAC,6BAA6B,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;iBACrE;gBACD,SAAS;aACZ;YAED,IAAI,IAAI,CAAC,MAAM,KAAK,wBAAwB,CAAC,OAAO,EAAE;gBAClD,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,IAAI,CAAC,MAAO,CAAC,KAAK,CAAC,EAAE;oBACrC,SAAS;iBACZ;gBAED,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,KAAK,CAAC,MAAO,CAAC,KAAK,CAAC,EAAE;oBACtC,SAAS;iBACZ;aACJ;YAED,IAAI,KAAK,GAAG,KAAK,CAAC,cAAc,CAAC,UAAU,CAAC;YAC5C,IAAI,KAAK,IAAI,KAAK,KAAK,IAAI,EAAE;gBACzB,IAAI,CAAC,aAAa,CAAC,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,YAAY,CAAC,CAAC;aACzD;SACJ;QAED,IAAI,IAAI,CAAC,QAAQ,KAAK,KAAK,CAAC,UAAU,CAAC,OAAO,EAAE;YAC5C,OAAO,IAAI,CAAC,CAAC,gFAAgF;SAChG;QAED,OAAO;QACP,IAAI,KAAK,CAAC,UAAU,CAAC,OAAO,EAAE;YAC1B,OAAO,CAAC,GAAG,CAAC,CAAG,KAAK,CAAC,MAAM,KAAK,wBAAwB,CAAC,MAAM,CAAC,CAAC,CAAC,eAAe,CAAC,CAAC,CAAC,iBAAiB,oBAAc,IAAI,CAAC,IAAI,UAAK,IAAI,CAAC,YAAY,EAAE,MAAG,CAAC,CAAC;SAC5J;QAED,uBAAuB;QACvB,IAAI,IAAI,CAAC,aAAa,EAAE;YACpB,QAAQ,KAAK,CAAC,MAAM,EAAE;gBAClB,KAAK,wBAAwB,CAAC,MAAM;oBAChC,KAAK,CAAC,UAAU,CAAC,MAAM,CAAC,UAAU,GAAG,IAAI,CAAC;oBAC1C,MAAM;gBACV,KAAK,wBAAwB,CAAC,QAAQ;oBAClC,KAAK,CAAC,UAAU,CAAC,MAAM,CAAC,YAAY,GAAG,IAAI,CAAC;oBAC5C,MAAM;aACb;SACJ;QAED,IAAI,CAAC,IAAI,CAAC,OAAO,IAAI,KAAK,CAAC,UAAU,CAAC,YAAY,EAAE;YAChD,KAAK,CAAC,iBAAiB,IAAI,WAAS,IAAI,CAAC,IAAI,SAAM,CAAC;SACvD;QAED,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;QAExB,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC,UAAU,CAAC,OAAO,CAAC;QACzC,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC,MAAM,CAAC;QAEjC,2BAA2B;QAC3B,KAAmB,UAAa,EAAb,KAAA,IAAI,CAAC,QAAQ,EAAb,cAAa,EAAb,IAAa,EAAE;YAA7B,IAAI,MAAM,SAAA;YACX,IAAI,CAAC,MAAM,CAAC,MAAM,GAAG,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE;gBACtC,SAAS;aACZ;YAED,KAAqB,UAAgB,EAAhB,KAAA,MAAM,CAAC,SAAS,EAAhB,cAAgB,EAAhB,IAAgB,EAAE;gBAAlC,IAAI,QAAQ,SAAA;gBACb,IAAI,KAAK,GAAG,QAAQ,CAAC,UAAU,CAAC;gBAEhC,IAAI,KAAK,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,YAAY,CAAC,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE;oBACpF,IAAI,CAAC,aAAa,CAAC,KAAK,EAAE,KAAK,EAAE,QAAQ,EAAE,YAAY,CAAC,CAAC;iBAC5D;aACJ;SACJ;QACD,OAAO,KAAK,CAAC;IACjB,CAAC;IAES,wCAAY,GAAtB,UAAuB,IAAY;QAC/B,OAAO,IAAI,CAAC;IAChB,CAAC;IAES,yCAAa,GAAvB,UAAwB,IAAY;QAChC,OAAO,IAAI,CAAC;IAChB,CAAC;IAES,+CAAmB,GAA7B;QACI,OAAO,EAAE,CAAC;IACd,CAAC;IAED,cAAc;IACP,qCAAS,GAAhB,UAAiB,WAAqB,EAAE,aAAkC;QACtE,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAEzB,IAAI,UAAkB,CAAC;QAEvB,kBAAkB;QAClB,IAAI,kBAAkB,GAAG,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,cAAc,EAAE,EAAE,CAAC,CAAC;QAC/D,IAAI,CAAC,iBAAiB,GAAG,kBAAkB,IAAO,IAAI,CAAC,YAAY,EAAE,SAAI,IAAI,CAAC,QAAU,CAAC;QAEzF,IAAI,WAAW,CAAC,OAAO,CAAC,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC,CAAC,EAAE;YACpD,IAAI,KAAK,GAAG,CAAC,CAAC;YACd,GAAG;gBACC,KAAK,EAAE,CAAC;gBACR,IAAI,CAAC,iBAAiB,GAAG,kBAAkB,GAAG,KAAK,CAAC;aACvD,QACM,WAAW,CAAC,OAAO,CAAC,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC,CAAC,EAAE;SAC9D;QAED,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC;QAEzC,cAAc;QACd,UAAU,GAAG,YAAU,IAAI,CAAC,YAAY,EAAE,SAAM,CAAC;QACjD,IAAI,IAAI,CAAC,QAAQ,EAAE;YACf,UAAU,IAAI,QAAM,IAAI,CAAC,QAAQ,SAAM,CAAC;SAC3C;QACD,UAAU,IAAI,SAAO,IAAI,CAAC,iBAAiB,uBAAkB,IAAI,CAAC,YAAY,EAAE,WAAK,IAAI,CAAC,IAAI,aAAS,CAAC;QAExG,aAAa;QACb,UAAU,IAAI,IAAI,CAAC,mBAAmB,EAAE,CAAC;QAEzC,SAAS;QACT,KAAkB,UAAW,EAAX,KAAA,IAAI,CAAC,MAAM,EAAX,cAAW,EAAX,IAAW,EAAE;YAA1B,IAAI,KAAK,SAAA;YACV,IAAI,CAAC,KAAK,CAAC,WAAW,EAAE;gBACpB,SAAS;aACZ;YAED,IAAI,eAAe,GAAG,KAAK,CAAC,cAAe,CAAC;YAC5C,IAAI,cAAc,GAAG,eAAe,CAAC,UAAU,CAAC;YAEhD,IAAI,aAAa,CAAC,OAAO,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC,EAAE;gBAC9C,UAAU,IAAI,cAAc,CAAC,SAAS,CAAC,WAAW,EAAE,aAAa,CAAC,CAAC;aACtE;SACJ;QAED,UAAU;QACV,KAAmB,UAAY,EAAZ,KAAA,IAAI,CAAC,OAAO,EAAZ,cAAY,EAAZ,IAAY,EAAE;YAA5B,IAAI,MAAM,SAAA;YACX,IAAI,CAAC,MAAM,CAAC,YAAY,EAAE;gBACtB,SAAS;aACZ;YAED,KAAqB,UAAgB,EAAhB,KAAA,MAAM,CAAC,SAAS,EAAhB,cAAgB,EAAhB,IAAgB,EAAE;gBAAlC,IAAI,QAAQ,SAAA;gBACb,IAAI,cAAc,GAAG,QAAQ,CAAC,UAAU,CAAC;gBACzC,IAAI,cAAc,IAAI,aAAa,CAAC,OAAO,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC,EAAE;oBAChE,UAAU,IAAI,cAAc,CAAC,SAAS,CAAC,WAAW,EAAE,aAAa,CAAC,CAAC;iBACtE;aACJ;SACJ;QAED,OAAO,UAAU,CAAC;IACtB,CAAC;IAED,cAAc;IACP,yDAA6B,GAApC,UAAqC,aAAkC;QACnE,IAAI,UAAU,GAAG,EAAE,CAAC;QAEpB,IAAI,aAAa,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE;YACpC,OAAO,UAAU,CAAC;SACrB;QAED,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAEzB,KAAkB,UAAW,EAAX,KAAA,IAAI,CAAC,MAAM,EAAX,cAAW,EAAX,IAAW,EAAE;YAA1B,IAAI,KAAK,SAAA;YACV,IAAI,CAAC,KAAK,CAAC,WAAW,EAAE;gBACpB,SAAS;aACZ;YAED,IAAI,eAAe,GAAG,KAAK,CAAC,cAAe,CAAC;YAC5C,IAAI,cAAc,GAAG,eAAe,CAAC,UAAU,CAAC;YAEhD,UAAU,IAAI,cAAc,CAAC,6BAA6B,CAAC,aAAa,CAAC,CAAC;YAC1E,UAAU,IAAO,cAAc,CAAC,iBAAiB,SAAI,cAAc,CAAC,aAAa,CAAC,eAAe,CAAC,IAAI,CAAC,mBAAc,IAAI,CAAC,iBAAiB,SAAI,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,IAAI,CAAC,WAAQ,CAAC;SACxL;QAED,OAAO,UAAU,CAAC;IACtB,CAAC;IAED;;;;;OAKG;IACI,iCAAK,GAAZ,UAAa,KAAY,EAAE,OAAoB;QAApB,wBAAA,EAAA,YAAoB;QAC3C,IAAI,mBAAmB,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;QAE3C,IAAI,SAAS,GAAG,UAAU,CAAC,QAAQ,CAAC,mBAAmB,CAAC,UAAU,CAAC,CAAC;QACpE,IAAI,SAAS,EAAE;YACX,IAAI,KAAK,GAAsB,IAAI,SAAS,EAAE,CAAC;YAC/C,KAAK,CAAC,YAAY,CAAC,mBAAmB,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;YAExD,OAAO,KAAK,CAAC;SAChB;QAED,OAAO,IAAI,CAAC;IAChB,CAAC;IAED;;;OAGG;IACI,qCAAS,GAAhB;QACI,IAAI,mBAAmB,GAAQ,EAAE,CAAC;QAClC,mBAAmB,CAAC,UAAU,GAAG,UAAU,GAAG,IAAI,CAAC,YAAY,EAAE,CAAC;QAClE,mBAAmB,CAAC,EAAE,GAAG,IAAI,CAAC,QAAQ,CAAC;QACvC,mBAAmB,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QACrC,mBAAmB,CAAC,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;QAE7C,mBAAmB,CAAC,MAAM,GAAG,EAAE,CAAC;QAEhC,KAAkB,UAAW,EAAX,KAAA,IAAI,CAAC,MAAM,EAAX,cAAW,EAAX,IAAW,EAAE;YAA1B,IAAI,KAAK,SAAA;YACV,mBAAmB,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,SAAS,EAAE,CAAC,CAAC;SACtD;QAED,OAAO,mBAAmB,CAAC;IAC/B,CAAC;IAED,cAAc;IACP,wCAAY,GAAnB,UAAoB,mBAAwB,EAAE,KAAY,EAAE,OAAe;QACvE,IAAI,CAAC,IAAI,GAAG,mBAAmB,CAAC,IAAI,CAAC;QACrC,IAAI,CAAC,QAAQ,GAAG,mBAAmB,CAAC,QAAQ,CAAC;IACjD,CAAC;IAED;;OAEG;IACI,mCAAO,GAAd;QACI,KAAkB,UAAW,EAAX,KAAA,IAAI,CAAC,MAAM,EAAX,cAAW,EAAX,IAAW,EAAE;YAA1B,IAAI,KAAK,SAAA;YACV,KAAK,CAAC,OAAO,EAAE,CAAC;SACnB;QAED,KAAmB,UAAY,EAAZ,KAAA,IAAI,CAAC,OAAO,EAAZ,cAAY,EAAZ,IAAY,EAAE;YAA5B,IAAI,MAAM,SAAA;YACX,MAAM,CAAC,OAAO,EAAE,CAAC;SACpB;IACL,CAAC;IACL,wBAAC;AAAD,CAAC,AA1pBD,IA0pBC","sourcesContent":["import { NodeMaterialBlockConnectionPointTypes } from './Enums/nodeMaterialBlockConnectionPointTypes';\r\nimport { NodeMaterialBuildState } from './nodeMaterialBuildState';\r\nimport { Nullable } from '../../types';\r\nimport { NodeMaterialConnectionPoint, NodeMaterialConnectionPointDirection } from './nodeMaterialBlockConnectionPoint';\r\nimport { NodeMaterialBlockTargets } from './Enums/nodeMaterialBlockTargets';\r\nimport { Effect } from '../effect';\r\nimport { AbstractMesh } from '../../Meshes/abstractMesh';\r\nimport { Mesh } from '../../Meshes/mesh';\r\nimport { NodeMaterial, NodeMaterialDefines } from './nodeMaterial';\r\nimport { InputBlock } from './Blocks/Input/inputBlock';\r\nimport { UniqueIdGenerator } from '../../Misc/uniqueIdGenerator';\r\nimport { Scene } from '../../scene';\r\nimport { _TypeStore } from '../../Misc/typeStore';\r\nimport { EffectFallbacks } from '../effectFallbacks';\r\n\r\n/**\r\n * Defines a block that can be used inside a node based material\r\n */\r\nexport class NodeMaterialBlock {\r\n    private _buildId: number;\r\n    private _buildTarget: NodeMaterialBlockTargets;\r\n    private _target: NodeMaterialBlockTargets;\r\n    private _isFinalMerger = false;\r\n    private _isInput = false;\r\n    protected _isUnique = false;\r\n\r\n    /** Gets or sets a boolean indicating that only one input can be connected at a time */\r\n    public inputsAreExclusive = false;\r\n\r\n    /** @hidden */\r\n    public _codeVariableName = \"\";\r\n\r\n    /** @hidden */\r\n    public _inputs = new Array<NodeMaterialConnectionPoint>();\r\n    /** @hidden */\r\n    public _outputs = new Array<NodeMaterialConnectionPoint>();\r\n\r\n    /** @hidden */\r\n    public _preparationId: number;\r\n\r\n    /**\r\n     * Gets or sets the name of the block\r\n     */\r\n    public name: string;\r\n\r\n    /**\r\n     * Gets or sets the unique id of the node\r\n     */\r\n    public uniqueId: number;\r\n\r\n    /**\r\n     * Gets or sets the comments associated with this block\r\n     */\r\n    public comments: string = \"\";\r\n\r\n    /**\r\n     * Gets a boolean indicating that this block can only be used once per NodeMaterial\r\n     */\r\n    public get isUnique() {\r\n        return this._isUnique;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that this block is an end block (e.g. it is generating a system value)\r\n     */\r\n    public get isFinalMerger(): boolean {\r\n        return this._isFinalMerger;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that this block is an input (e.g. it sends data to the shader)\r\n     */\r\n    public get isInput(): boolean {\r\n        return this._isInput;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the build Id\r\n     */\r\n    public get buildId(): number {\r\n        return this._buildId;\r\n    }\r\n\r\n    public set buildId(value: number) {\r\n        this._buildId = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the target of the block\r\n     */\r\n    public get target() {\r\n        return this._target;\r\n    }\r\n\r\n    public set target(value: NodeMaterialBlockTargets) {\r\n        if ((this._target & value) !== 0) {\r\n            return;\r\n        }\r\n        this._target = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of input points\r\n     */\r\n    public get inputs(): NodeMaterialConnectionPoint[] {\r\n        return this._inputs;\r\n    }\r\n\r\n    /** Gets the list of output points */\r\n    public get outputs(): NodeMaterialConnectionPoint[] {\r\n        return this._outputs;\r\n    }\r\n\r\n    /**\r\n     * Find an input by its name\r\n     * @param name defines the name of the input to look for\r\n     * @returns the input or null if not found\r\n     */\r\n    public getInputByName(name: string) {\r\n        let filter = this._inputs.filter((e) => e.name === name);\r\n\r\n        if (filter.length) {\r\n            return filter[0];\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Find an output by its name\r\n     * @param name defines the name of the outputto look for\r\n     * @returns the output or null if not found\r\n     */\r\n    public getOutputByName(name: string) {\r\n        let filter = this._outputs.filter((e) => e.name === name);\r\n\r\n        if (filter.length) {\r\n            return filter[0];\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Creates a new NodeMaterialBlock\r\n     * @param name defines the block name\r\n     * @param target defines the target of that block (Vertex by default)\r\n     * @param isFinalMerger defines a boolean indicating that this block is an end block (e.g. it is generating a system value). Default is false\r\n     * @param isInput defines a boolean indicating that this block is an input (e.g. it sends data to the shader). Default is false\r\n     */\r\n    public constructor(name: string, target = NodeMaterialBlockTargets.Vertex, isFinalMerger = false, isInput = false) {\r\n        this.name = name;\r\n\r\n        this._target = target;\r\n\r\n        this._isFinalMerger = isFinalMerger;\r\n        this._isInput = isInput;\r\n        this.uniqueId = UniqueIdGenerator.UniqueId;\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public initialize(state: NodeMaterialBuildState) {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Bind data to effect. Will only be called for blocks with isBindable === true\r\n     * @param effect defines the effect to bind data to\r\n     * @param nodeMaterial defines the hosting NodeMaterial\r\n     * @param mesh defines the mesh that will be rendered\r\n     */\r\n    public bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh) {\r\n        // Do nothing\r\n    }\r\n\r\n    protected _declareOutput(output: NodeMaterialConnectionPoint, state: NodeMaterialBuildState): string {\r\n        return `${state._getGLType(output.type)} ${output.associatedVariableName}`;\r\n    }\r\n\r\n    protected _writeVariable(currentPoint: NodeMaterialConnectionPoint): string {\r\n        let connectionPoint = currentPoint.connectedPoint;\r\n\r\n        if (connectionPoint) {\r\n            return `${currentPoint.associatedVariableName}`;\r\n        }\r\n\r\n        return `0.`;\r\n    }\r\n\r\n    protected _writeFloat(value: number) {\r\n        let stringVersion = value.toString();\r\n\r\n        if (stringVersion.indexOf(\".\") === -1) {\r\n            stringVersion += \".0\";\r\n        }\r\n        return `${stringVersion}`;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name e.g. \"NodeMaterialBlock\"\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"NodeMaterialBlock\";\r\n    }\r\n\r\n    /**\r\n     * Register a new input. Must be called inside a block constructor\r\n     * @param name defines the connection point name\r\n     * @param type defines the connection point type\r\n     * @param isOptional defines a boolean indicating that this input can be omitted\r\n     * @param target defines the target to use to limit the connection point (will be VertexAndFragment by default)\r\n     * @returns the current block\r\n     */\r\n    public registerInput(name: string, type: NodeMaterialBlockConnectionPointTypes, isOptional: boolean = false, target?: NodeMaterialBlockTargets) {\r\n        let point = new NodeMaterialConnectionPoint(name, this, NodeMaterialConnectionPointDirection.Input);\r\n        point.type = type;\r\n        point.isOptional = isOptional;\r\n        if (target) {\r\n            point.target = target;\r\n        }\r\n\r\n        this._inputs.push(point);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Register a new output. Must be called inside a block constructor\r\n     * @param name defines the connection point name\r\n     * @param type defines the connection point type\r\n     * @param target defines the target to use to limit the connection point (will be VertexAndFragment by default)\r\n     * @returns the current block\r\n     */\r\n    public registerOutput(name: string, type: NodeMaterialBlockConnectionPointTypes, target?: NodeMaterialBlockTargets) {\r\n        let point = new NodeMaterialConnectionPoint(name, this, NodeMaterialConnectionPointDirection.Output);\r\n        point.type = type;\r\n        if (target) {\r\n            point.target = target;\r\n        }\r\n\r\n        this._outputs.push(point);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Will return the first available input e.g. the first one which is not an uniform or an attribute\r\n     * @param forOutput defines an optional connection point to check compatibility with\r\n     * @returns the first available input or null\r\n     */\r\n    public getFirstAvailableInput(forOutput: Nullable<NodeMaterialConnectionPoint> = null) {\r\n        for (var input of this._inputs) {\r\n            if (!input.connectedPoint) {\r\n                if (!forOutput || (forOutput.type === input.type) || (input.type === NodeMaterialBlockConnectionPointTypes.AutoDetect)) {\r\n                    return input;\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Will return the first available output e.g. the first one which is not yet connected and not a varying\r\n     * @param forBlock defines an optional block to check compatibility with\r\n     * @returns the first available input or null\r\n     */\r\n    public getFirstAvailableOutput(forBlock: Nullable<NodeMaterialBlock> = null) {\r\n        for (var output of this._outputs) {\r\n            if (!forBlock || !forBlock.target || forBlock.target === NodeMaterialBlockTargets.Neutral || (forBlock.target & output.target) !== 0) {\r\n                return output;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets the sibling of the given output\r\n     * @param current defines the current output\r\n     * @returns the next output in the list or null\r\n     */\r\n    public getSiblingOutput(current: NodeMaterialConnectionPoint) {\r\n        let index = this._outputs.indexOf(current);\r\n\r\n        if (index === -1 || index >= this._outputs.length) {\r\n            return null;\r\n        }\r\n\r\n        return this._outputs[index + 1];\r\n    }\r\n\r\n    /**\r\n     * Connect current block with another block\r\n     * @param other defines the block to connect with\r\n     * @param options define the various options to help pick the right connections\r\n     * @returns the current block\r\n     */\r\n    public connectTo(other: NodeMaterialBlock, options?: {\r\n        input?: string,\r\n        output?: string,\r\n        outputSwizzle?: string\r\n    }) {\r\n        if (this._outputs.length === 0) {\r\n            return;\r\n        }\r\n\r\n        let output = options && options.output ? this.getOutputByName(options.output) : this.getFirstAvailableOutput(other);\r\n\r\n        let notFound = true;\r\n        while (notFound) {\r\n            let input = options && options.input ? other.getInputByName(options.input) : other.getFirstAvailableInput(output);\r\n\r\n            if (output && input && output.canConnectTo(input)) {\r\n                output.connectTo(input);\r\n                notFound = false;\r\n            } else if (!output) {\r\n                throw \"Unable to find a compatible match\";\r\n            } else {\r\n                output = this.getSiblingOutput(output);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        // Empty. Must be defined by child nodes\r\n    }\r\n\r\n    /**\r\n     * Add uniforms, samplers and uniform buffers at compilation time\r\n     * @param state defines the state to update\r\n     * @param nodeMaterial defines the node material requesting the update\r\n     * @param defines defines the material defines to update\r\n     * @param uniformBuffers defines the list of uniform buffer names\r\n     */\r\n    public updateUniformsAndSamples(state: NodeMaterialBuildState, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines, uniformBuffers: string[]) {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Add potential fallbacks if shader compilation fails\r\n     * @param mesh defines the mesh to be rendered\r\n     * @param fallbacks defines the current prioritized list of fallbacks\r\n     */\r\n    public provideFallbacks(mesh: AbstractMesh, fallbacks: EffectFallbacks) {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Initialize defines for shader compilation\r\n     * @param mesh defines the mesh to be rendered\r\n     * @param nodeMaterial defines the node material requesting the update\r\n     * @param defines defines the material defines to update\r\n     * @param useInstances specifies that instances should be used\r\n     */\r\n    public initializeDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines, useInstances: boolean = false) {\r\n    }\r\n\r\n    /**\r\n     * Update defines for shader compilation\r\n     * @param mesh defines the mesh to be rendered\r\n     * @param nodeMaterial defines the node material requesting the update\r\n     * @param defines defines the material defines to update\r\n     * @param useInstances specifies that instances should be used\r\n     */\r\n    public prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines, useInstances: boolean = false) {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Lets the block try to connect some inputs automatically\r\n     * @param material defines the hosting NodeMaterial\r\n     */\r\n    public autoConfigure(material: NodeMaterial) {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Function called when a block is declared as repeatable content generator\r\n     * @param vertexShaderState defines the current compilation state for the vertex shader\r\n     * @param fragmentShaderState defines the current compilation state for the fragment shader\r\n     * @param mesh defines the mesh to be rendered\r\n     * @param defines defines the material defines to update\r\n     */\r\n    public replaceRepeatableContent(vertexShaderState: NodeMaterialBuildState, fragmentShaderState: NodeMaterialBuildState, mesh: AbstractMesh, defines: NodeMaterialDefines) {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Checks if the block is ready\r\n     * @param mesh defines the mesh to be rendered\r\n     * @param nodeMaterial defines the node material requesting the update\r\n     * @param defines defines the material defines to update\r\n     * @param useInstances specifies that instances should be used\r\n     * @returns true if the block is ready\r\n     */\r\n    public isReady(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines, useInstances: boolean = false) {\r\n        return true;\r\n    }\r\n\r\n    protected _linkConnectionTypes(inputIndex0: number, inputIndex1: number) {\r\n        this._inputs[inputIndex0]._linkedConnectionSource = this._inputs[inputIndex1];\r\n        this._inputs[inputIndex1]._linkedConnectionSource = this._inputs[inputIndex0];\r\n    }\r\n\r\n    private _processBuild(block: NodeMaterialBlock, state: NodeMaterialBuildState, input: NodeMaterialConnectionPoint, activeBlocks: NodeMaterialBlock[]) {\r\n        block.build(state, activeBlocks);\r\n\r\n        const localBlockIsFragment = (state._vertexState != null);\r\n        const otherBlockWasGeneratedInVertexShader = block._buildTarget === NodeMaterialBlockTargets.Vertex && block.target !== NodeMaterialBlockTargets.VertexAndFragment;\r\n\r\n        if (localBlockIsFragment && (\r\n            ((block.target & block._buildTarget) === 0) ||\r\n            ((block.target & input.target) === 0) ||\r\n            (this.target !== NodeMaterialBlockTargets.VertexAndFragment && otherBlockWasGeneratedInVertexShader)\r\n            )) { // context switch! We need a varying\r\n            if ((!block.isInput && state.target !== block._buildTarget) // block was already emitted by vertex shader\r\n                || (block.isInput && (block as InputBlock).isAttribute) // block is an attribute\r\n            ) {\r\n                let connectedPoint = input.connectedPoint!;\r\n                if (state._vertexState._emitVaryingFromString(\"v_\" + connectedPoint.associatedVariableName, state._getGLType(connectedPoint.type))) {\r\n                    state._vertexState.compilationString += `${\"v_\" + connectedPoint.associatedVariableName} = ${connectedPoint.associatedVariableName};\\r\\n`;\r\n                }\r\n                input.associatedVariableName = \"v_\" + connectedPoint.associatedVariableName;\r\n                input._enforceAssociatedVariableName = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Compile the current node and generate the shader code\r\n     * @param state defines the current compilation state (uniforms, samplers, current string)\r\n     * @param activeBlocks defines the list of active blocks (i.e. blocks to compile)\r\n     * @returns true if already built\r\n     */\r\n    public build(state: NodeMaterialBuildState, activeBlocks: NodeMaterialBlock[]): boolean {\r\n        if (this._buildId === state.sharedData.buildId) {\r\n            return true;\r\n        }\r\n\r\n        if (!this.isInput) {\r\n            /** Prepare outputs */\r\n            for (var output of this._outputs) {\r\n                if (!output.associatedVariableName) {\r\n                    output.associatedVariableName = state._getFreeVariableName(output.name);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Check if \"parent\" blocks are compiled\r\n        for (var input of this._inputs) {\r\n            if (!input.connectedPoint) {\r\n                if (!input.isOptional) { // Emit a warning\r\n                    state.sharedData.checks.notConnectedNonOptionalInputs.push(input);\r\n                }\r\n                continue;\r\n            }\r\n\r\n            if (this.target !== NodeMaterialBlockTargets.Neutral) {\r\n                if ((input.target & this.target!) === 0) {\r\n                    continue;\r\n                }\r\n\r\n                if ((input.target & state.target!) === 0) {\r\n                    continue;\r\n                }\r\n            }\r\n\r\n            let block = input.connectedPoint.ownerBlock;\r\n            if (block && block !== this) {\r\n                this._processBuild(block, state, input, activeBlocks);\r\n            }\r\n        }\r\n\r\n        if (this._buildId === state.sharedData.buildId) {\r\n            return true; // Need to check again as inputs can be connected multiple time to this endpoint\r\n        }\r\n\r\n        // Logs\r\n        if (state.sharedData.verbose) {\r\n            console.log(`${state.target === NodeMaterialBlockTargets.Vertex ? \"Vertex shader\" : \"Fragment shader\"}: Building ${this.name} [${this.getClassName()}]`);\r\n        }\r\n\r\n        // Checks final outputs\r\n        if (this.isFinalMerger) {\r\n            switch (state.target) {\r\n                case NodeMaterialBlockTargets.Vertex:\r\n                    state.sharedData.checks.emitVertex = true;\r\n                    break;\r\n                case NodeMaterialBlockTargets.Fragment:\r\n                    state.sharedData.checks.emitFragment = true;\r\n                    break;\r\n            }\r\n        }\r\n\r\n        if (!this.isInput && state.sharedData.emitComments) {\r\n            state.compilationString += `\\r\\n//${this.name}\\r\\n`;\r\n        }\r\n\r\n        this._buildBlock(state);\r\n\r\n        this._buildId = state.sharedData.buildId;\r\n        this._buildTarget = state.target;\r\n\r\n        // Compile connected blocks\r\n        for (var output of this._outputs) {\r\n            if ((output.target & state.target) === 0) {\r\n                continue;\r\n            }\r\n\r\n            for (var endpoint of output.endpoints) {\r\n                let block = endpoint.ownerBlock;\r\n\r\n                if (block && (block.target & state.target) !== 0 && activeBlocks.indexOf(block) !== -1) {\r\n                    this._processBuild(block, state, endpoint, activeBlocks);\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    protected _inputRename(name: string) {\r\n        return name;\r\n    }\r\n\r\n    protected _outputRename(name: string) {\r\n        return name;\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        return \"\";\r\n    }\r\n\r\n    /** @hidden */\r\n    public _dumpCode(uniqueNames: string[], alreadyDumped: NodeMaterialBlock[]) {\r\n        alreadyDumped.push(this);\r\n\r\n        let codeString: string;\r\n\r\n        // Get unique name\r\n        let nameAsVariableName = this.name.replace(/[^A-Za-z_]+/g, \"\");\r\n        this._codeVariableName = nameAsVariableName || `${this.getClassName()}_${this.uniqueId}`;\r\n\r\n        if (uniqueNames.indexOf(this._codeVariableName) !== -1) {\r\n            let index = 0;\r\n            do {\r\n                index++;\r\n                this._codeVariableName = nameAsVariableName + index;\r\n            }\r\n            while (uniqueNames.indexOf(this._codeVariableName) !== -1);\r\n        }\r\n\r\n        uniqueNames.push(this._codeVariableName);\r\n\r\n        // Declaration\r\n        codeString = `\\r\\n// ${this.getClassName()}\\r\\n`;\r\n        if (this.comments) {\r\n            codeString += `// ${this.comments}\\r\\n`;\r\n        }\r\n        codeString += `var ${this._codeVariableName} = new BABYLON.${this.getClassName()}(\"${this.name}\");\\r\\n`;\r\n\r\n        // Properties\r\n        codeString += this._dumpPropertiesCode();\r\n\r\n        // Inputs\r\n        for (var input of this.inputs) {\r\n            if (!input.isConnected) {\r\n                continue;\r\n            }\r\n\r\n            var connectedOutput = input.connectedPoint!;\r\n            var connectedBlock = connectedOutput.ownerBlock;\r\n\r\n            if (alreadyDumped.indexOf(connectedBlock) === -1) {\r\n                codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);\r\n            }\r\n        }\r\n\r\n        // Outputs\r\n        for (var output of this.outputs) {\r\n            if (!output.hasEndpoints) {\r\n                continue;\r\n            }\r\n\r\n            for (var endpoint of output.endpoints) {\r\n                var connectedBlock = endpoint.ownerBlock;\r\n                if (connectedBlock && alreadyDumped.indexOf(connectedBlock) === -1) {\r\n                    codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);\r\n                }\r\n            }\r\n        }\r\n\r\n        return codeString;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _dumpCodeForOutputConnections(alreadyDumped: NodeMaterialBlock[]) {\r\n        let codeString = \"\";\r\n\r\n        if (alreadyDumped.indexOf(this) !== -1) {\r\n            return codeString;\r\n        }\r\n\r\n        alreadyDumped.push(this);\r\n\r\n        for (var input of this.inputs) {\r\n            if (!input.isConnected) {\r\n                continue;\r\n            }\r\n\r\n            var connectedOutput = input.connectedPoint!;\r\n            var connectedBlock = connectedOutput.ownerBlock;\r\n\r\n            codeString += connectedBlock._dumpCodeForOutputConnections(alreadyDumped);\r\n            codeString += `${connectedBlock._codeVariableName}.${connectedBlock._outputRename(connectedOutput.name)}.connectTo(${this._codeVariableName}.${this._inputRename(input.name)});\\r\\n`;\r\n        }\r\n\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Clone the current block to a new identical block\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a copy of the current block\r\n     */\r\n    public clone(scene: Scene, rootUrl: string = \"\") {\r\n        let serializationObject = this.serialize();\r\n\r\n        let blockType = _TypeStore.GetClass(serializationObject.customType);\r\n        if (blockType) {\r\n            let block: NodeMaterialBlock = new blockType();\r\n            block._deserialize(serializationObject, scene, rootUrl);\r\n\r\n            return block;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Serializes this block in a JSON representation\r\n     * @returns the serialized block object\r\n     */\r\n    public serialize(): any {\r\n        let serializationObject: any = {};\r\n        serializationObject.customType = \"BABYLON.\" + this.getClassName();\r\n        serializationObject.id = this.uniqueId;\r\n        serializationObject.name = this.name;\r\n        serializationObject.comments = this.comments;\r\n\r\n        serializationObject.inputs = [];\r\n\r\n        for (var input of this.inputs) {\r\n            serializationObject.inputs.push(input.serialize());\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /** @hidden */\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        this.name = serializationObject.name;\r\n        this.comments = serializationObject.comments;\r\n    }\r\n\r\n    /**\r\n     * Release resources\r\n     */\r\n    public dispose() {\r\n        for (var input of this.inputs) {\r\n            input.dispose();\r\n        }\r\n\r\n        for (var output of this.outputs) {\r\n            output.dispose();\r\n        }\r\n    }\r\n}"]}