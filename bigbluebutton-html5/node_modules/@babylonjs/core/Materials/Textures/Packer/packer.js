import { Engine } from "../../../Engines/engine";
import { VertexBuffer } from "../../../Meshes/buffer";
import { Texture } from "../texture";
import { DynamicTexture } from "../dynamicTexture";
import { Vector2 } from "../../../Maths/math.vector";
import { Color3, Color4 } from "../../../Maths/math.color";
import { TexturePackerFrame } from "./frame";
import { Logger } from "../../../Misc/logger";
/**
* This is a support class that generates a series of packed texture sets.
* @see https://doc.babylonjs.com/babylon101/materials
*/
var TexturePacker = /** @class */ (function () {
    /**
    * Initializes a texture package series from an array of meshes or a single mesh.
    * @param name The name of the package
    * @param meshes The target meshes to compose the package from
    * @param options The arguments that texture packer should follow while building.
    * @param scene The scene which the textures are scoped to.
    * @returns TexturePacker
    */
    function TexturePacker(name, meshes, options, scene) {
        this.name = name;
        this.meshes = meshes;
        this.scene = scene;
        /**
         * Run through the options and set what ever defaults are needed that where not declared.
         */
        this.options = options;
        this.options.map = this.options.map || [
            'ambientTexture',
            'bumpTexture',
            'diffuseTexture',
            'emissiveTexture',
            'lightmapTexture',
            'opacityTexture',
            'reflectionTexture',
            'refractionTexture',
            'specularTexture'
        ];
        this.options.uvsIn = this.options.uvsIn || VertexBuffer.UVKind;
        this.options.uvsOut = this.options.uvsOut || VertexBuffer.UVKind;
        this.options.layout = this.options.layout || TexturePacker.LAYOUT_STRIP;
        if (this.options.layout === TexturePacker.LAYOUT_COLNUM) {
            this.options.colnum = this.options.colnum || 8;
        }
        this.options.updateInputMeshes = this.options.updateInputMeshes || true;
        this.options.disposeSources = this.options.disposeSources || true;
        this._expecting = 0;
        this.options.fillBlanks = this.options.fillBlanks || true;
        if (this.options.fillBlanks === true) {
            this.options.customFillColor = this.options.customFillColor || 'black';
        }
        this.options.frameSize = this.options.frameSize || 256;
        this.options.paddingRatio = this.options.paddingRatio || 0.0115;
        this._paddingValue = Math.ceil(this.options.frameSize * this.options.paddingRatio);
        //Make it an even padding Number.
        if (this._paddingValue % 2 !== 0) {
            this._paddingValue++;
        }
        this.options.paddingMode = this.options.paddingMode || TexturePacker.SUBUV_WRAP;
        if (this.options.paddingMode === TexturePacker.SUBUV_COLOR) {
            this.options.paddingColor = this.options.paddingColor || new Color4(0, 0, 0, 1.0);
        }
        this.sets = {};
        this.frames = [];
        return this;
    }
    /**
    * Starts the package process
    * @param resolve The promises resolution function
    * @returns TexturePacker
    */
    TexturePacker.prototype._createFrames = function (resolve) {
        var _this = this;
        var dtSize = this._calculateSize();
        var dtUnits = (new Vector2(1, 1)).divide(dtSize);
        var doneCount = 0;
        var expecting = this._expecting;
        var meshLength = this.meshes.length;
        var sKeys = Object.keys(this.sets);
        for (var i = 0; i < sKeys.length; i++) {
            var setName = sKeys[i];
            var dt = new DynamicTexture(this.name + '.TexturePack.' + setName + 'Set', { width: dtSize.x, height: dtSize.y }, this.scene, true, //Generate Mips
            Texture.TRILINEAR_SAMPLINGMODE, Engine.TEXTUREFORMAT_RGBA);
            var dtx = dt.getContext();
            dtx.fillStyle = 'rgba(0,0,0,0)';
            dtx.fillRect(0, 0, dtSize.x, dtSize.y);
            dt.update(false);
            this.sets[setName] = dt;
        }
        var baseSize = this.options.frameSize || 256;
        var padding = this._paddingValue;
        var tcs = baseSize + (2 * padding);
        var done = function () {
            _this._calculateMeshUVFrames(baseSize, padding, dtSize, dtUnits, _this.options.updateInputMeshes || false);
        };
        //Update the Textures
        for (var i = 0; i < meshLength; i++) {
            var m = this.meshes[i];
            var mat = m.material;
            var _loop_1 = function (j) {
                var tempTexture = new DynamicTexture('temp', tcs, this_1.scene, true);
                var tcx = tempTexture.getContext();
                var offset = this_1._getFrameOffset(i);
                var updateDt = function () {
                    doneCount++;
                    tempTexture.update(false);
                    var iDat = tcx.getImageData(0, 0, tcs, tcs);
                    //Update Set
                    var dt = _this.sets[setName];
                    var dtx = dt.getContext();
                    dtx.putImageData(iDat, dtSize.x * offset.x, dtSize.y * offset.y);
                    tempTexture.dispose();
                    dt.update(false);
                    if (doneCount == expecting) {
                        done();
                        resolve();
                        return;
                    }
                };
                var setName = sKeys[j] || '_blank';
                if (!mat || mat[setName] === null) {
                    tcx.fillStyle = 'rgba(0,0,0,0)';
                    if (this_1.options.fillBlanks) {
                        tcx.fillStyle = this_1.options.customFillColor;
                    }
                    tcx.fillRect(0, 0, tcs, tcs);
                    updateDt();
                }
                else {
                    var setTexture = mat[setName];
                    var img_1 = new Image();
                    if (setTexture instanceof DynamicTexture) {
                        img_1.src = setTexture.getContext().canvas.toDataURL("image/png");
                    }
                    else {
                        img_1.src = setTexture.url;
                    }
                    img_1.onload = function () {
                        tcx.fillStyle = 'rgba(0,0,0,0)';
                        tcx.fillRect(0, 0, tcs, tcs);
                        tempTexture.update(false);
                        tcx.setTransform(1, 0, 0, -1, 0, 0);
                        var cellOffsets = [0, 0, 1, 0, 1, 1, 0, 1, -1, 1, -1, 0, -1 - 1, 0, -1, 1, -1];
                        switch (_this.options.paddingMode) {
                            //Wrap Mode
                            case 0:
                                for (var i_1 = 0; i_1 < 9; i_1++) {
                                    tcx.drawImage(img_1, 0, 0, img_1.width, img_1.height, (padding) + (baseSize * cellOffsets[i_1]), ((padding) + (baseSize * cellOffsets[i_1 + 1])) - tcs, baseSize, baseSize);
                                }
                                break;
                            //Extend Mode
                            case 1:
                                for (var i_2 = 0; i_2 < padding; i_2++) {
                                    tcx.drawImage(img_1, 0, 0, img_1.width, img_1.height, i_2 + (baseSize * cellOffsets[0]), padding - tcs, baseSize, baseSize);
                                    tcx.drawImage(img_1, 0, 0, img_1.width, img_1.height, (padding * 2) - i_2, padding - tcs, baseSize, baseSize);
                                    tcx.drawImage(img_1, 0, 0, img_1.width, img_1.height, padding, i_2 - tcs, baseSize, baseSize);
                                    tcx.drawImage(img_1, 0, 0, img_1.width, img_1.height, padding, (padding * 2) - i_2 - tcs, baseSize, baseSize);
                                }
                                tcx.drawImage(img_1, 0, 0, img_1.width, img_1.height, (padding) + (baseSize * cellOffsets[0]), ((padding) + (baseSize * cellOffsets[1])) - tcs, baseSize, baseSize);
                                break;
                            //Color Mode
                            case 2:
                                tcx.fillStyle = (_this.options.paddingColor || Color3.Black()).toHexString();
                                tcx.fillRect(0, 0, tcs, -tcs);
                                tcx.clearRect(padding, padding, baseSize, baseSize);
                                tcx.drawImage(img_1, 0, 0, img_1.width, img_1.height, (padding) + (baseSize * cellOffsets[0]), ((padding) + (baseSize * cellOffsets[1])) - tcs, baseSize, baseSize);
                                break;
                        }
                        tcx.setTransform(1, 0, 0, 1, 0, 0);
                        updateDt();
                    };
                }
            };
            var this_1 = this;
            //Check if the material has the texture
            //Create a temporary canvas the same size as 1 frame
            //Then apply the texture to the center and the 8 offsets
            //Copy the Context and place in the correct frame on the DT
            for (var j = 0; j < sKeys.length; j++) {
                _loop_1(j);
            }
        }
    };
    /**
    * Calculates the Size of the Channel Sets
    * @returns Vector2
    */
    TexturePacker.prototype._calculateSize = function () {
        var meshLength = this.meshes.length || 0;
        var baseSize = this.options.frameSize || 0;
        var padding = this._paddingValue || 0;
        switch (this.options.layout) {
            case 0:
                //STRIP_LAYOUT
                return new Vector2((baseSize * meshLength) + (2 * padding * meshLength), (baseSize) + (2 * padding));
                break;
            case 1:
                //POWER2
                var sqrtCount = Math.max(2, Math.ceil(Math.sqrt(meshLength)));
                var size = (baseSize * sqrtCount) + (2 * padding * sqrtCount);
                return new Vector2(size, size);
                break;
            case 2:
                //COLNUM
                var cols = this.options.colnum || 1;
                var rowCnt = Math.max(1, Math.ceil(meshLength / cols));
                return new Vector2((baseSize * cols) + (2 * padding * cols), (baseSize * rowCnt) + (2 * padding * rowCnt));
                break;
        }
        return Vector2.Zero();
    };
    /**
    * Calculates the UV data for the frames.
    * @param baseSize the base frameSize
    * @param padding the base frame padding
    * @param dtSize size of the Dynamic Texture for that channel
    * @param dtUnits is 1/dtSize
    * @param update flag to update the input meshes
    */
    TexturePacker.prototype._calculateMeshUVFrames = function (baseSize, padding, dtSize, dtUnits, update) {
        var meshLength = this.meshes.length;
        for (var i = 0; i < meshLength; i++) {
            var m = this.meshes[i];
            var scale = new Vector2(baseSize / dtSize.x, baseSize / dtSize.y);
            var pOffset = dtUnits.clone().scale(padding);
            var frameOffset = this._getFrameOffset(i);
            var offset = frameOffset.add(pOffset);
            var frame = new TexturePackerFrame(i, scale, offset);
            this.frames.push(frame);
            //Update Output UVs
            if (update) {
                this._updateMeshUV(m, i);
                this._updateTextureReferences(m);
            }
        }
    };
    /**
    * Calculates the frames Offset.
    * @param index of the frame
    * @returns Vector2
    */
    TexturePacker.prototype._getFrameOffset = function (index) {
        var meshLength = this.meshes.length;
        var uvStep, yStep, xStep;
        switch (this.options.layout) {
            case 0:
                //STRIP_LAYOUT
                uvStep = 1 / meshLength;
                return new Vector2(index * uvStep, 0);
                break;
            case 1:
                //POWER2
                var sqrtCount = Math.max(2, Math.ceil(Math.sqrt(meshLength)));
                yStep = Math.floor(index / sqrtCount);
                xStep = index - (yStep * sqrtCount);
                uvStep = 1 / sqrtCount;
                return new Vector2(xStep * uvStep, yStep * uvStep);
                break;
            case 2:
                //COLNUM
                var cols = this.options.colnum || 1;
                var rowCnt = Math.max(1, Math.ceil(meshLength / cols));
                xStep = Math.floor(index / rowCnt);
                yStep = index - (xStep * rowCnt);
                uvStep = new Vector2(1 / cols, 1 / rowCnt);
                return new Vector2(xStep * uvStep.x, yStep * uvStep.y);
                break;
        }
        return Vector2.Zero();
    };
    /**
    * Updates a Mesh to the frame data
    * @param mesh that is the target
    * @param frameID or the frame index
    */
    TexturePacker.prototype._updateMeshUV = function (mesh, frameID) {
        var frame = this.frames[frameID];
        var uvIn = mesh.getVerticesData(this.options.uvsIn || VertexBuffer.UVKind);
        var uvOut = [];
        var toCount = 0;
        if (uvIn.length) {
            toCount = uvIn.length || 0;
        }
        for (var i = 0; i < toCount; i += 2) {
            uvOut.push((uvIn[i] * frame.scale.x) + frame.offset.x, (uvIn[i + 1] * frame.scale.y) + frame.offset.y);
        }
        mesh.setVerticesData(this.options.uvsOut || VertexBuffer.UVKind, uvOut);
    };
    /**
    * Updates a Meshes materials to use the texture packer channels
    * @param m is the mesh to target
    * @param force all channels on the packer to be set.
    */
    TexturePacker.prototype._updateTextureReferences = function (m, force) {
        if (force === void 0) { force = false; }
        var mat = m.material;
        var sKeys = Object.keys(this.sets);
        var _dispose = function (_t) {
            if ((_t.dispose)) {
                _t.dispose();
            }
        };
        for (var i = 0; i < sKeys.length; i++) {
            var setName = sKeys[i];
            if (!force) {
                if (!mat) {
                    return;
                }
                if (mat[setName] !== null) {
                    _dispose(mat[setName]);
                    mat[setName] = this.sets[setName];
                }
            }
            else {
                if (mat[setName] !== null) {
                    _dispose(mat[setName]);
                }
                mat[setName] = this.sets[setName];
            }
        }
    };
    /**
    * Public method to set a Mesh to a frame
    * @param m that is the target
    * @param frameID or the frame index
    * @param updateMaterial trigger for if the Meshes attached Material be updated?
    */
    TexturePacker.prototype.setMeshToFrame = function (m, frameID, updateMaterial) {
        if (updateMaterial === void 0) { updateMaterial = false; }
        this._updateMeshUV(m, frameID);
        if (updateMaterial) {
            this._updateTextureReferences(m, true);
        }
    };
    /**
    * Starts the async promise to compile the texture packer.
    * @returns Promise<void>
    */
    TexturePacker.prototype.processAsync = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            try {
                if (_this.meshes.length === 0) {
                    //Must be a JSON load!
                    resolve();
                    return;
                }
                var done_1 = 0;
                var doneCheck_1 = function (mat) {
                    done_1++;
                    //Check Status of all Textures on all meshes, till they are ready.
                    if (_this.options.map) {
                        for (var j = 0; j < _this.options.map.length; j++) {
                            var index = _this.options.map[j];
                            var t = mat[index];
                            if (t !== null) {
                                if (!_this.sets[_this.options.map[j]]) {
                                    _this.sets[_this.options.map[j]] = true;
                                }
                                _this._expecting++;
                            }
                        }
                        if (done_1 === _this.meshes.length) {
                            _this._createFrames(resolve);
                        }
                    }
                };
                var _loop_2 = function (i) {
                    var mesh = _this.meshes[i];
                    var material = mesh.material;
                    if (!material) {
                        done_1++;
                        if (done_1 === _this.meshes.length) {
                            return { value: _this._createFrames(resolve) };
                        }
                        return "continue";
                    }
                    material.forceCompilationAsync(mesh).then(function () {
                        doneCheck_1(material);
                    });
                };
                for (var i = 0; i < _this.meshes.length; i++) {
                    var state_1 = _loop_2(i);
                    if (typeof state_1 === "object")
                        return state_1.value;
                }
            }
            catch (e) {
                return reject(e);
            }
        });
    };
    /**
    * Disposes all textures associated with this packer
    */
    TexturePacker.prototype.dispose = function () {
        var sKeys = Object.keys(this.sets);
        for (var i = 0; i < sKeys.length; i++) {
            var channel = sKeys[i];
            this.sets[channel].dispose();
        }
    };
    /**
    * Starts the download process for all the channels converting them to base64 data and embedding it all in a JSON file.
    * @param imageType is the image type to use.
    * @param quality of the image if downloading as jpeg, Ranges from >0 to 1.
    */
    TexturePacker.prototype.download = function (imageType, quality) {
        var _this = this;
        if (imageType === void 0) { imageType = 'png'; }
        if (quality === void 0) { quality = 1; }
        setTimeout(function () {
            var pack = {
                name: _this.name,
                sets: {},
                options: {},
                frames: []
            };
            var sKeys = Object.keys(_this.sets);
            var oKeys = Object.keys(_this.options);
            try {
                for (var i = 0; i < sKeys.length; i++) {
                    var channel = sKeys[i];
                    var dt = _this.sets[channel];
                    pack.sets[channel] = dt.getContext().canvas.toDataURL('image/' + imageType, quality);
                }
                for (var i = 0; i < oKeys.length; i++) {
                    var opt = oKeys[i];
                    pack.options[opt] = _this.options[opt];
                }
                for (var i = 0; i < _this.frames.length; i++) {
                    var _f = _this.frames[i];
                    pack.frames.push(_f.scale.x, _f.scale.y, _f.offset.x, _f.offset.y);
                }
            }
            catch (err) {
                Logger.Warn("Unable to download: " + err);
                return;
            }
            var data = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(pack, null, 4));
            var _a = document.createElement('a');
            _a.setAttribute("href", data);
            _a.setAttribute("download", _this.name + "_texurePackage.json");
            document.body.appendChild(_a);
            _a.click();
            _a.remove();
        }, 0);
    };
    /**
    * Public method to load a texturePacker JSON file.
    * @param data of the JSON file in string format.
    */
    TexturePacker.prototype.updateFromJSON = function (data) {
        try {
            var parsedData = JSON.parse(data);
            this.name = parsedData.name;
            var _options = Object.keys(parsedData.options);
            for (var i = 0; i < _options.length; i++) {
                this.options[_options[i]] = parsedData.options[_options[i]];
            }
            for (var i = 0; i < parsedData.frames.length; i += 4) {
                var frame = new TexturePackerFrame(i / 4, new Vector2(parsedData.frames[i], parsedData.frames[i + 1]), new Vector2(parsedData.frames[i + 2], parsedData.frames[i + 3]));
                this.frames.push(frame);
            }
            var channels = Object.keys(parsedData.sets);
            for (var i = 0; i < channels.length; i++) {
                var _t = new Texture(parsedData.sets[channels[i]], this.scene, false, false);
                this.sets[channels[i]] = _t;
            }
        }
        catch (err) {
            Logger.Warn("Unable to update from JSON: " + err);
        }
    };
    /** Packer Layout Constant 0 */
    TexturePacker.LAYOUT_STRIP = 0;
    /** Packer Layout Constant 1 */
    TexturePacker.LAYOUT_POWER2 = 1;
    /** Packer Layout Constant 2 */
    TexturePacker.LAYOUT_COLNUM = 2;
    /** Packer Layout Constant 0 */
    TexturePacker.SUBUV_WRAP = 0;
    /** Packer Layout Constant 1 */
    TexturePacker.SUBUV_EXTEND = 1;
    /** Packer Layout Constant 2 */
    TexturePacker.SUBUV_COLOR = 2;
    return TexturePacker;
}());
export { TexturePacker };
//# sourceMappingURL=packer.js.map