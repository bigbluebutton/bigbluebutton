{"version":3,"file":"packer.js","sourceRoot":"","sources":["../../../../../sourceES6/core/Materials/Textures/Packer/packer.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,MAAM,EAAE,MAAM,yBAAyB,CAAC;AAEjD,OAAO,EAAE,YAAY,EAAE,MAAM,wBAAwB,CAAC;AAGtD,OAAO,EAAE,OAAO,EAAE,MAAM,YAAY,CAAC;AACrC,OAAO,EAAE,cAAc,EAAE,MAAM,mBAAmB,CAAC;AAEnD,OAAO,EAAE,OAAO,EAAE,MAAM,4BAA4B,CAAC;AACrD,OAAO,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,2BAA2B,CAAC;AAC3D,OAAO,EAAE,kBAAkB,EAAE,MAAM,SAAS,CAAC;AAC7C,OAAO,EAAE,MAAM,EAAE,MAAM,sBAAsB,CAAC;AAqG9C;;;EAGE;AACF;IA2CI;;;;;;;MAOE;IACF,uBAAY,IAAY,EAAE,MAAsB,EAAE,OAA8B,EAAE,KAAY;QAE1F,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;QACjB,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QAEnB;;WAEG;QACH,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QACvB,IAAI,CAAC,OAAO,CAAC,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,IAAI;YAC/B,gBAAgB;YAChB,aAAa;YACb,gBAAgB;YAChB,iBAAiB;YACjB,iBAAiB;YACjB,gBAAgB;YAChB,mBAAmB;YACnB,mBAAmB;YACnB,iBAAiB;SACpB,CAAC;QAEN,IAAI,CAAC,OAAO,CAAC,KAAK,GAAG,IAAI,CAAC,OAAO,CAAC,KAAK,IAAI,YAAY,CAAC,MAAM,CAAC;QAC/D,IAAI,CAAC,OAAO,CAAC,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,IAAI,YAAY,CAAC,MAAM,CAAC;QACjE,IAAI,CAAC,OAAO,CAAC,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,IAAI,aAAa,CAAC,YAAY,CAAC;QAExE,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,KAAK,aAAa,CAAC,aAAa,EAAE;YACrD,IAAI,CAAC,OAAO,CAAC,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,IAAI,CAAC,CAAC;SAClD;QAED,IAAI,CAAC,OAAO,CAAC,iBAAiB,GAAG,IAAI,CAAC,OAAO,CAAC,iBAAiB,IAAI,IAAI,CAAC;QACxE,IAAI,CAAC,OAAO,CAAC,cAAc,GAAG,IAAI,CAAC,OAAO,CAAC,cAAc,IAAI,IAAI,CAAC;QAClE,IAAI,CAAC,UAAU,GAAG,CAAC,CAAC;QAEpB,IAAI,CAAC,OAAO,CAAC,UAAU,GAAG,IAAI,CAAC,OAAO,CAAC,UAAU,IAAI,IAAI,CAAC;QAE1D,IAAI,IAAI,CAAC,OAAO,CAAC,UAAU,KAAK,IAAI,EAAE;YAClC,IAAI,CAAC,OAAO,CAAC,eAAe,GAAG,IAAI,CAAC,OAAO,CAAC,eAAe,IAAI,OAAO,CAAC;SAC1E;QAED,IAAI,CAAC,OAAO,CAAC,SAAS,GAAG,IAAI,CAAC,OAAO,CAAC,SAAS,IAAI,GAAG,CAAC;QACvD,IAAI,CAAC,OAAO,CAAC,YAAY,GAAG,IAAI,CAAC,OAAO,CAAC,YAAY,IAAI,MAAM,CAAC;QAEhE,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,SAAS,GAAG,IAAI,CAAC,OAAO,CAAC,YAAY,CAAC,CAAC;QAEnF,iCAAiC;QACjC,IAAI,IAAI,CAAC,aAAa,GAAG,CAAC,KAAK,CAAC,EAAE;YAC9B,IAAI,CAAC,aAAa,EAAE,CAAC;SACxB;QAED,IAAI,CAAC,OAAO,CAAC,WAAW,GAAG,IAAI,CAAC,OAAO,CAAC,WAAW,IAAI,aAAa,CAAC,UAAU,CAAC;QAEhF,IAAI,IAAI,CAAC,OAAO,CAAC,WAAW,KAAK,aAAa,CAAC,WAAW,EAAE;YACxD,IAAI,CAAC,OAAO,CAAC,YAAY,GAAG,IAAI,CAAC,OAAO,CAAC,YAAY,IAAI,IAAI,MAAM,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,CAAC,CAAC;SACrF;QAED,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC;QACf,IAAI,CAAC,MAAM,GAAG,EAAE,CAAC;QAEjB,OAAO,IAAI,CAAC;IAChB,CAAC;IAED;;;;MAIE;IACM,qCAAa,GAArB,UAAsB,OAAmB;QAAzC,iBAiNC;QA/MG,IAAI,MAAM,GAAG,IAAI,CAAC,cAAc,EAAE,CAAC;QACnC,IAAI,OAAO,GAAG,CAAC,IAAI,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;QACjD,IAAI,SAAS,GAAG,CAAC,CAAC;QAClB,IAAI,SAAS,GAAG,IAAI,CAAC,UAAU,CAAC;QAChC,IAAI,UAAU,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC;QAEpC,IAAI,KAAK,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACnC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACnC,IAAI,OAAO,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;YAEvB,IAAI,EAAE,GAAG,IAAI,cAAc,CAAC,IAAI,CAAC,IAAI,GAAG,eAAe,GAAG,OAAO,GAAG,KAAK,EACjE,EAAE,KAAK,EAAE,MAAM,CAAC,CAAC,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC,EAAE,EACrC,IAAI,CAAC,KAAK,EACV,IAAI,EAAE,eAAe;YACrB,OAAO,CAAC,sBAAsB,EAC9B,MAAM,CAAC,kBAAkB,CAC5B,CAAC;YAEN,IAAI,GAAG,GAAG,EAAE,CAAC,UAAU,EAAE,CAAC;YAC1B,GAAG,CAAC,SAAS,GAAG,eAAe,CAAC;YAChC,GAAG,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,MAAM,CAAC,CAAC,EAAE,MAAM,CAAC,CAAC,CAAC,CAAE;YACxC,EAAE,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;YAChB,IAAI,CAAC,IAAY,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC;SACpC;QAED,IAAI,QAAQ,GAAG,IAAI,CAAC,OAAO,CAAC,SAAS,IAAI,GAAG,CAAC;QAC7C,IAAI,OAAO,GAAG,IAAI,CAAC,aAAa,CAAC;QACjC,IAAI,GAAG,GAAG,QAAQ,GAAG,CAAC,CAAC,GAAG,OAAO,CAAC,CAAC;QAEnC,IAAM,IAAI,GAAG;YACT,KAAI,CAAC,sBAAsB,CAAC,QAAQ,EAAE,OAAO,EAAE,MAAM,EAAE,OAAO,EAAE,KAAI,CAAC,OAAO,CAAC,iBAAiB,IAAI,KAAK,CAAC,CAAC;QAC7G,CAAC,CAAC;QAEF,qBAAqB;QACrB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,UAAU,EAAE,CAAC,EAAE,EAAE;YACjC,IAAI,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;YACvB,IAAI,GAAG,GAAG,CAAC,CAAC,QAAQ,CAAC;oCAOZ,CAAC;gBACN,IAAI,WAAW,GAAG,IAAI,cAAc,CAAC,MAAM,EAAE,GAAG,EAAE,OAAK,KAAK,EAAE,IAAI,CAAC,CAAC;gBACpE,IAAI,GAAG,GAAG,WAAW,CAAC,UAAU,EAAE,CAAC;gBACnC,IAAI,MAAM,GAAG,OAAK,eAAe,CAAC,CAAC,CAAC,CAAC;gBAErC,IAAM,QAAQ,GAAG;oBACb,SAAS,EAAE,CAAC;oBACZ,WAAW,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;oBAC1B,IAAI,IAAI,GAAG,GAAG,CAAC,YAAY,CAAC,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;oBAE5C,YAAY;oBACZ,IAAI,EAAE,GAAI,KAAI,CAAC,IAAY,CAAC,OAAO,CAAC,CAAC;oBACrC,IAAI,GAAG,GAAG,EAAE,CAAC,UAAU,EAAE,CAAC;oBAC1B,GAAG,CAAC,YAAY,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC,GAAG,MAAM,CAAC,CAAC,EAAE,MAAM,CAAC,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;oBACjE,WAAW,CAAC,OAAO,EAAE,CAAC;oBACtB,EAAE,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;oBACjB,IAAI,SAAS,IAAI,SAAS,EAAE;wBACxB,IAAI,EAAE,CAAC;wBACP,OAAO,EAAE,CAAC;wBACV,OAAO;qBACV;gBACL,CAAC,CAAC;gBAEF,IAAI,OAAO,GAAG,KAAK,CAAC,CAAC,CAAC,IAAI,QAAQ,CAAC;gBACnC,IAAI,CAAC,GAAG,IAAK,GAAW,CAAC,OAAO,CAAC,KAAK,IAAI,EAAE;oBACxC,GAAG,CAAC,SAAS,GAAG,eAAe,CAAC;oBAEhC,IAAI,OAAK,OAAO,CAAC,UAAU,EAAE;wBACzB,GAAG,CAAC,SAAS,GAAI,OAAK,OAAO,CAAC,eAA0B,CAAC;qBAC5D;oBAED,GAAG,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;oBAE7B,QAAQ,EAAE,CAAC;iBAEd;qBAAM;oBAEH,IAAI,UAAU,GAAI,GAAW,CAAC,OAAO,CAAC,CAAC;oBACvC,IAAI,KAAG,GAAG,IAAI,KAAK,EAAE,CAAC;oBAEtB,IAAI,UAAU,YAAY,cAAc,EAAE;wBACtC,KAAG,CAAC,GAAG,GAAG,UAAU,CAAC,UAAU,EAAE,CAAC,MAAM,CAAC,SAAS,CAAC,WAAW,CAAC,CAAC;qBACnE;yBAAM;wBACH,KAAG,CAAC,GAAG,GAAG,UAAW,CAAC,GAAG,CAAC;qBAC7B;oBAED,KAAG,CAAC,MAAM,GAAG;wBACT,GAAG,CAAC,SAAS,GAAG,eAAe,CAAC;wBAChC,GAAG,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;wBAC7B,WAAW,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;wBAE1B,GAAG,CAAC,YAAY,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;wBACpC,IAAI,WAAW,GAAG,CAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;wBAEhF,QAAQ,KAAI,CAAC,OAAO,CAAC,WAAW,EAAC;4BAC7B,WAAW;4BACX,KAAK,CAAC;gCACF,KAAK,IAAI,GAAC,GAAG,CAAC,EAAE,GAAC,GAAG,CAAC,EAAE,GAAC,EAAE,EAAE;oCACxB,GAAG,CAAC,SAAS,CACT,KAAG,EACH,CAAC,EACD,CAAC,EACD,KAAG,CAAC,KAAK,EACT,KAAG,CAAC,MAAM,EACV,CAAC,OAAO,CAAC,GAAG,CAAC,QAAQ,GAAG,WAAW,CAAC,GAAC,CAAC,CAAC,EACvC,CAAC,CAAC,OAAO,CAAC,GAAG,CAAC,QAAQ,GAAG,WAAW,CAAC,GAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,EACnD,QAAQ,EACR,QAAQ,CACX,CAAC;iCACL;gCACL,MAAM;4BACN,aAAa;4BACb,KAAK,CAAC;gCACF,KAAK,IAAI,GAAC,GAAG,CAAC,EAAE,GAAC,GAAG,OAAO,EAAE,GAAC,EAAE,EAAE;oCAC9B,GAAG,CAAC,SAAS,CACT,KAAG,EACH,CAAC,EACD,CAAC,EACD,KAAG,CAAC,KAAK,EACT,KAAG,CAAC,MAAM,EACV,GAAC,GAAG,CAAC,QAAQ,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC,EAC/B,OAAO,GAAG,GAAG,EACb,QAAQ,EACR,QAAQ,CACX,CAAC;oCAEF,GAAG,CAAC,SAAS,CACT,KAAG,EACH,CAAC,EACD,CAAC,EACD,KAAG,CAAC,KAAK,EACT,KAAG,CAAC,MAAM,EACV,CAAC,OAAO,GAAG,CAAC,CAAC,GAAG,GAAC,EACjB,OAAO,GAAG,GAAG,EACb,QAAQ,EACR,QAAQ,CACX,CAAC;oCAEF,GAAG,CAAC,SAAS,CACT,KAAG,EACH,CAAC,EACD,CAAC,EACD,KAAG,CAAC,KAAK,EACT,KAAG,CAAC,MAAM,EACV,OAAO,EACP,GAAC,GAAG,GAAG,EACP,QAAQ,EACR,QAAQ,CACX,CAAC;oCAEF,GAAG,CAAC,SAAS,CACT,KAAG,EACH,CAAC,EACD,CAAC,EACD,KAAG,CAAC,KAAK,EACT,KAAG,CAAC,MAAM,EACV,OAAO,EACP,CAAC,OAAO,GAAG,CAAC,CAAC,GAAG,GAAC,GAAG,GAAG,EACvB,QAAQ,EACR,QAAQ,CACX,CAAC;iCACL;gCAED,GAAG,CAAC,SAAS,CACT,KAAG,EACH,CAAC,EACD,CAAC,EACD,KAAG,CAAC,KAAK,EACT,KAAG,CAAC,MAAM,EACV,CAAC,OAAO,CAAC,GAAG,CAAC,QAAQ,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC,EACvC,CAAC,CAAC,OAAO,CAAC,GAAG,CAAC,QAAQ,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,EAC/C,QAAQ,EACR,QAAQ,CACX,CAAC;gCAEN,MAAM;4BACN,YAAY;4BACZ,KAAK,CAAC;gCAEH,GAAG,CAAC,SAAS,GAAG,CAAC,KAAI,CAAC,OAAO,CAAC,YAAY,IAAI,MAAM,CAAC,KAAK,EAAE,CAAC,CAAC,WAAW,EAAE,CAAC;gCAC5E,GAAG,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,GAAG,CAAC,CAAC;gCAC9B,GAAG,CAAC,SAAS,CAAC,OAAO,EAAE,OAAO,EAAE,QAAQ,EAAE,QAAQ,CAAC,CAAC;gCACpD,GAAG,CAAC,SAAS,CACR,KAAG,EACH,CAAC,EACD,CAAC,EACD,KAAG,CAAC,KAAK,EACT,KAAG,CAAC,MAAM,EACV,CAAC,OAAO,CAAC,GAAG,CAAC,QAAQ,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC,EACvC,CAAC,CAAC,OAAO,CAAC,GAAG,CAAC,QAAQ,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,EAC/C,QAAQ,EACR,QAAQ,CACX,CAAC;gCAEN,MAAM;yBACT;wBAED,GAAG,CAAC,YAAY,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;wBAEnC,QAAQ,EAAE,CAAC;oBACf,CAAC,CAAC;iBACL;;;YAtKL,uCAAuC;YACvC,oDAAoD;YACpD,wDAAwD;YACxD,2DAA2D;YAE3D,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE;wBAA5B,CAAC;aAkKT;SACJ;IACL,CAAC;IAED;;;MAGE;IACM,sCAAc,GAAtB;QAEI,IAAI,UAAU,GAAW,IAAI,CAAC,MAAM,CAAC,MAAM,IAAI,CAAC,CAAC;QACjD,IAAI,QAAQ,GAAY,IAAI,CAAC,OAAO,CAAC,SAAS,IAAI,CAAC,CAAC;QACpD,IAAI,OAAO,GAAW,IAAI,CAAC,aAAa,IAAI,CAAC,CAAC;QAE9C,QAAQ,IAAI,CAAC,OAAO,CAAC,MAAM,EAAC;YACxB,KAAK,CAAC;gBACF,cAAc;gBACd,OAAO,IAAI,OAAO,CACd,CAAC,QAAQ,GAAG,UAAU,CAAC,GAAG,CAAC,CAAC,GAAG,OAAO,GAAG,UAAU,CAAC,EACpD,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,GAAG,OAAO,CAAC,CAC7B,CAAC;gBACN,MAAM;YACN,KAAK,CAAC;gBACF,QAAQ;gBACR,IAAI,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;gBAC9D,IAAI,IAAI,GAAG,CAAC,QAAQ,GAAG,SAAS,CAAC,GAAG,CAAC,CAAC,GAAG,OAAO,GAAG,SAAS,CAAC,CAAC;gBAC9D,OAAO,IAAI,OAAO,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;gBACnC,MAAM;YACN,KAAK,CAAC;gBACF,QAAQ;gBACR,IAAI,IAAI,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,IAAI,CAAC,CAAC;gBACpC,IAAI,MAAM,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,CAAC,CAAC;gBACvD,OAAO,IAAI,OAAO,CACd,CAAC,QAAQ,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,GAAG,OAAO,GAAG,IAAI,CAAC,EACxC,CAAC,QAAQ,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC,GAAG,OAAO,GAAG,MAAM,CAAC,CAC/C,CAAC;gBACN,MAAM;SACT;QAED,OAAO,OAAO,CAAC,IAAI,EAAE,CAAC;IAC1B,CAAC;IAED;;;;;;;MAOE;IACM,8CAAsB,GAA9B,UAA+B,QAAgB,EAAE,OAAe,EAAE,MAAe,EAAE,OAAgB,EAAE,MAAe;QAChH,IAAI,UAAU,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC;QAEpC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,UAAU,EAAE,CAAC,EAAE,EAAE;YACjC,IAAI,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;YAEvB,IAAI,KAAK,GAAG,IAAI,OAAO,CACnB,QAAQ,GAAG,MAAM,CAAC,CAAC,EACnB,QAAQ,GAAG,MAAM,CAAC,CAAC,CACtB,CAAC;YAEF,IAAI,OAAO,GAAY,OAAO,CAAC,KAAK,EAAE,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;YACtD,IAAI,WAAW,GAAY,IAAI,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC;YACnD,IAAI,MAAM,GAAY,WAAW,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;YAE/C,IAAI,KAAK,GAAuB,IAAI,kBAAkB,CAAC,CAAC,EAAE,KAAK,EAAE,MAAM,CAAC,CAAC;YAEzE,IAAI,CAAC,MAAM,CAAC,IAAI,CACZ,KAAK,CACR,CAAC;YAEF,mBAAmB;YACnB,IAAI,MAAM,EAAE;gBACR,IAAI,CAAC,aAAa,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;gBACzB,IAAI,CAAC,wBAAwB,CAAC,CAAC,CAAC,CAAC;aACpC;SACJ;IACL,CAAC;IAED;;;;MAIE;IACM,uCAAe,GAAvB,UAAwB,KAAa;QAEjC,IAAI,UAAU,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC;QACpC,IAAI,MAAM,EAAE,KAAK,EAAE,KAAK,CAAC;QAEzB,QAAQ,IAAI,CAAC,OAAO,CAAC,MAAM,EAAC;YACxB,KAAK,CAAC;gBACF,cAAc;gBACd,MAAM,GAAG,CAAC,GAAG,UAAU,CAAC;gBACxB,OAAO,IAAI,OAAO,CACd,KAAK,GAAG,MAAM,EACd,CAAC,CACJ,CAAC;gBACN,MAAM;YACN,KAAK,CAAC;gBACF,QAAQ;gBACR,IAAI,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;gBAC9D,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,GAAG,SAAS,CAAC,CAAC;gBACtC,KAAK,GAAG,KAAK,GAAG,CAAC,KAAK,GAAG,SAAS,CAAC,CAAC;gBACpC,MAAM,GAAG,CAAC,GAAG,SAAS,CAAC;gBACvB,OAAO,IAAI,OAAO,CAAC,KAAK,GAAG,MAAM,EAAG,KAAK,GAAG,MAAM,CAAC,CAAC;gBACxD,MAAM;YACN,KAAK,CAAC;gBACF,QAAQ;gBACR,IAAI,IAAI,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,IAAI,CAAC,CAAC;gBACpC,IAAI,MAAM,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,CAAC,CAAC;gBACvD,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,GAAG,MAAM,CAAC,CAAC;gBACnC,KAAK,GAAG,KAAK,GAAG,CAAC,KAAK,GAAG,MAAM,CAAC,CAAC;gBACjC,MAAM,GAAG,IAAI,OAAO,CAAC,CAAC,GAAG,IAAI,EAAE,CAAC,GAAG,MAAM,CAAC,CAAC;gBAC3C,OAAO,IAAI,OAAO,CAAC,KAAK,GAAG,MAAM,CAAC,CAAC,EAAG,KAAK,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;gBAC5D,MAAM;SACT;QAED,OAAO,OAAO,CAAC,IAAI,EAAE,CAAC;IAC1B,CAAC;IAED;;;;MAIE;IACM,qCAAa,GAArB,UAAsB,IAAkB,EAAE,OAAe;QACrD,IAAI,KAAK,GAAwB,IAAI,CAAC,MAAc,CAAC,OAAO,CAAC,CAAC;QAC9D,IAAI,IAAI,GAAG,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,IAAI,YAAY,CAAC,MAAM,CAAC,CAAC;QAC3E,IAAI,KAAK,GAAG,EAAE,CAAC;QACf,IAAI,OAAO,GAAG,CAAC,CAAC;QAEhB,IAAI,IAAK,CAAC,MAAM,EAAE;YACd,OAAO,GAAG,IAAK,CAAC,MAAM,IAAI,CAAC,CAAC;SAC/B;QAED,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,EAAE,CAAC,IAAI,CAAC,EAAE;YACjC,KAAK,CAAC,IAAI,CACN,CAAE,IAAY,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC,EACnD,CAAE,IAAY,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC,CAC1D,CAAC;SACL;QAED,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,IAAI,YAAY,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;IAC5E,CAAC;IAED;;;;MAIE;IACM,gDAAwB,GAAhC,UAAiC,CAAe,EAAE,KAAsB;QAAtB,sBAAA,EAAA,aAAsB;QACpE,IAAI,GAAG,GAAG,CAAC,CAAC,QAAQ,CAAC;QACrB,IAAI,KAAK,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAEnC,IAAI,QAAQ,GAAG,UAAC,EAAO;YAClB,IAAI,CAAC,EAAE,CAAC,OAAO,CAAC,EAAE;gBACf,EAAE,CAAC,OAAO,EAAE,CAAC;aACf;QACN,CAAC,CAAC;QAEF,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACnC,IAAI,OAAO,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;YACvB,IAAI,CAAC,KAAK,EAAE;gBACR,IAAI,CAAC,GAAG,EAAE;oBACN,OAAO;iBACV;gBACD,IAAK,GAAW,CAAC,OAAO,CAAC,KAAK,IAAI,EAAE;oBAChC,QAAQ,CAAE,GAAW,CAAC,OAAO,CAAC,CAAC,CAAC;oBAC/B,GAAW,CAAC,OAAO,CAAC,GAAI,IAAI,CAAC,IAAY,CAAC,OAAO,CAAC,CAAC;iBACvD;aACJ;iBAAM;gBACH,IAAK,GAAW,CAAC,OAAO,CAAC,KAAK,IAAI,EAAE;oBAChC,QAAQ,CAAE,GAAW,CAAC,OAAO,CAAC,CAAC,CAAC;iBACnC;gBACA,GAAW,CAAC,OAAO,CAAC,GAAI,IAAI,CAAC,IAAY,CAAC,OAAO,CAAC,CAAC;aACvD;SACJ;IACL,CAAC;IAED;;;;;MAKE;IACK,sCAAc,GAArB,UAAsB,CAAe,EAAE,OAAe,EAAE,cAA+B;QAA/B,+BAAA,EAAA,sBAA+B;QACnF,IAAI,CAAC,aAAa,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC;QAC/B,IAAI,cAAc,EAAE;YAChB,IAAI,CAAC,wBAAwB,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;SAC1C;IACL,CAAC;IAED;;;MAGE;IACK,oCAAY,GAAnB;QAAA,iBAqDC;QApDO,OAAO,IAAI,OAAO,CAAE,UAAC,OAAO,EAAE,MAAM;YAChC,IAAI;gBACA,IAAI,KAAI,CAAC,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE;oBAC1B,sBAAsB;oBACtB,OAAO,EAAE,CAAC;oBACV,OAAO;iBACV;gBACD,IAAI,MAAI,GAAG,CAAC,CAAC;gBACb,IAAM,WAAS,GAAG,UAAC,GAAa;oBAC5B,MAAI,EAAE,CAAC;oBACP,kEAAkE;oBAClE,IAAI,KAAI,CAAC,OAAO,CAAC,GAAG,EAAE;wBAClB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAI,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;4BAC9C,IAAI,KAAK,GAAW,KAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;4BACxC,IAAI,CAAC,GAAgC,GAAW,CAAC,KAAK,CAAC,CAAC;4BAExD,IAAI,CAAC,KAAK,IAAI,EAAE;gCACZ,IAAI,CAAE,KAAI,CAAC,IAAY,CAAC,KAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE;oCACzC,KAAI,CAAC,IAAY,CAAC,KAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC;iCAClD;gCAED,KAAI,CAAC,UAAU,EAAE,CAAC;6BACrB;yBACJ;wBAED,IAAI,MAAI,KAAK,KAAI,CAAC,MAAM,CAAC,MAAM,EAAE;4BAC7B,KAAI,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC;yBAC/B;qBACJ;gBACL,CAAC,CAAC;wCAEO,CAAC;oBAEN,IAAI,IAAI,GAAG,KAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;oBAC1B,IAAI,QAAQ,GAAyB,IAAI,CAAC,QAAQ,CAAC;oBAEnD,IAAI,CAAC,QAAQ,EAAE;wBACX,MAAI,EAAE,CAAC;wBACP,IAAI,MAAI,KAAK,KAAI,CAAC,MAAM,CAAC,MAAM,EAAE;4CACtB,KAAI,CAAC,aAAa,CAAC,OAAO,CAAC;yBACrC;;qBAEJ;oBAED,QAAQ,CAAC,qBAAqB,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC;wBACtC,WAAS,CAAE,QAAqB,CAAC,CAAC;oBACtC,CAAC,CAAC,CAAC;;gBAfP,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAI,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE;0CAAlC,CAAC;;;iBAgBT;aACJ;YAAC,OAAO,CAAC,EAAE;gBACR,OAAO,MAAM,CAAC,CAAC,CAAC,CAAC;aACpB;QACL,CAAC,CAAC,CAAC;IACX,CAAC;IAED;;MAEE;IACK,+BAAO,GAAd;QACI,IAAI,KAAK,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACnC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACnC,IAAI,OAAO,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;YACtB,IAAI,CAAC,IAAY,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,CAAC;SACzC;IACL,CAAC;IAED;;;;MAIE;IACK,gCAAQ,GAAf,UAAgB,SAAyB,EAAE,OAAmB;QAA9D,iBAwCC;QAxCe,0BAAA,EAAA,iBAAyB;QAAE,wBAAA,EAAA,WAAmB;QAC1D,UAAU,CAAC;YACP,IAAI,IAAI,GAAG;gBACP,IAAI,EAAG,KAAI,CAAC,IAAI;gBAChB,IAAI,EAAG,EAAE;gBACT,OAAO,EAAE,EAAE;gBACX,MAAM,EAAG,EAAE;aACd,CAAC;YAEF,IAAI,KAAK,GAAG,MAAM,CAAC,IAAI,CAAC,KAAI,CAAC,IAAI,CAAC,CAAC;YACnC,IAAI,KAAK,GAAG,MAAM,CAAC,IAAI,CAAC,KAAI,CAAC,OAAO,CAAC,CAAC;YACtC,IAAI;gBACA,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;oBACnC,IAAI,OAAO,GAAW,KAAK,CAAC,CAAC,CAAC,CAAC;oBAC/B,IAAI,EAAE,GAAK,KAAI,CAAC,IAAY,CAAC,OAAO,CAAC,CAAC;oBACrC,IAAI,CAAC,IAAY,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC,UAAU,EAAE,CAAC,MAAM,CAAC,SAAS,CAAC,QAAQ,GAAG,SAAS,EAAE,OAAO,CAAC,CAAC;iBACjG;gBACD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;oBACnC,IAAI,GAAG,GAAW,KAAK,CAAC,CAAC,CAAC,CAAC;oBAC1B,IAAI,CAAC,OAAe,CAAC,GAAG,CAAC,GAAI,KAAI,CAAC,OAAe,CAAC,GAAG,CAAC,CAAC;iBAC3D;gBACD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAI,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;oBACzC,IAAI,EAAE,GAAG,KAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;oBACvB,IAAI,CAAC,MAAwB,CAAC,IAAI,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC,MAAM,CAAC,CAAC,EAAE,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;iBACzF;aAEJ;YAAC,OAAO,GAAG,EAAE;gBACV,MAAM,CAAC,IAAI,CAAC,sBAAsB,GAAG,GAAG,CAAC,CAAC;gBAC1C,OAAO;aACV;YAED,IAAI,IAAI,GAAG,+BAA+B,GAAG,kBAAkB,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC,CAAC;YAC/F,IAAI,EAAE,GAAG,QAAQ,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC;YACrC,EAAE,CAAC,YAAY,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;YAC9B,EAAE,CAAC,YAAY,CAAC,UAAU,EAAE,KAAI,CAAC,IAAI,GAAG,qBAAqB,CAAC,CAAC;YAC/D,QAAQ,CAAC,IAAI,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC;YAC9B,EAAE,CAAC,KAAK,EAAE,CAAC;YACX,EAAE,CAAC,MAAM,EAAE,CAAC;QAEhB,CAAC,EAAE,CAAC,CAAC,CAAC;IACV,CAAC;IAED;;;MAGE;IACK,sCAAc,GAArB,UAAsB,IAAY;QAC9B,IAAI;YACA,IAAI,UAAU,GAAuB,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;YACtD,IAAI,CAAC,IAAI,GAAG,UAAU,CAAC,IAAI,CAAC;YAC5B,IAAI,QAAQ,GAAG,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC;YAE/C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBACrC,IAAI,CAAC,OAAe,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,GAAI,UAAU,CAAC,OAAe,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;aACjF;YAED,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,UAAU,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC,IAAI,CAAC,EAAE;gBAClD,IAAI,KAAK,GAAuB,IAAI,kBAAkB,CAClD,CAAC,GAAG,CAAC,EACL,IAAI,OAAO,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,UAAU,CAAC,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAC3D,IAAI,OAAO,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE,UAAU,CAAC,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAClE,CAAC;gBACN,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;aACvB;YAED,IAAI,QAAQ,GAAG,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;YAE5C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBACtC,IAAI,EAAE,GAAG,IAAI,OAAO,CAAC,UAAU,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC;gBAC5E,IAAI,CAAC,IAAY,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,GAAG,EAAE,CAAC;aACxC;SACJ;QAAC,OAAO,GAAG,EAAE;YACV,MAAM,CAAC,IAAI,CAAC,8BAA8B,GAAG,GAAG,CAAC,CAAC;SACrD;IACL,CAAC;IAxpBD,+BAA+B;IACR,0BAAY,GAAG,CAAC,CAAC;IACxC,+BAA+B;IACR,2BAAa,GAAG,CAAC,CAAC;IACzC,+BAA+B;IACR,2BAAa,GAAG,CAAC,CAAC;IAEzC,+BAA+B;IACR,wBAAU,GAAG,CAAC,CAAC;IACtC,+BAA+B;IACR,0BAAY,GAAG,CAAC,CAAC;IACxC,+BAA+B;IACR,yBAAW,GAAG,CAAC,CAAC;IA6oB3C,oBAAC;CAAA,AA3pBD,IA2pBC;SA3pBY,aAAa","sourcesContent":["import { Engine } from \"../../../Engines/engine\";\r\nimport { AbstractMesh } from \"../../../Meshes/abstractMesh\";\r\nimport { VertexBuffer } from \"../../../Meshes/buffer\";\r\nimport { Scene } from \"../../../scene\";\r\nimport { Material } from \"../../material\";\r\nimport { Texture } from \"../texture\";\r\nimport { DynamicTexture } from \"../dynamicTexture\";\r\nimport { Nullable } from \"../../../types\";\r\nimport { Vector2 } from \"../../../Maths/math.vector\";\r\nimport { Color3, Color4 } from \"../../../Maths/math.color\";\r\nimport { TexturePackerFrame } from \"./frame\";\r\nimport { Logger } from \"../../../Misc/logger\";\r\n\r\n/**\r\n* Defines the basic options interface of a TexturePacker\r\n*/\r\nexport interface ITexturePackerOptions{\r\n\r\n    /**\r\n    * Custom targets for the channels of a texture packer.  Default is all the channels of the Standard Material\r\n    */\r\n    map?: string[];\r\n\r\n    /**\r\n    * the UV input targets, as a single value for all meshes. Defaults to VertexBuffer.UVKind\r\n    */\r\n    uvsIn?: string;\r\n\r\n    /**\r\n    * the UV output targets, as a single value for all meshes.  Defaults to VertexBuffer.UVKind\r\n    */\r\n    uvsOut?: string;\r\n\r\n    /**\r\n    * number representing the layout style. Defaults to LAYOUT_STRIP\r\n    */\r\n    layout?: number;\r\n\r\n    /**\r\n    * number of columns if using custom column count layout(2).  This defaults to 4.\r\n    */\r\n    colnum?: number;\r\n\r\n    /**\r\n    * flag to update the input meshes to the new packed texture after compilation. Defaults to true.\r\n    */\r\n    updateInputMeshes?: boolean;\r\n\r\n    /**\r\n    * boolean flag to dispose all the source textures.  Defaults to true.\r\n    */\r\n    disposeSources?: boolean;\r\n\r\n    /**\r\n    * Fills the blank cells in a set to the customFillColor.  Defaults to true.\r\n    */\r\n    fillBlanks?: boolean;\r\n\r\n    /**\r\n    * string value representing the context fill style color.  Defaults to 'black'.\r\n    */\r\n    customFillColor?: string;\r\n\r\n    /**\r\n    * Width and Height Value of each Frame in the TexturePacker Sets\r\n    */\r\n    frameSize?: number;\r\n\r\n    /**\r\n    * Ratio of the value to add padding wise to each cell.  Defaults to 0.0115\r\n    */\r\n    paddingRatio?: number;\r\n\r\n    /**\r\n    * Number that declares the fill method for the padding gutter.\r\n    */\r\n    paddingMode?: number;\r\n\r\n    /**\r\n    * If in SUBUV_COLOR padding mode what color to use.\r\n    */\r\n    paddingColor?: Color3 | Color4;\r\n\r\n}\r\n\r\n/**\r\n* Defines the basic interface of a TexturePacker JSON File\r\n*/\r\nexport interface ITexturePackerJSON{\r\n\r\n    /**\r\n    * The frame ID\r\n    */\r\n    name: string;\r\n\r\n    /**\r\n    * The base64 channel data\r\n    */\r\n    sets: any;\r\n\r\n    /**\r\n    * The options of the Packer\r\n    */\r\n    options: ITexturePackerOptions;\r\n\r\n    /**\r\n    * The frame data of the Packer\r\n    */\r\n    frames: Array<number>;\r\n\r\n}\r\n\r\n/**\r\n* This is a support class that generates a series of packed texture sets.\r\n* @see https://doc.babylonjs.com/babylon101/materials\r\n*/\r\nexport class TexturePacker{\r\n\r\n    /** Packer Layout Constant 0 */\r\n    public static readonly LAYOUT_STRIP = 0;\r\n    /** Packer Layout Constant 1 */\r\n    public static readonly LAYOUT_POWER2 = 1;\r\n    /** Packer Layout Constant 2 */\r\n    public static readonly LAYOUT_COLNUM = 2;\r\n\r\n    /** Packer Layout Constant 0 */\r\n    public static readonly SUBUV_WRAP = 0;\r\n    /** Packer Layout Constant 1 */\r\n    public static readonly SUBUV_EXTEND = 1;\r\n    /** Packer Layout Constant 2 */\r\n    public static readonly SUBUV_COLOR = 2;\r\n\r\n    /** The Name of the Texture Package */\r\n    public name: string;\r\n\r\n    /** The scene scope of the TexturePacker */\r\n    public scene: Scene;\r\n\r\n    /** The Meshes to target */\r\n    public meshes: AbstractMesh[];\r\n\r\n    /** Arguments passed with the Constructor */\r\n    public options: ITexturePackerOptions;\r\n\r\n    /** The promise that is started upon initialization */\r\n    public promise: Nullable<Promise< TexturePacker | string >>;\r\n\r\n    /** The Container object for the channel sets that are generated */\r\n    public sets: object;\r\n\r\n    /** The Container array for the frames that are generated */\r\n    public frames: TexturePackerFrame[];\r\n\r\n    /** The expected number of textures the system is parsing. */\r\n    private _expecting: number;\r\n\r\n    /** The padding value from Math.ceil(frameSize * paddingRatio) */\r\n    private _paddingValue: number;\r\n\r\n    /**\r\n    * Initializes a texture package series from an array of meshes or a single mesh.\r\n    * @param name The name of the package\r\n    * @param meshes The target meshes to compose the package from\r\n    * @param options The arguments that texture packer should follow while building.\r\n    * @param scene The scene which the textures are scoped to.\r\n    * @returns TexturePacker\r\n    */\r\n    constructor(name: string, meshes: AbstractMesh[], options: ITexturePackerOptions, scene: Scene) {\r\n\r\n        this.name = name;\r\n        this.meshes = meshes;\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * Run through the options and set what ever defaults are needed that where not declared.\r\n         */\r\n        this.options = options;\r\n        this.options.map = this.options.map || [\r\n                'ambientTexture',\r\n                'bumpTexture',\r\n                'diffuseTexture',\r\n                'emissiveTexture',\r\n                'lightmapTexture',\r\n                'opacityTexture',\r\n                'reflectionTexture',\r\n                'refractionTexture',\r\n                'specularTexture'\r\n            ];\r\n\r\n        this.options.uvsIn = this.options.uvsIn || VertexBuffer.UVKind;\r\n        this.options.uvsOut = this.options.uvsOut || VertexBuffer.UVKind;\r\n        this.options.layout = this.options.layout || TexturePacker.LAYOUT_STRIP;\r\n\r\n        if (this.options.layout === TexturePacker.LAYOUT_COLNUM) {\r\n            this.options.colnum = this.options.colnum || 8;\r\n        }\r\n\r\n        this.options.updateInputMeshes = this.options.updateInputMeshes || true;\r\n        this.options.disposeSources = this.options.disposeSources || true;\r\n        this._expecting = 0;\r\n\r\n        this.options.fillBlanks = this.options.fillBlanks || true;\r\n\r\n        if (this.options.fillBlanks === true) {\r\n            this.options.customFillColor = this.options.customFillColor || 'black';\r\n        }\r\n\r\n        this.options.frameSize = this.options.frameSize || 256;\r\n        this.options.paddingRatio = this.options.paddingRatio || 0.0115;\r\n\r\n        this._paddingValue = Math.ceil(this.options.frameSize * this.options.paddingRatio);\r\n\r\n        //Make it an even padding Number.\r\n        if (this._paddingValue % 2 !== 0) {\r\n            this._paddingValue++;\r\n        }\r\n\r\n        this.options.paddingMode = this.options.paddingMode || TexturePacker.SUBUV_WRAP;\r\n\r\n        if (this.options.paddingMode === TexturePacker.SUBUV_COLOR) {\r\n            this.options.paddingColor = this.options.paddingColor || new Color4(0, 0, 0, 1.0);\r\n        }\r\n\r\n        this.sets = {};\r\n        this.frames = [];\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n    * Starts the package process\r\n    * @param resolve The promises resolution function\r\n    * @returns TexturePacker\r\n    */\r\n    private _createFrames(resolve: () => void) {\r\n\r\n        let dtSize = this._calculateSize();\r\n        let dtUnits = (new Vector2(1, 1)).divide(dtSize);\r\n        let doneCount = 0;\r\n        let expecting = this._expecting;\r\n        let meshLength = this.meshes.length;\r\n\r\n        let sKeys = Object.keys(this.sets);\r\n        for (let i = 0; i < sKeys.length; i++) {\r\n            let setName = sKeys[i];\r\n\r\n            let dt = new DynamicTexture(this.name + '.TexturePack.' + setName + 'Set',\r\n                    { width: dtSize.x, height: dtSize.y },\r\n                    this.scene,\r\n                    true, //Generate Mips\r\n                    Texture.TRILINEAR_SAMPLINGMODE,\r\n                    Engine.TEXTUREFORMAT_RGBA\r\n                );\r\n\r\n            let dtx = dt.getContext();\r\n            dtx.fillStyle = 'rgba(0,0,0,0)';\r\n            dtx.fillRect(0, 0, dtSize.x, dtSize.y) ;\r\n            dt.update(false);\r\n            (this.sets as any)[setName] = dt;\r\n        }\r\n\r\n        let baseSize = this.options.frameSize || 256;\r\n        let padding = this._paddingValue;\r\n        let tcs = baseSize + (2 * padding);\r\n\r\n        const done = () => {\r\n            this._calculateMeshUVFrames(baseSize, padding, dtSize, dtUnits, this.options.updateInputMeshes || false);\r\n        };\r\n\r\n        //Update the Textures\r\n        for (let i = 0; i < meshLength; i++) {\r\n            let m = this.meshes[i];\r\n            let mat = m.material;\r\n\r\n            //Check if the material has the texture\r\n            //Create a temporary canvas the same size as 1 frame\r\n            //Then apply the texture to the center and the 8 offsets\r\n            //Copy the Context and place in the correct frame on the DT\r\n\r\n            for (let j = 0; j < sKeys.length; j++) {\r\n                let tempTexture = new DynamicTexture('temp', tcs, this.scene, true);\r\n                let tcx = tempTexture.getContext();\r\n                let offset = this._getFrameOffset(i);\r\n\r\n                const updateDt = () => {\r\n                    doneCount++;\r\n                    tempTexture.update(false);\r\n                    let iDat = tcx.getImageData(0, 0, tcs, tcs);\r\n\r\n                    //Update Set\r\n                    let dt = (this.sets as any)[setName];\r\n                    let dtx = dt.getContext();\r\n                    dtx.putImageData(iDat, dtSize.x * offset.x, dtSize.y * offset.y);\r\n                    tempTexture.dispose();\r\n                    dt.update(false);\r\n                    if (doneCount == expecting) {\r\n                        done();\r\n                        resolve();\r\n                        return;\r\n                    }\r\n                };\r\n\r\n                let setName = sKeys[j] || '_blank';\r\n                if (!mat || (mat as any)[setName] === null) {\r\n                    tcx.fillStyle = 'rgba(0,0,0,0)';\r\n\r\n                    if (this.options.fillBlanks) {\r\n                        tcx.fillStyle = (this.options.customFillColor as string);\r\n                    }\r\n\r\n                    tcx.fillRect(0, 0, tcs, tcs);\r\n\r\n                    updateDt();\r\n\r\n                } else {\r\n\r\n                    let setTexture = (mat as any)[setName];\r\n                    let img = new Image();\r\n\r\n                    if (setTexture instanceof DynamicTexture) {\r\n                        img.src = setTexture.getContext().canvas.toDataURL(\"image/png\");\r\n                    } else {\r\n                        img.src = setTexture!.url;\r\n                    }\r\n\r\n                    img.onload = () => {\r\n                        tcx.fillStyle = 'rgba(0,0,0,0)';\r\n                        tcx.fillRect(0, 0, tcs, tcs);\r\n                        tempTexture.update(false);\r\n\r\n                        tcx.setTransform(1, 0, 0, -1, 0, 0);\r\n                        let cellOffsets = [ 0, 0, 1, 0, 1, 1, 0, 1, -1, 1, -1, 0, -1 - 1, 0, -1, 1, -1];\r\n\r\n                        switch (this.options.paddingMode){\r\n                            //Wrap Mode\r\n                            case 0:\r\n                                for (let i = 0; i < 9; i++) {\r\n                                    tcx.drawImage(\r\n                                        img,\r\n                                        0,\r\n                                        0,\r\n                                        img.width,\r\n                                        img.height,\r\n                                        (padding) + (baseSize * cellOffsets[i]),\r\n                                        ((padding) + (baseSize * cellOffsets[i + 1])) - tcs,\r\n                                        baseSize,\r\n                                        baseSize\r\n                                    );\r\n                                }\r\n                            break;\r\n                            //Extend Mode\r\n                            case 1:\r\n                                for (let i = 0; i < padding; i++) {\r\n                                    tcx.drawImage(\r\n                                        img,\r\n                                        0,\r\n                                        0,\r\n                                        img.width,\r\n                                        img.height,\r\n                                        i + (baseSize * cellOffsets[0]),\r\n                                        padding - tcs,\r\n                                        baseSize,\r\n                                        baseSize\r\n                                    );\r\n\r\n                                    tcx.drawImage(\r\n                                        img,\r\n                                        0,\r\n                                        0,\r\n                                        img.width,\r\n                                        img.height,\r\n                                        (padding * 2) - i,\r\n                                        padding - tcs,\r\n                                        baseSize,\r\n                                        baseSize\r\n                                    );\r\n\r\n                                    tcx.drawImage(\r\n                                        img,\r\n                                        0,\r\n                                        0,\r\n                                        img.width,\r\n                                        img.height,\r\n                                        padding,\r\n                                        i - tcs,\r\n                                        baseSize,\r\n                                        baseSize\r\n                                    );\r\n\r\n                                    tcx.drawImage(\r\n                                        img,\r\n                                        0,\r\n                                        0,\r\n                                        img.width,\r\n                                        img.height,\r\n                                        padding,\r\n                                        (padding * 2) - i - tcs,\r\n                                        baseSize,\r\n                                        baseSize\r\n                                    );\r\n                                }\r\n\r\n                                tcx.drawImage(\r\n                                    img,\r\n                                    0,\r\n                                    0,\r\n                                    img.width,\r\n                                    img.height,\r\n                                    (padding) + (baseSize * cellOffsets[0]),\r\n                                    ((padding) + (baseSize * cellOffsets[1])) - tcs,\r\n                                    baseSize,\r\n                                    baseSize\r\n                                );\r\n\r\n                            break;\r\n                            //Color Mode\r\n                            case 2:\r\n\r\n                               tcx.fillStyle = (this.options.paddingColor || Color3.Black()).toHexString();\r\n                               tcx.fillRect(0, 0, tcs, -tcs);\r\n                               tcx.clearRect(padding, padding, baseSize, baseSize);\r\n                               tcx.drawImage(\r\n                                    img,\r\n                                    0,\r\n                                    0,\r\n                                    img.width,\r\n                                    img.height,\r\n                                    (padding) + (baseSize * cellOffsets[0]),\r\n                                    ((padding) + (baseSize * cellOffsets[1])) - tcs,\r\n                                    baseSize,\r\n                                    baseSize\r\n                                );\r\n\r\n                            break;\r\n                        }\r\n\r\n                        tcx.setTransform(1, 0, 0, 1, 0, 0);\r\n\r\n                        updateDt();\r\n                    };\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * Calculates the Size of the Channel Sets\r\n    * @returns Vector2\r\n    */\r\n    private _calculateSize(): Vector2 {\r\n\r\n        let meshLength: number = this.meshes.length || 0;\r\n        let baseSize: number =  this.options.frameSize || 0;\r\n        let padding: number = this._paddingValue || 0;\r\n\r\n        switch (this.options.layout){\r\n            case 0 :\r\n                //STRIP_LAYOUT\r\n                return new Vector2(\r\n                    (baseSize * meshLength) + (2 * padding * meshLength),\r\n                    (baseSize) + (2 * padding)\r\n                );\r\n            break;\r\n            case 1 :\r\n                //POWER2\r\n                let sqrtCount = Math.max(2, Math.ceil(Math.sqrt(meshLength)));\r\n                let size = (baseSize * sqrtCount) + (2 * padding * sqrtCount);\r\n                return new Vector2(size, size);\r\n            break;\r\n            case 2 :\r\n                //COLNUM\r\n                let cols = this.options.colnum || 1;\r\n                let rowCnt = Math.max(1, Math.ceil(meshLength / cols));\r\n                return new Vector2(\r\n                    (baseSize * cols) + (2 * padding * cols),\r\n                    (baseSize * rowCnt) + (2 * padding * rowCnt)\r\n                );\r\n            break;\r\n        }\r\n\r\n        return Vector2.Zero();\r\n    }\r\n\r\n    /**\r\n    * Calculates the UV data for the frames.\r\n    * @param baseSize the base frameSize\r\n    * @param padding the base frame padding\r\n    * @param dtSize size of the Dynamic Texture for that channel\r\n    * @param dtUnits is 1/dtSize\r\n    * @param update flag to update the input meshes\r\n    */\r\n    private _calculateMeshUVFrames(baseSize: number, padding: number, dtSize: Vector2, dtUnits: Vector2, update: boolean) {\r\n        let meshLength = this.meshes.length;\r\n\r\n        for (let i = 0; i < meshLength; i++) {\r\n            let m = this.meshes[i];\r\n\r\n            let scale = new Vector2(\r\n                baseSize / dtSize.x,\r\n                baseSize / dtSize.y,\r\n            );\r\n\r\n            let pOffset: Vector2 = dtUnits.clone().scale(padding);\r\n            let frameOffset: Vector2 = this._getFrameOffset(i);\r\n            let offset: Vector2 = frameOffset.add(pOffset);\r\n\r\n            let frame: TexturePackerFrame = new TexturePackerFrame(i, scale, offset);\r\n\r\n            this.frames.push(\r\n                frame\r\n            );\r\n\r\n            //Update Output UVs\r\n            if (update) {\r\n                this._updateMeshUV(m, i);\r\n                this._updateTextureReferences(m);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * Calculates the frames Offset.\r\n    * @param index of the frame\r\n    * @returns Vector2\r\n    */\r\n    private _getFrameOffset(index: number): Vector2 {\r\n\r\n        let meshLength = this.meshes.length;\r\n        let uvStep, yStep, xStep;\r\n\r\n        switch (this.options.layout){\r\n            case 0 :\r\n                //STRIP_LAYOUT\r\n                uvStep = 1 / meshLength;\r\n                return new Vector2(\r\n                    index * uvStep,\r\n                    0\r\n                );\r\n            break;\r\n            case 1 :\r\n                //POWER2\r\n                let sqrtCount = Math.max(2, Math.ceil(Math.sqrt(meshLength)));\r\n                yStep = Math.floor(index / sqrtCount);\r\n                xStep = index - (yStep * sqrtCount);\r\n                uvStep = 1 / sqrtCount;\r\n                return new Vector2(xStep * uvStep , yStep * uvStep);\r\n            break;\r\n            case 2 :\r\n                //COLNUM\r\n                let cols = this.options.colnum || 1;\r\n                let rowCnt = Math.max(1, Math.ceil(meshLength / cols));\r\n                xStep = Math.floor(index / rowCnt);\r\n                yStep = index - (xStep * rowCnt);\r\n                uvStep = new Vector2(1 / cols, 1 / rowCnt);\r\n                return new Vector2(xStep * uvStep.x , yStep * uvStep.y);\r\n            break;\r\n        }\r\n\r\n        return Vector2.Zero();\r\n    }\r\n\r\n    /**\r\n    * Updates a Mesh to the frame data\r\n    * @param mesh that is the target\r\n    * @param frameID or the frame index\r\n    */\r\n    private _updateMeshUV(mesh: AbstractMesh, frameID: number): void {\r\n        let frame: TexturePackerFrame = (this.frames as any)[frameID];\r\n        let uvIn = mesh.getVerticesData(this.options.uvsIn || VertexBuffer.UVKind);\r\n        let uvOut = [];\r\n        let toCount = 0;\r\n\r\n        if (uvIn!.length) {\r\n            toCount = uvIn!.length || 0;\r\n        }\r\n\r\n        for (let i = 0; i < toCount; i += 2) {\r\n            uvOut.push(\r\n                ((uvIn as any)[i] * frame.scale.x) + frame.offset.x,\r\n                ((uvIn as any)[i + 1] * frame.scale.y) + frame.offset.y\r\n            );\r\n        }\r\n\r\n        mesh.setVerticesData(this.options.uvsOut || VertexBuffer.UVKind, uvOut);\r\n    }\r\n\r\n    /**\r\n    * Updates a Meshes materials to use the texture packer channels\r\n    * @param m is the mesh to target\r\n    * @param force all channels on the packer to be set.\r\n    */\r\n    private _updateTextureReferences(m: AbstractMesh, force: boolean = false): void {\r\n        let mat = m.material;\r\n        let sKeys = Object.keys(this.sets);\r\n\r\n        let _dispose = (_t: any) => {\r\n             if ((_t.dispose)) {\r\n                _t.dispose();\r\n             }\r\n        };\r\n\r\n        for (let i = 0; i < sKeys.length; i++) {\r\n            let setName = sKeys[i];\r\n            if (!force) {\r\n                if (!mat) {\r\n                    return;\r\n                }\r\n                if ((mat as any)[setName] !== null) {\r\n                    _dispose((mat as any)[setName]);\r\n                    (mat as any)[setName] = (this.sets as any)[setName];\r\n                }\r\n            } else {\r\n                if ((mat as any)[setName] !== null) {\r\n                    _dispose((mat as any)[setName]);\r\n                }\r\n                (mat as any)[setName] = (this.sets as any)[setName];\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * Public method to set a Mesh to a frame\r\n    * @param m that is the target\r\n    * @param frameID or the frame index\r\n    * @param updateMaterial trigger for if the Meshes attached Material be updated?\r\n    */\r\n    public setMeshToFrame(m: AbstractMesh, frameID: number, updateMaterial: boolean = false): void {\r\n        this._updateMeshUV(m, frameID);\r\n        if (updateMaterial) {\r\n            this._updateTextureReferences(m, true);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * Starts the async promise to compile the texture packer.\r\n    * @returns Promise<void>\r\n    */\r\n    public processAsync(): Promise<void> {\r\n            return new Promise ((resolve, reject) => {\r\n                try {\r\n                    if (this.meshes.length === 0) {\r\n                        //Must be a JSON load!\r\n                        resolve();\r\n                        return;\r\n                    }\r\n                    let done = 0;\r\n                    const doneCheck = (mat: Material) => {\r\n                        done++;\r\n                        //Check Status of all Textures on all meshes, till they are ready.\r\n                        if (this.options.map) {\r\n                            for (let j = 0; j < this.options.map.length; j++) {\r\n                                let index: string = this.options.map[j];\r\n                                let t: (Texture | DynamicTexture) = (mat as any)[index];\r\n\r\n                                if (t !== null) {\r\n                                    if (!(this.sets as any)[this.options.map[j]]) {\r\n                                        (this.sets as any)[this.options.map[j]] = true;\r\n                                    }\r\n\r\n                                    this._expecting++;\r\n                                }\r\n                            }\r\n\r\n                            if (done === this.meshes.length) {\r\n                                this._createFrames(resolve);\r\n                            }\r\n                        }\r\n                    };\r\n\r\n                    for (let i = 0; i < this.meshes.length; i++) {\r\n\r\n                        let mesh = this.meshes[i];\r\n                        let material: Nullable< Material > = mesh.material;\r\n\r\n                        if (!material) {\r\n                            done++;\r\n                            if (done === this.meshes.length) {\r\n                                return this._createFrames(resolve);\r\n                            }\r\n                            continue;\r\n                        }\r\n\r\n                        material.forceCompilationAsync(mesh).then(() => {\r\n                            doneCheck((material as Material));\r\n                        });\r\n                    }\r\n                } catch (e) {\r\n                    return reject(e);\r\n                }\r\n            });\r\n    }\r\n\r\n    /**\r\n    * Disposes all textures associated with this packer\r\n    */\r\n    public dispose(): void {\r\n        let sKeys = Object.keys(this.sets);\r\n        for (let i = 0; i < sKeys.length; i++) {\r\n            let channel = sKeys[i];\r\n            (this.sets as any)[channel].dispose();\r\n        }\r\n    }\r\n\r\n    /**\r\n    * Starts the download process for all the channels converting them to base64 data and embedding it all in a JSON file.\r\n    * @param imageType is the image type to use.\r\n    * @param quality of the image if downloading as jpeg, Ranges from >0 to 1.\r\n    */\r\n    public download(imageType: string = 'png', quality: number = 1): void {\r\n        setTimeout(() => {\r\n            let pack = {\r\n                name : this.name,\r\n                sets : {},\r\n                options: {},\r\n                frames : []\r\n            };\r\n\r\n            let sKeys = Object.keys(this.sets);\r\n            let oKeys = Object.keys(this.options);\r\n            try {\r\n                for (let i = 0; i < sKeys.length; i++) {\r\n                    let channel: string = sKeys[i];\r\n                    let dt =  (this.sets as any)[channel];\r\n                    (pack.sets as any)[channel] = dt.getContext().canvas.toDataURL('image/' + imageType, quality);\r\n                }\r\n                for (let i = 0; i < oKeys.length; i++) {\r\n                    let opt: string = oKeys[i];\r\n                    (pack.options as any)[opt] = (this.options as any)[opt];\r\n                }\r\n                for (let i = 0; i < this.frames.length; i++) {\r\n                    let _f = this.frames[i];\r\n                    (pack.frames as Array<number>).push(_f.scale.x, _f.scale.y, _f.offset.x, _f.offset.y);\r\n                }\r\n\r\n            } catch (err) {\r\n                Logger.Warn(\"Unable to download: \" + err);\r\n                return;\r\n            }\r\n\r\n            let data = \"data:text/json;charset=utf-8,\" + encodeURIComponent(JSON.stringify(pack, null, 4));\r\n            let _a = document.createElement('a');\r\n            _a.setAttribute(\"href\", data);\r\n            _a.setAttribute(\"download\", this.name + \"_texurePackage.json\");\r\n            document.body.appendChild(_a);\r\n            _a.click();\r\n            _a.remove();\r\n\r\n        }, 0);\r\n    }\r\n\r\n    /**\r\n    * Public method to load a texturePacker JSON file.\r\n    * @param data of the JSON file in string format.\r\n    */\r\n    public updateFromJSON(data: string): void {\r\n        try {\r\n            let parsedData: ITexturePackerJSON = JSON.parse(data);\r\n            this.name = parsedData.name;\r\n            let _options = Object.keys(parsedData.options);\r\n\r\n            for (let i = 0; i < _options.length; i++) {\r\n                (this.options as any)[_options[i]] = (parsedData.options as any)[_options[i]];\r\n            }\r\n\r\n            for (let i = 0; i < parsedData.frames.length; i += 4) {\r\n                let frame: TexturePackerFrame = new TexturePackerFrame(\r\n                    i / 4,\r\n                    new Vector2(parsedData.frames[i], parsedData.frames[i + 1]),\r\n                    new Vector2(parsedData.frames[i + 2], parsedData.frames[i + 3])\r\n                );\r\n            this.frames.push(frame);\r\n            }\r\n\r\n            let channels = Object.keys(parsedData.sets);\r\n\r\n            for (let i = 0; i < channels.length; i++) {\r\n                let _t = new Texture(parsedData.sets[channels[i]], this.scene, false, false);\r\n                (this.sets as any)[channels[i]] = _t;\r\n            }\r\n        } catch (err) {\r\n            Logger.Warn(\"Unable to update from JSON: \" + err);\r\n        }\r\n    }\r\n}\r\n"]}