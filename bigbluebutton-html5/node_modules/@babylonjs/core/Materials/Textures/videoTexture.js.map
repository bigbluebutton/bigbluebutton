{"version":3,"file":"videoTexture.js","sourceRoot":"","sources":["../../../../sourceES6/core/Materials/Textures/videoTexture.ts"],"names":[],"mappings":"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","sourcesContent":["import { Observable } from \"../../Misc/observable\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { Nullable } from \"../../types\";\r\nimport { Scene } from \"../../scene\";\r\nimport { Engine } from \"../../Engines/engine\";\r\nimport { Texture } from \"../../Materials/Textures/texture\";\r\n\r\nimport \"../../Engines/Extensions/engine.videoTexture\";\r\n\r\n/**\r\n * Settings for finer control over video usage\r\n */\r\nexport interface VideoTextureSettings {\r\n    /**\r\n     * Applies `autoplay` to video, if specified\r\n     */\r\n    autoPlay?: boolean;\r\n\r\n    /**\r\n     * Applies `loop` to video, if specified\r\n     */\r\n    loop?: boolean;\r\n\r\n    /**\r\n     * Automatically updates internal texture from video at every frame in the render loop\r\n     */\r\n    autoUpdateTexture: boolean;\r\n\r\n    /**\r\n     * Image src displayed during the video loading or until the user interacts with the video.\r\n     */\r\n    poster?: string;\r\n}\r\n\r\n/**\r\n * If you want to display a video in your scene, this is the special texture for that.\r\n * This special texture works similar to other textures, with the exception of a few parameters.\r\n * @see https://doc.babylonjs.com/how_to/video_texture\r\n */\r\nexport class VideoTexture extends Texture {\r\n    /**\r\n     * Tells whether textures will be updated automatically or user is required to call `updateTexture` manually\r\n     */\r\n    public readonly autoUpdateTexture: boolean;\r\n\r\n    /**\r\n     * The video instance used by the texture internally\r\n     */\r\n    public readonly video: HTMLVideoElement;\r\n\r\n    private _onUserActionRequestedObservable: Nullable<Observable<Texture>> = null;\r\n\r\n    /**\r\n     * Event triggerd when a dom action is required by the user to play the video.\r\n     * This happens due to recent changes in browser policies preventing video to auto start.\r\n     */\r\n    public get onUserActionRequestedObservable(): Observable<Texture> {\r\n        if (!this._onUserActionRequestedObservable) {\r\n            this._onUserActionRequestedObservable = new Observable<Texture>();\r\n        }\r\n        return this._onUserActionRequestedObservable;\r\n    }\r\n\r\n    private _generateMipMaps: boolean;\r\n    private _engine: Engine;\r\n    private _stillImageCaptured = false;\r\n    private _displayingPosterTexture = false;\r\n    private _settings: VideoTextureSettings;\r\n    private _createInternalTextureOnEvent: string;\r\n    private _frameId = -1;\r\n    private _currentSrc: Nullable<string | string[] | HTMLVideoElement> = null;\r\n\r\n    /**\r\n     * Creates a video texture.\r\n     * If you want to display a video in your scene, this is the special texture for that.\r\n     * This special texture works similar to other textures, with the exception of a few parameters.\r\n     * @see https://doc.babylonjs.com/how_to/video_texture\r\n     * @param name optional name, will detect from video source, if not defined\r\n     * @param src can be used to provide an url, array of urls or an already setup HTML video element.\r\n     * @param scene is obviously the current scene.\r\n     * @param generateMipMaps can be used to turn on mipmaps (Can be expensive for videoTextures because they are often updated).\r\n     * @param invertY is false by default but can be used to invert video on Y axis\r\n     * @param samplingMode controls the sampling method and is set to TRILINEAR_SAMPLINGMODE by default\r\n     * @param settings allows finer control over video usage\r\n     */\r\n    constructor(\r\n        name: Nullable<string>,\r\n        src: string | string[] | HTMLVideoElement,\r\n        scene: Nullable<Scene>,\r\n        generateMipMaps = false,\r\n        invertY = false,\r\n        samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE,\r\n        settings: VideoTextureSettings = {\r\n            autoPlay: true,\r\n            loop: true,\r\n            autoUpdateTexture: true,\r\n        }\r\n    ) {\r\n        super(null, scene, !generateMipMaps, invertY);\r\n\r\n        this._engine = this.getScene()!.getEngine();\r\n        this._generateMipMaps = generateMipMaps;\r\n        this._initialSamplingMode = samplingMode;\r\n        this.autoUpdateTexture = settings.autoUpdateTexture;\r\n\r\n        this._currentSrc = src;\r\n        this.name = name || this._getName(src);\r\n        this.video = this._getVideo(src);\r\n        this._settings = settings;\r\n\r\n        if (settings.poster) {\r\n            this.video.poster = settings.poster;\r\n        }\r\n\r\n        if (settings.autoPlay !== undefined) {\r\n            this.video.autoplay = settings.autoPlay;\r\n        }\r\n        if (settings.loop !== undefined) {\r\n            this.video.loop = settings.loop;\r\n        }\r\n\r\n        this.video.setAttribute(\"playsinline\", \"\");\r\n\r\n        this.video.addEventListener(\"paused\", this._updateInternalTexture);\r\n        this.video.addEventListener(\"seeked\", this._updateInternalTexture);\r\n        this.video.addEventListener(\"emptied\", this.reset);\r\n        this._createInternalTextureOnEvent = (settings.poster && !settings.autoPlay) ? \"play\" : \"canplay\";\r\n        this.video.addEventListener(this._createInternalTextureOnEvent, this._createInternalTexture);\r\n\r\n        const videoHasEnoughData = (this.video.readyState >= this.video.HAVE_CURRENT_DATA);\r\n        if (settings.poster &&\r\n            (!settings.autoPlay || !videoHasEnoughData)) {\r\n            this._texture = this._engine.createTexture(settings.poster!, false, !this.invertY, scene);\r\n            this._displayingPosterTexture = true;\r\n        }\r\n        else if (videoHasEnoughData) {\r\n            this._createInternalTexture();\r\n        }\r\n    }\r\n\r\n    private _getName(src: string | string[] | HTMLVideoElement): string {\r\n        if (src instanceof HTMLVideoElement) {\r\n            return src.currentSrc;\r\n        }\r\n\r\n        if (typeof src === \"object\") {\r\n            return src.toString();\r\n        }\r\n\r\n        return src;\r\n    }\r\n\r\n    private _getVideo(src: string | string[] | HTMLVideoElement): HTMLVideoElement {\r\n        if (src instanceof HTMLVideoElement) {\r\n            Tools.SetCorsBehavior(src.currentSrc, src);\r\n            return src;\r\n        }\r\n        const video: HTMLVideoElement = document.createElement(\"video\");\r\n        if (typeof src === \"string\") {\r\n            Tools.SetCorsBehavior(src, video);\r\n            video.src = src;\r\n        } else {\r\n            Tools.SetCorsBehavior(src[0], video);\r\n            src.forEach((url) => {\r\n                const source = document.createElement(\"source\");\r\n                source.src = url;\r\n                video.appendChild(source);\r\n            });\r\n        }\r\n        return video;\r\n    }\r\n\r\n    private _createInternalTexture = (): void => {\r\n        if (this._texture != null) {\r\n            if (this._displayingPosterTexture) {\r\n                this._texture.dispose();\r\n                this._displayingPosterTexture = false;\r\n            }\r\n            else {\r\n                return;\r\n            }\r\n        }\r\n\r\n        if (!this._engine.needPOTTextures ||\r\n            (Tools.IsExponentOfTwo(this.video.videoWidth) && Tools.IsExponentOfTwo(this.video.videoHeight))) {\r\n            this.wrapU = Texture.WRAP_ADDRESSMODE;\r\n            this.wrapV = Texture.WRAP_ADDRESSMODE;\r\n        } else {\r\n            this.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n            this.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n            this._generateMipMaps = false;\r\n        }\r\n\r\n        this._texture = this._engine.createDynamicTexture(\r\n            this.video.videoWidth,\r\n            this.video.videoHeight,\r\n            this._generateMipMaps,\r\n            this.samplingMode\r\n        );\r\n\r\n        if (!this.video.autoplay && !this._settings.poster) {\r\n            let oldHandler = this.video.onplaying;\r\n            let error = false;\r\n            let oldMuted = this.video.muted;\r\n            this.video.muted = true;\r\n            this.video.onplaying = () => {\r\n                this.video.muted = oldMuted;\r\n                this.video.onplaying = oldHandler;\r\n                this._texture!.isReady = true;\r\n                this._updateInternalTexture();\r\n                if (!error) {\r\n                    this.video.pause();\r\n                }\r\n                if (this.onLoadObservable.hasObservers()) {\r\n                    this.onLoadObservable.notifyObservers(this);\r\n                }\r\n            };\r\n            var playing = this.video.play();\r\n            if (playing) {\r\n                playing.then(() => {\r\n                    // Everything is good.\r\n                })\r\n                    .catch(() => {\r\n                        error = true;\r\n                        // On Chrome for instance, new policies might prevent playing without user interaction.\r\n                        if (this._onUserActionRequestedObservable && this._onUserActionRequestedObservable.hasObservers()) {\r\n                            this._onUserActionRequestedObservable.notifyObservers(this);\r\n                        }\r\n                    });\r\n            }\r\n            else {\r\n                this.video.onplaying = oldHandler;\r\n                this._texture.isReady = true;\r\n                this._updateInternalTexture();\r\n                if (this.onLoadObservable.hasObservers()) {\r\n                    this.onLoadObservable.notifyObservers(this);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            this._texture.isReady = true;\r\n            this._updateInternalTexture();\r\n            if (this.onLoadObservable.hasObservers()) {\r\n                this.onLoadObservable.notifyObservers(this);\r\n            }\r\n        }\r\n    }\r\n\r\n    private reset = (): void => {\r\n        if (this._texture == null) {\r\n            return;\r\n        }\r\n\r\n        if (!this._displayingPosterTexture) {\r\n            this._texture.dispose();\r\n            this._texture = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @hidden Internal method to initiate `update`.\r\n     */\r\n    public _rebuild(): void {\r\n        this.update();\r\n    }\r\n\r\n    /**\r\n     * Update Texture in the `auto` mode. Does not do anything if `settings.autoUpdateTexture` is false.\r\n     */\r\n    public update(): void {\r\n        if (!this.autoUpdateTexture) {\r\n            // Expecting user to call `updateTexture` manually\r\n            return;\r\n        }\r\n\r\n        this.updateTexture(true);\r\n    }\r\n\r\n    /**\r\n     * Update Texture in `manual` mode. Does not do anything if not visible or paused.\r\n     * @param isVisible Visibility state, detected by user using `scene.getActiveMeshes()` or othervise.\r\n     */\r\n    public updateTexture(isVisible: boolean): void {\r\n        if (!isVisible) {\r\n            return;\r\n        }\r\n        if (this.video.paused && this._stillImageCaptured) {\r\n            return;\r\n        }\r\n        this._stillImageCaptured = true;\r\n        this._updateInternalTexture();\r\n    }\r\n\r\n    protected _updateInternalTexture = (): void => {\r\n        if (this._texture == null || !this._texture.isReady) {\r\n            return;\r\n        }\r\n        if (this.video.readyState < this.video.HAVE_CURRENT_DATA) {\r\n            return;\r\n        }\r\n        if (this._displayingPosterTexture) {\r\n            return;\r\n        }\r\n\r\n        let frameId = this.getScene()!.getFrameId();\r\n        if (this._frameId === frameId) {\r\n            return;\r\n        }\r\n\r\n        this._frameId = frameId;\r\n\r\n        this._engine.updateVideoTexture(this._texture, this.video, this._invertY);\r\n    }\r\n\r\n    /**\r\n     * Change video content. Changing video instance or setting multiple urls (as in constructor) is not supported.\r\n     * @param url New url.\r\n     */\r\n    public updateURL(url: string): void {\r\n        this.video.src = url;\r\n        this._currentSrc = url;\r\n    }\r\n\r\n    /**\r\n     * Clones the texture.\r\n     * @returns the cloned texture\r\n     */\r\n    public clone(): VideoTexture {\r\n        return new VideoTexture(this.name,\r\n            this._currentSrc!,\r\n            this.getScene(),\r\n            this._generateMipMaps,\r\n            this.invertY,\r\n            this.samplingMode,\r\n            this._settings);\r\n    }\r\n\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    public dispose(): void {\r\n        super.dispose();\r\n\r\n        this._currentSrc = null;\r\n\r\n        if (this._onUserActionRequestedObservable) {\r\n            this._onUserActionRequestedObservable.clear();\r\n            this._onUserActionRequestedObservable = null;\r\n        }\r\n\r\n        this.video.removeEventListener(this._createInternalTextureOnEvent, this._createInternalTexture);\r\n        this.video.removeEventListener(\"paused\", this._updateInternalTexture);\r\n        this.video.removeEventListener(\"seeked\", this._updateInternalTexture);\r\n        this.video.removeEventListener(\"emptied\", this.reset);\r\n        this.video.pause();\r\n    }\r\n\r\n    /**\r\n     * Creates a video texture straight from a stream.\r\n     * @param scene Define the scene the texture should be created in\r\n     * @param stream Define the stream the texture should be created from\r\n     * @returns The created video texture as a promise\r\n     */\r\n    public static CreateFromStreamAsync(scene: Scene, stream: MediaStream): Promise<VideoTexture> {\r\n        var video = document.createElement(\"video\");\r\n        video.setAttribute('autoplay', '');\r\n        video.setAttribute('muted', 'true');\r\n        video.setAttribute('playsinline', '');\r\n        video.muted = true;\r\n\r\n        if (video.mozSrcObject !== undefined) {\r\n            // hack for Firefox < 19\r\n            video.mozSrcObject = stream;\r\n        } else {\r\n            if (typeof video.srcObject == \"object\") {\r\n                video.srcObject = stream;\r\n            } else {\r\n                window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL;\r\n                video.src = (window.URL && window.URL.createObjectURL(stream));\r\n            }\r\n        }\r\n\r\n        return new Promise<VideoTexture>((resolve) => {\r\n            let onPlaying = () => {\r\n                resolve(new VideoTexture(\"video\", video, scene, true, true));\r\n                video.removeEventListener(\"playing\", onPlaying);\r\n            };\r\n\r\n            video.addEventListener(\"playing\", onPlaying);\r\n            video.play();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a video texture straight from your WebCam video feed.\r\n     * @param scene Define the scene the texture should be created in\r\n     * @param constraints Define the constraints to use to create the web cam feed from WebRTC\r\n     * @param audioConstaints Define the audio constraints to use to create the web cam feed from WebRTC\r\n     * @returns The created video texture as a promise\r\n     */\r\n    public static CreateFromWebCamAsync(\r\n        scene: Scene,\r\n        constraints: {\r\n            minWidth: number;\r\n            maxWidth: number;\r\n            minHeight: number;\r\n            maxHeight: number;\r\n            deviceId: string;\r\n        } & MediaTrackConstraints,\r\n        audioConstaints: boolean | MediaTrackConstraints = false\r\n    ): Promise<VideoTexture> {\r\n        var constraintsDeviceId;\r\n        if (constraints && constraints.deviceId) {\r\n            constraintsDeviceId = {\r\n                exact: constraints.deviceId,\r\n            };\r\n        }\r\n\r\n        if (navigator.mediaDevices) {\r\n            return navigator.mediaDevices.getUserMedia({\r\n                    video: constraints,\r\n                    audio: audioConstaints\r\n                })\r\n                .then((stream) => {\r\n                    return this.CreateFromStreamAsync(scene, stream);\r\n                });\r\n        }\r\n        else {\r\n            navigator.getUserMedia =\r\n                navigator.getUserMedia ||\r\n                navigator.webkitGetUserMedia ||\r\n                navigator.mozGetUserMedia ||\r\n                navigator.msGetUserMedia;\r\n\r\n            if (navigator.getUserMedia) {\r\n                navigator.getUserMedia(\r\n                    {\r\n                        video: {\r\n                            deviceId: constraintsDeviceId,\r\n                            width: {\r\n                                min: (constraints && constraints.minWidth) || 256,\r\n                                max: (constraints && constraints.maxWidth) || 640,\r\n                            },\r\n                            height: {\r\n                                min: (constraints && constraints.minHeight) || 256,\r\n                                max: (constraints && constraints.maxHeight) || 480,\r\n                            },\r\n                        },\r\n                        audio: audioConstaints\r\n                    },\r\n                    (stream: any) => {\r\n                        return this.CreateFromStreamAsync(scene, stream);\r\n                    },\r\n                    function(e: MediaStreamError) {\r\n                        Logger.Error(e.name);\r\n                    }\r\n                );\r\n            }\r\n        }\r\n\r\n        return Promise.reject(\"No support for userMedia on this device\");\r\n    }\r\n\r\n    /**\r\n     * Creates a video texture straight from your WebCam video feed.\r\n     * @param scene Define the scene the texture should be created in\r\n     * @param onReady Define a callback to triggered once the texture will be ready\r\n     * @param constraints Define the constraints to use to create the web cam feed from WebRTC\r\n     * @param audioConstaints Define the audio constraints to use to create the web cam feed from WebRTC\r\n     */\r\n    public static CreateFromWebCam(\r\n        scene: Scene,\r\n        onReady: (videoTexture: VideoTexture) => void,\r\n        constraints: {\r\n            minWidth: number;\r\n            maxWidth: number;\r\n            minHeight: number;\r\n            maxHeight: number;\r\n            deviceId: string;\r\n        } & MediaTrackConstraints,\r\n        audioConstaints: boolean | MediaTrackConstraints = false\r\n    ): void {\r\n        this.CreateFromWebCamAsync(scene, constraints, audioConstaints)\r\n            .then(function(videoTexture) {\r\n                if (onReady) {\r\n                    onReady(videoTexture);\r\n                }\r\n            })\r\n            .catch(function(err) {\r\n                Logger.Error(err.name);\r\n            });\r\n    }\r\n}\r\n"]}