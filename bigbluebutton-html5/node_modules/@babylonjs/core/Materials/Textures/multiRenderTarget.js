import { __extends } from "tslib";
import { Texture } from "../../Materials/Textures/texture";
import { RenderTargetTexture } from "../../Materials/Textures/renderTargetTexture";
import "../../Engines/Extensions/engine.multiRender";
/**
 * A multi render target, like a render target provides the ability to render to a texture.
 * Unlike the render target, it can render to several draw buffers in one draw.
 * This is specially interesting in deferred rendering or for any effects requiring more than
 * just one color from a single pass.
 */
var MultiRenderTarget = /** @class */ (function (_super) {
    __extends(MultiRenderTarget, _super);
    /**
     * Instantiate a new multi render target texture.
     * A multi render target, like a render target provides the ability to render to a texture.
     * Unlike the render target, it can render to several draw buffers in one draw.
     * This is specially interesting in deferred rendering or for any effects requiring more than
     * just one color from a single pass.
     * @param name Define the name of the texture
     * @param size Define the size of the buffers to render to
     * @param count Define the number of target we are rendering into
     * @param scene Define the scene the texture belongs to
     * @param options Define the options used to create the multi render target
     */
    function MultiRenderTarget(name, size, count, scene, options) {
        var _this = this;
        var generateMipMaps = options && options.generateMipMaps ? options.generateMipMaps : false;
        var generateDepthTexture = options && options.generateDepthTexture ? options.generateDepthTexture : false;
        var doNotChangeAspectRatio = !options || options.doNotChangeAspectRatio === undefined ? true : options.doNotChangeAspectRatio;
        _this = _super.call(this, name, size, scene, generateMipMaps, doNotChangeAspectRatio) || this;
        _this._engine = scene.getEngine();
        if (!_this.isSupported) {
            _this.dispose();
            return;
        }
        var types = [];
        var samplingModes = [];
        for (var i = 0; i < count; i++) {
            if (options && options.types && options.types[i] !== undefined) {
                types.push(options.types[i]);
            }
            else {
                types.push(options && options.defaultType ? options.defaultType : 0);
            }
            if (options && options.samplingModes && options.samplingModes[i] !== undefined) {
                samplingModes.push(options.samplingModes[i]);
            }
            else {
                samplingModes.push(Texture.BILINEAR_SAMPLINGMODE);
            }
        }
        var generateDepthBuffer = !options || options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;
        var generateStencilBuffer = !options || options.generateStencilBuffer === undefined ? false : options.generateStencilBuffer;
        _this._size = size;
        _this._multiRenderTargetOptions = {
            samplingModes: samplingModes,
            generateMipMaps: generateMipMaps,
            generateDepthBuffer: generateDepthBuffer,
            generateStencilBuffer: generateStencilBuffer,
            generateDepthTexture: generateDepthTexture,
            types: types,
            textureCount: count
        };
        _this._createInternalTextures();
        _this._createTextures();
        return _this;
    }
    Object.defineProperty(MultiRenderTarget.prototype, "isSupported", {
        /**
         * Get if draw buffers are currently supported by the used hardware and browser.
         */
        get: function () {
            return this._engine.webGLVersion > 1 || this._engine.getCaps().drawBuffersExtension;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MultiRenderTarget.prototype, "textures", {
        /**
         * Get the list of textures generated by the multi render target.
         */
        get: function () {
            return this._textures;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MultiRenderTarget.prototype, "depthTexture", {
        /**
         * Get the depth texture generated by the multi render target if options.generateDepthTexture has been set
         */
        get: function () {
            return this._textures[this._textures.length - 1];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MultiRenderTarget.prototype, "wrapU", {
        /**
         * Set the wrapping mode on U of all the textures we are rendering to.
         * Can be any of the Texture. (CLAMP_ADDRESSMODE, MIRROR_ADDRESSMODE or WRAP_ADDRESSMODE)
         */
        set: function (wrap) {
            if (this._textures) {
                for (var i = 0; i < this._textures.length; i++) {
                    this._textures[i].wrapU = wrap;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MultiRenderTarget.prototype, "wrapV", {
        /**
         * Set the wrapping mode on V of all the textures we are rendering to.
         * Can be any of the Texture. (CLAMP_ADDRESSMODE, MIRROR_ADDRESSMODE or WRAP_ADDRESSMODE)
         */
        set: function (wrap) {
            if (this._textures) {
                for (var i = 0; i < this._textures.length; i++) {
                    this._textures[i].wrapV = wrap;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    /** @hidden */
    MultiRenderTarget.prototype._rebuild = function () {
        this.releaseInternalTextures();
        this._createInternalTextures();
        for (var i = 0; i < this._internalTextures.length; i++) {
            var texture = this._textures[i];
            texture._texture = this._internalTextures[i];
        }
        // Keeps references to frame buffer and stencil/depth buffer
        this._texture = this._internalTextures[0];
    };
    MultiRenderTarget.prototype._createInternalTextures = function () {
        this._internalTextures = this._engine.createMultipleRenderTarget(this._size, this._multiRenderTargetOptions);
    };
    MultiRenderTarget.prototype._createTextures = function () {
        this._textures = [];
        for (var i = 0; i < this._internalTextures.length; i++) {
            var texture = new Texture(null, this.getScene());
            texture._texture = this._internalTextures[i];
            this._textures.push(texture);
        }
        // Keeps references to frame buffer and stencil/depth buffer
        this._texture = this._internalTextures[0];
    };
    Object.defineProperty(MultiRenderTarget.prototype, "samples", {
        /**
         * Define the number of samples used if MSAA is enabled.
         */
        get: function () {
            return this._samples;
        },
        set: function (value) {
            if (this._samples === value) {
                return;
            }
            this._samples = this._engine.updateMultipleRenderTargetTextureSampleCount(this._internalTextures, value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Resize all the textures in the multi render target.
     * Be carrefull as it will recreate all the data in the new texture.
     * @param size Define the new size
     */
    MultiRenderTarget.prototype.resize = function (size) {
        this.releaseInternalTextures();
        this._size = size;
        this._createInternalTextures();
    };
    MultiRenderTarget.prototype.unbindFrameBuffer = function (engine, faceIndex) {
        var _this = this;
        engine.unBindMultiColorAttachmentFramebuffer(this._internalTextures, this.isCube, function () {
            _this.onAfterRenderObservable.notifyObservers(faceIndex);
        });
    };
    /**
     * Dispose the render targets and their associated resources
     */
    MultiRenderTarget.prototype.dispose = function () {
        this.releaseInternalTextures();
        _super.prototype.dispose.call(this);
    };
    /**
     * Release all the underlying texture used as draw buffers.
     */
    MultiRenderTarget.prototype.releaseInternalTextures = function () {
        if (!this._internalTextures) {
            return;
        }
        for (var i = this._internalTextures.length - 1; i >= 0; i--) {
            if (this._internalTextures[i] !== undefined) {
                this._internalTextures[i].dispose();
                this._internalTextures.splice(i, 1);
            }
        }
    };
    return MultiRenderTarget;
}(RenderTargetTexture));
export { MultiRenderTarget };
//# sourceMappingURL=multiRenderTarget.js.map