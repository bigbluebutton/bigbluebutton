{"version":3,"file":"multiRenderTarget.js","sourceRoot":"","sources":["../../../../sourceES6/core/Materials/Textures/multiRenderTarget.ts"],"names":[],"mappings":"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","sourcesContent":["import { Scene } from \"../../scene\";\r\nimport { Engine } from \"../../Engines/engine\";\r\nimport { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport { Texture } from \"../../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture\";\r\n\r\n\r\nimport \"../../Engines/Extensions/engine.multiRender\";\r\n\r\n/**\r\n * Creation options of the multi render target texture.\r\n */\r\nexport interface IMultiRenderTargetOptions {\r\n    /**\r\n     * Define if the texture needs to create mip maps after render.\r\n     */\r\n    generateMipMaps?: boolean;\r\n    /**\r\n     * Define the types of all the draw buffers we want to create\r\n     */\r\n    types?: number[];\r\n    /**\r\n     * Define the sampling modes of all the draw buffers we want to create\r\n     */\r\n    samplingModes?: number[];\r\n    /**\r\n     * Define if a depth buffer is required\r\n     */\r\n    generateDepthBuffer?: boolean;\r\n    /**\r\n     * Define if a stencil buffer is required\r\n     */\r\n    generateStencilBuffer?: boolean;\r\n    /**\r\n     * Define if a depth texture is required instead of a depth buffer\r\n     */\r\n    generateDepthTexture?: boolean;\r\n    /**\r\n     * Define the number of desired draw buffers\r\n     */\r\n    textureCount?: number;\r\n    /**\r\n     * Define if aspect ratio should be adapted to the texture or stay the scene one\r\n     */\r\n    doNotChangeAspectRatio?: boolean;\r\n    /**\r\n     * Define the default type of the buffers we are creating\r\n     */\r\n    defaultType?: number;\r\n}\r\n\r\n/**\r\n * A multi render target, like a render target provides the ability to render to a texture.\r\n * Unlike the render target, it can render to several draw buffers in one draw.\r\n * This is specially interesting in deferred rendering or for any effects requiring more than\r\n * just one color from a single pass.\r\n */\r\nexport class MultiRenderTarget extends RenderTargetTexture {\r\n\r\n    private _internalTextures: InternalTexture[];\r\n    private _textures: Texture[];\r\n    private _multiRenderTargetOptions: IMultiRenderTargetOptions;\r\n\r\n    /**\r\n     * Get if draw buffers are currently supported by the used hardware and browser.\r\n     */\r\n    public get isSupported(): boolean {\r\n        return this._engine.webGLVersion > 1 || this._engine.getCaps().drawBuffersExtension;\r\n    }\r\n\r\n    /**\r\n     * Get the list of textures generated by the multi render target.\r\n     */\r\n    public get textures(): Texture[] {\r\n        return this._textures;\r\n    }\r\n\r\n    /**\r\n     * Get the depth texture generated by the multi render target if options.generateDepthTexture has been set\r\n     */\r\n    public get depthTexture(): Texture {\r\n        return this._textures[this._textures.length - 1];\r\n    }\r\n\r\n    /**\r\n     * Set the wrapping mode on U of all the textures we are rendering to.\r\n     * Can be any of the Texture. (CLAMP_ADDRESSMODE, MIRROR_ADDRESSMODE or WRAP_ADDRESSMODE)\r\n     */\r\n    public set wrapU(wrap: number) {\r\n        if (this._textures) {\r\n            for (var i = 0; i < this._textures.length; i++) {\r\n                this._textures[i].wrapU = wrap;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the wrapping mode on V of all the textures we are rendering to.\r\n     * Can be any of the Texture. (CLAMP_ADDRESSMODE, MIRROR_ADDRESSMODE or WRAP_ADDRESSMODE)\r\n     */\r\n    public set wrapV(wrap: number) {\r\n        if (this._textures) {\r\n            for (var i = 0; i < this._textures.length; i++) {\r\n                this._textures[i].wrapV = wrap;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Instantiate a new multi render target texture.\r\n     * A multi render target, like a render target provides the ability to render to a texture.\r\n     * Unlike the render target, it can render to several draw buffers in one draw.\r\n     * This is specially interesting in deferred rendering or for any effects requiring more than\r\n     * just one color from a single pass.\r\n     * @param name Define the name of the texture\r\n     * @param size Define the size of the buffers to render to\r\n     * @param count Define the number of target we are rendering into\r\n     * @param scene Define the scene the texture belongs to\r\n     * @param options Define the options used to create the multi render target\r\n     */\r\n    constructor(name: string, size: any, count: number, scene: Scene, options?: IMultiRenderTargetOptions) {\r\n        var generateMipMaps = options && options.generateMipMaps ? options.generateMipMaps : false;\r\n        var generateDepthTexture = options && options.generateDepthTexture ? options.generateDepthTexture : false;\r\n        var doNotChangeAspectRatio = !options || options.doNotChangeAspectRatio === undefined ? true : options.doNotChangeAspectRatio;\r\n\r\n        super(name, size, scene, generateMipMaps, doNotChangeAspectRatio);\r\n\r\n        this._engine = scene.getEngine();\r\n\r\n        if (!this.isSupported) {\r\n            this.dispose();\r\n            return;\r\n        }\r\n\r\n        var types = [];\r\n        var samplingModes = [];\r\n\r\n        for (var i = 0; i < count; i++) {\r\n            if (options && options.types && options.types[i] !== undefined) {\r\n                types.push(options.types[i]);\r\n            } else {\r\n                types.push(options && options.defaultType ? options.defaultType : 0);\r\n            }\r\n\r\n            if (options && options.samplingModes && options.samplingModes[i] !== undefined) {\r\n                samplingModes.push(options.samplingModes[i]);\r\n            } else {\r\n                samplingModes.push(Texture.BILINEAR_SAMPLINGMODE);\r\n            }\r\n        }\r\n\r\n        var generateDepthBuffer = !options || options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;\r\n        var generateStencilBuffer = !options || options.generateStencilBuffer === undefined ? false : options.generateStencilBuffer;\r\n\r\n        this._size = size;\r\n        this._multiRenderTargetOptions = {\r\n            samplingModes: samplingModes,\r\n            generateMipMaps: generateMipMaps,\r\n            generateDepthBuffer: generateDepthBuffer,\r\n            generateStencilBuffer: generateStencilBuffer,\r\n            generateDepthTexture: generateDepthTexture,\r\n            types: types,\r\n            textureCount: count\r\n        };\r\n\r\n        this._createInternalTextures();\r\n        this._createTextures();\r\n    }\r\n\r\n    /** @hidden */\r\n    public _rebuild(): void {\r\n        this.releaseInternalTextures();\r\n        this._createInternalTextures();\r\n\r\n        for (var i = 0; i < this._internalTextures.length; i++) {\r\n            var texture = this._textures[i];\r\n            texture._texture = this._internalTextures[i];\r\n        }\r\n\r\n        // Keeps references to frame buffer and stencil/depth buffer\r\n        this._texture = this._internalTextures[0];\r\n    }\r\n\r\n    private _createInternalTextures(): void {\r\n        this._internalTextures = this._engine.createMultipleRenderTarget(this._size, this._multiRenderTargetOptions);\r\n    }\r\n\r\n    private _createTextures(): void {\r\n        this._textures = [];\r\n        for (var i = 0; i < this._internalTextures.length; i++) {\r\n            var texture = new Texture(null, this.getScene());\r\n            texture._texture = this._internalTextures[i];\r\n            this._textures.push(texture);\r\n        }\r\n\r\n        // Keeps references to frame buffer and stencil/depth buffer\r\n        this._texture = this._internalTextures[0];\r\n    }\r\n\r\n    /**\r\n     * Define the number of samples used if MSAA is enabled.\r\n     */\r\n    public get samples(): number {\r\n        return this._samples;\r\n    }\r\n\r\n    public set samples(value: number) {\r\n        if (this._samples === value) {\r\n            return;\r\n        }\r\n\r\n        this._samples = this._engine.updateMultipleRenderTargetTextureSampleCount(this._internalTextures, value);\r\n    }\r\n\r\n    /**\r\n     * Resize all the textures in the multi render target.\r\n     * Be carrefull as it will recreate all the data in the new texture.\r\n     * @param size Define the new size\r\n     */\r\n    public resize(size: any) {\r\n        this.releaseInternalTextures();\r\n        this._size = size;\r\n        this._createInternalTextures();\r\n    }\r\n\r\n    protected unbindFrameBuffer(engine: Engine, faceIndex: number): void {\r\n        engine.unBindMultiColorAttachmentFramebuffer(this._internalTextures, this.isCube, () => {\r\n            this.onAfterRenderObservable.notifyObservers(faceIndex);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Dispose the render targets and their associated resources\r\n     */\r\n    public dispose(): void {\r\n        this.releaseInternalTextures();\r\n\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Release all the underlying texture used as draw buffers.\r\n     */\r\n    public releaseInternalTextures(): void {\r\n        if (!this._internalTextures) {\r\n            return;\r\n        }\r\n\r\n        for (var i = this._internalTextures.length - 1; i >= 0; i--) {\r\n            if (this._internalTextures[i] !== undefined) {\r\n                this._internalTextures[i].dispose();\r\n                this._internalTextures.splice(i, 1);\r\n            }\r\n        }\r\n    }\r\n}\r\n"]}