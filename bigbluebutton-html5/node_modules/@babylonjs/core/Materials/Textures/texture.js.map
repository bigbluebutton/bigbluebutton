{"version":3,"file":"texture.js","sourceRoot":"","sources":["../../../../sourceES6/core/Materials/Textures/texture.ts"],"names":[],"mappings":"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","sourcesContent":["import { serialize, SerializationHelper } from \"../../Misc/decorators\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { Nullable } from \"../../types\";\r\nimport { Matrix, Vector3 } from \"../../Maths/math.vector\";\r\nimport { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\n\r\nimport { _TypeStore } from '../../Misc/typeStore';\r\nimport { _DevTools } from '../../Misc/devTools';\r\nimport { IInspectable } from '../../Misc/iInspectable';\r\nimport { ThinEngine } from '../../Engines/thinEngine';\r\nimport { TimingTools } from '../../Misc/timingTools';\r\nimport { InstantiationTools } from '../../Misc/instantiationTools';\r\nimport { Plane } from '../../Maths/math.plane';\r\nimport { StringTools } from '../../Misc/stringTools';\r\n\r\ndeclare type CubeTexture = import(\"../../Materials/Textures/cubeTexture\").CubeTexture;\r\ndeclare type MirrorTexture = import(\"../../Materials/Textures/mirrorTexture\").MirrorTexture;\r\ndeclare type RenderTargetTexture = import(\"../../Materials/Textures/renderTargetTexture\").RenderTargetTexture;\r\ndeclare type Scene = import(\"../../scene\").Scene;\r\n\r\n/**\r\n * This represents a texture in babylon. It can be easily loaded from a network, base64 or html input.\r\n * @see http://doc.babylonjs.com/babylon101/materials#texture\r\n */\r\nexport class Texture extends BaseTexture {\r\n    /**\r\n     * Gets or sets a general boolean used to indicate that textures containing direct data (buffers) must be saved as part of the serialization process\r\n     */\r\n    public static SerializeBuffers = true;\r\n\r\n    /** @hidden */\r\n    public static _CubeTextureParser = (jsonTexture: any, scene: Scene, rootUrl: string): CubeTexture => {\r\n        throw _DevTools.WarnImport(\"CubeTexture\");\r\n    }\r\n    /** @hidden */\r\n    public static _CreateMirror = (name: string, renderTargetSize: number, scene: Scene, generateMipMaps: boolean): MirrorTexture => {\r\n        throw _DevTools.WarnImport(\"MirrorTexture\");\r\n    }\r\n    /** @hidden */\r\n    public static _CreateRenderTargetTexture = (name: string, renderTargetSize: number, scene: Scene, generateMipMaps: boolean): RenderTargetTexture => {\r\n        throw _DevTools.WarnImport(\"RenderTargetTexture\");\r\n    }\r\n\r\n    /** nearest is mag = nearest and min = nearest and mip = linear */\r\n    public static readonly NEAREST_SAMPLINGMODE = 1;\r\n    /** nearest is mag = nearest and min = nearest and mip = linear */\r\n    public static readonly NEAREST_NEAREST_MIPLINEAR = 8; // nearest is mag = nearest and min = nearest and mip = linear\r\n\r\n    /** Bilinear is mag = linear and min = linear and mip = nearest */\r\n    public static readonly BILINEAR_SAMPLINGMODE = 2;\r\n    /** Bilinear is mag = linear and min = linear and mip = nearest */\r\n    public static readonly LINEAR_LINEAR_MIPNEAREST = 11; // Bilinear is mag = linear and min = linear and mip = nearest\r\n\r\n    /** Trilinear is mag = linear and min = linear and mip = linear */\r\n    public static readonly TRILINEAR_SAMPLINGMODE = 3;\r\n    /** Trilinear is mag = linear and min = linear and mip = linear */\r\n    public static readonly LINEAR_LINEAR_MIPLINEAR = 3; // Trilinear is mag = linear and min = linear and mip = linear\r\n\r\n    /** mag = nearest and min = nearest and mip = nearest */\r\n    public static readonly NEAREST_NEAREST_MIPNEAREST = 4;\r\n    /** mag = nearest and min = linear and mip = nearest */\r\n    public static readonly NEAREST_LINEAR_MIPNEAREST = 5;\r\n    /** mag = nearest and min = linear and mip = linear */\r\n    public static readonly NEAREST_LINEAR_MIPLINEAR = 6;\r\n    /** mag = nearest and min = linear and mip = none */\r\n    public static readonly NEAREST_LINEAR = 7;\r\n    /** mag = nearest and min = nearest and mip = none */\r\n    public static readonly NEAREST_NEAREST = 1;\r\n    /** mag = linear and min = nearest and mip = nearest */\r\n    public static readonly LINEAR_NEAREST_MIPNEAREST = 9;\r\n    /** mag = linear and min = nearest and mip = linear */\r\n    public static readonly LINEAR_NEAREST_MIPLINEAR = 10;\r\n    /** mag = linear and min = linear and mip = none */\r\n    public static readonly LINEAR_LINEAR = 2;\r\n    /** mag = linear and min = nearest and mip = none */\r\n    public static readonly LINEAR_NEAREST = 12;\r\n\r\n    /** Explicit coordinates mode */\r\n    public static readonly EXPLICIT_MODE = 0;\r\n    /** Spherical coordinates mode */\r\n    public static readonly SPHERICAL_MODE = 1;\r\n    /** Planar coordinates mode */\r\n    public static readonly PLANAR_MODE = 2;\r\n    /** Cubic coordinates mode */\r\n    public static readonly CUBIC_MODE = 3;\r\n    /** Projection coordinates mode */\r\n    public static readonly PROJECTION_MODE = 4;\r\n    /** Inverse Cubic coordinates mode */\r\n    public static readonly SKYBOX_MODE = 5;\r\n    /** Inverse Cubic coordinates mode */\r\n    public static readonly INVCUBIC_MODE = 6;\r\n    /** Equirectangular coordinates mode */\r\n    public static readonly EQUIRECTANGULAR_MODE = 7;\r\n    /** Equirectangular Fixed coordinates mode */\r\n    public static readonly FIXED_EQUIRECTANGULAR_MODE = 8;\r\n    /** Equirectangular Fixed Mirrored coordinates mode */\r\n    public static readonly FIXED_EQUIRECTANGULAR_MIRRORED_MODE = 9;\r\n\r\n    /** Texture is not repeating outside of 0..1 UVs */\r\n    public static readonly CLAMP_ADDRESSMODE = 0;\r\n    /** Texture is repeating outside of 0..1 UVs */\r\n    public static readonly WRAP_ADDRESSMODE = 1;\r\n    /** Texture is repeating and mirrored */\r\n    public static readonly MIRROR_ADDRESSMODE = 2;\r\n\r\n    /**\r\n     * Gets or sets a boolean which defines if the texture url must be build from the serialized URL instead of just using the name and loading them side by side with the scene file\r\n     */\r\n    public static UseSerializedUrlIfAny = false;\r\n\r\n    /**\r\n     * Define the url of the texture.\r\n     */\r\n    @serialize()\r\n    public url: Nullable<string> = null;\r\n\r\n    /**\r\n     * Define an offset on the texture to offset the u coordinates of the UVs\r\n     * @see http://doc.babylonjs.com/how_to/more_materials#offsetting\r\n     */\r\n    @serialize()\r\n    public uOffset = 0;\r\n\r\n    /**\r\n     * Define an offset on the texture to offset the v coordinates of the UVs\r\n     * @see http://doc.babylonjs.com/how_to/more_materials#offsetting\r\n     */\r\n    @serialize()\r\n    public vOffset = 0;\r\n\r\n    /**\r\n     * Define an offset on the texture to scale the u coordinates of the UVs\r\n     * @see http://doc.babylonjs.com/how_to/more_materials#tiling\r\n     */\r\n    @serialize()\r\n    public uScale = 1.0;\r\n\r\n    /**\r\n     * Define an offset on the texture to scale the v coordinates of the UVs\r\n     * @see http://doc.babylonjs.com/how_to/more_materials#tiling\r\n     */\r\n    @serialize()\r\n    public vScale = 1.0;\r\n\r\n    /**\r\n     * Define an offset on the texture to rotate around the u coordinates of the UVs\r\n     * @see http://doc.babylonjs.com/how_to/more_materials\r\n     */\r\n    @serialize()\r\n    public uAng = 0;\r\n\r\n    /**\r\n     * Define an offset on the texture to rotate around the v coordinates of the UVs\r\n     * @see http://doc.babylonjs.com/how_to/more_materials\r\n     */\r\n    @serialize()\r\n    public vAng = 0;\r\n\r\n    /**\r\n     * Define an offset on the texture to rotate around the w coordinates of the UVs (in case of 3d texture)\r\n     * @see http://doc.babylonjs.com/how_to/more_materials\r\n     */\r\n    @serialize()\r\n    public wAng = 0;\r\n\r\n    /**\r\n     * Defines the center of rotation (U)\r\n     */\r\n    @serialize()\r\n    public uRotationCenter = 0.5;\r\n\r\n    /**\r\n     * Defines the center of rotation (V)\r\n     */\r\n    @serialize()\r\n    public vRotationCenter = 0.5;\r\n\r\n    /**\r\n     * Defines the center of rotation (W)\r\n     */\r\n    @serialize()\r\n    public wRotationCenter = 0.5;\r\n\r\n    /**\r\n     * Are mip maps generated for this texture or not.\r\n     */\r\n    get noMipmap(): boolean {\r\n        return this._noMipmap;\r\n    }\r\n\r\n    /**\r\n     * List of inspectable custom properties (used by the Inspector)\r\n     * @see https://doc.babylonjs.com/how_to/debug_layer#extensibility\r\n     */\r\n    public inspectableCustomProperties: Nullable<IInspectable[]> = null;\r\n\r\n    private _noMipmap: boolean = false;\r\n    /** @hidden */\r\n    public _invertY: boolean = false;\r\n    private _rowGenerationMatrix: Nullable<Matrix> = null;\r\n    private _cachedTextureMatrix: Nullable<Matrix> = null;\r\n    private _projectionModeMatrix: Nullable<Matrix> = null;\r\n    private _t0: Nullable<Vector3> = null;\r\n    private _t1: Nullable<Vector3> = null;\r\n    private _t2: Nullable<Vector3> = null;\r\n\r\n    private _cachedUOffset: number = -1;\r\n    private _cachedVOffset: number = -1;\r\n    private _cachedUScale: number = 0;\r\n    private _cachedVScale: number = 0;\r\n    private _cachedUAng: number = -1;\r\n    private _cachedVAng: number = -1;\r\n    private _cachedWAng: number = -1;\r\n    private _cachedProjectionMatrixId: number = -1;\r\n    private _cachedCoordinatesMode: number = -1;\r\n\r\n    /** @hidden */\r\n    protected _initialSamplingMode = Texture.BILINEAR_SAMPLINGMODE;\r\n\r\n    /** @hidden */\r\n    public _buffer: Nullable<string | ArrayBuffer | ArrayBufferView | HTMLImageElement | Blob | ImageBitmap> = null;\r\n    private _deleteBuffer: boolean = false;\r\n    protected _format: Nullable<number> = null;\r\n    private _delayedOnLoad: Nullable<() => void> = null;\r\n    private _delayedOnError: Nullable<() => void> = null;\r\n    private _mimeType?: string;\r\n\r\n    /**\r\n     * Observable triggered once the texture has been loaded.\r\n     */\r\n    public onLoadObservable: Observable<Texture> = new Observable<Texture>();\r\n\r\n    protected _isBlocking: boolean = true;\r\n    /**\r\n     * Is the texture preventing material to render while loading.\r\n     * If false, a default texture will be used instead of the loading one during the preparation step.\r\n     */\r\n    public set isBlocking(value: boolean) {\r\n        this._isBlocking = value;\r\n    }\r\n    @serialize()\r\n    public get isBlocking(): boolean {\r\n        return this._isBlocking;\r\n    }\r\n\r\n    /**\r\n     * Get the current sampling mode associated with the texture.\r\n     */\r\n    public get samplingMode(): number {\r\n        if (!this._texture) {\r\n            return this._initialSamplingMode;\r\n        }\r\n\r\n        return this._texture.samplingMode;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if the texture needs to be inverted on the y axis during loading\r\n     */\r\n    public get invertY(): boolean {\r\n        return this._invertY;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new texture.\r\n     * This represents a texture in babylon. It can be easily loaded from a network, base64 or html input.\r\n     * @see http://doc.babylonjs.com/babylon101/materials#texture\r\n     * @param url defines the url of the picture to load as a texture\r\n     * @param scene defines the scene or engine the texture will belong to\r\n     * @param noMipmap defines if the texture will require mip maps or not\r\n     * @param invertY defines if the texture needs to be inverted on the y axis during loading\r\n     * @param samplingMode defines the sampling mode we want for the texture while fectching from it (Texture.NEAREST_SAMPLINGMODE...)\r\n     * @param onLoad defines a callback triggered when the texture has been loaded\r\n     * @param onError defines a callback triggered when an error occurred during the loading session\r\n     * @param buffer defines the buffer to load the texture from in case the texture is loaded from a buffer representation\r\n     * @param deleteBuffer defines if the buffer we are loading the texture from should be deleted after load\r\n     * @param format defines the format of the texture we are trying to load (Engine.TEXTUREFORMAT_RGBA...)\r\n     * @param mimeType defines an optional mime type information\r\n     */\r\n    constructor(url: Nullable<string>, sceneOrEngine: Nullable<Scene | ThinEngine>, noMipmap: boolean = false, invertY: boolean = true, samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE, onLoad: Nullable<() => void> = null, onError: Nullable<(message?: string, exception?: any) => void> = null, buffer: Nullable<string | ArrayBuffer | ArrayBufferView | HTMLImageElement | Blob | ImageBitmap> = null, deleteBuffer: boolean = false, format?: number, mimeType?: string) {\r\n        super((sceneOrEngine && sceneOrEngine.getClassName() === \"Scene\") ? (sceneOrEngine as Scene) : null);\r\n\r\n        this.name = url || \"\";\r\n        this.url = url;\r\n        this._noMipmap = noMipmap;\r\n        this._invertY = invertY;\r\n        this._initialSamplingMode = samplingMode;\r\n        this._buffer = buffer;\r\n        this._deleteBuffer = deleteBuffer;\r\n        this._mimeType = mimeType;\r\n        if (format) {\r\n            this._format = format;\r\n        }\r\n\r\n        var scene = this.getScene();\r\n        var engine = (sceneOrEngine && (sceneOrEngine as ThinEngine).getCaps) ? (sceneOrEngine as ThinEngine) : (scene ? scene.getEngine() : null);\r\n\r\n        if (!engine) {\r\n            return;\r\n        }\r\n\r\n        engine.onBeforeTextureInitObservable.notifyObservers(this);\r\n\r\n        let load = () => {\r\n            if (this._texture) {\r\n                if (this._texture._invertVScale) {\r\n                    this.vScale *= -1;\r\n                    this.vOffset += 1;\r\n                }\r\n\r\n                // Update texutre to match internal texture's wrapping\r\n                if (this._texture._cachedWrapU !== null) {\r\n                    this.wrapU = this._texture._cachedWrapU;\r\n                    this._texture._cachedWrapU = null;\r\n                }\r\n                if (this._texture._cachedWrapV !== null) {\r\n                    this.wrapV = this._texture._cachedWrapV;\r\n                    this._texture._cachedWrapV = null;\r\n                }\r\n                if (this._texture._cachedWrapR !== null) {\r\n                    this.wrapR = this._texture._cachedWrapR;\r\n                    this._texture._cachedWrapR = null;\r\n                }\r\n            }\r\n\r\n            if (this.onLoadObservable.hasObservers()) {\r\n                this.onLoadObservable.notifyObservers(this);\r\n            }\r\n            if (onLoad) {\r\n                onLoad();\r\n            }\r\n\r\n            if (!this.isBlocking && scene) {\r\n                scene.resetCachedMaterial();\r\n            }\r\n        };\r\n\r\n        if (!this.url) {\r\n            this._delayedOnLoad = load;\r\n            this._delayedOnError = onError;\r\n            return;\r\n        }\r\n\r\n        this._texture = this._getFromCache(this.url, noMipmap, samplingMode, invertY);\r\n\r\n        if (!this._texture) {\r\n            if (!scene || !scene.useDelayedTextureLoading) {\r\n                this._texture = engine.createTexture(this.url, noMipmap, invertY, scene, samplingMode, load, onError, this._buffer, undefined, this._format, null, mimeType);\r\n                if (deleteBuffer) {\r\n                    delete this._buffer;\r\n                }\r\n            } else {\r\n                this.delayLoadState = 4;\r\n\r\n                this._delayedOnLoad = load;\r\n                this._delayedOnError = onError;\r\n            }\r\n        } else {\r\n            if (this._texture.isReady) {\r\n                TimingTools.SetImmediate(() => load());\r\n            } else {\r\n                this._texture.onLoadedObservable.add(load);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the url (and optional buffer) of this texture if url was null during construction.\r\n     * @param url the url of the texture\r\n     * @param buffer the buffer of the texture (defaults to null)\r\n     * @param onLoad callback called when the texture is loaded  (defaults to null)\r\n     */\r\n    public updateURL(url: string, buffer: Nullable<string | ArrayBuffer | ArrayBufferView | HTMLImageElement | Blob> = null, onLoad?: () => void): void {\r\n        if (this.url) {\r\n            this.releaseInternalTexture();\r\n            this.getScene()!.markAllMaterialsAsDirty(1);\r\n        }\r\n\r\n        if (!this.name || StringTools.StartsWith(this.name, \"data:\")) {\r\n            this.name = url;\r\n        }\r\n        this.url = url;\r\n        this._buffer = buffer;\r\n        this.delayLoadState = 4;\r\n\r\n        if (onLoad) {\r\n            this._delayedOnLoad = onLoad;\r\n        }\r\n        this.delayLoad();\r\n    }\r\n\r\n    /**\r\n     * Finish the loading sequence of a texture flagged as delayed load.\r\n     * @hidden\r\n     */\r\n    public delayLoad(): void {\r\n        if (this.delayLoadState !== 4) {\r\n            return;\r\n        }\r\n\r\n        let scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        this.delayLoadState = 1;\r\n        this._texture = this._getFromCache(this.url, this._noMipmap, this.samplingMode, this._invertY);\r\n\r\n        if (!this._texture) {\r\n            this._texture = scene.getEngine().createTexture(this.url, this._noMipmap, this._invertY, scene, this.samplingMode, this._delayedOnLoad, this._delayedOnError, this._buffer, null, this._format, null, this._mimeType);\r\n            if (this._deleteBuffer) {\r\n                delete this._buffer;\r\n            }\r\n        } else {\r\n            if (this._delayedOnLoad) {\r\n                if (this._texture.isReady) {\r\n                    TimingTools.SetImmediate(this._delayedOnLoad);\r\n                } else {\r\n                    this._texture.onLoadedObservable.add(this._delayedOnLoad);\r\n                }\r\n            }\r\n        }\r\n\r\n        this._delayedOnLoad = null;\r\n        this._delayedOnError = null;\r\n    }\r\n\r\n    private _prepareRowForTextureGeneration(x: number, y: number, z: number, t: Vector3): void {\r\n        x *= this._cachedUScale;\r\n        y *= this._cachedVScale;\r\n\r\n        x -= this.uRotationCenter * this._cachedUScale;\r\n        y -= this.vRotationCenter * this._cachedVScale;\r\n        z -= this.wRotationCenter;\r\n\r\n        Vector3.TransformCoordinatesFromFloatsToRef(x, y, z, this._rowGenerationMatrix!, t);\r\n\r\n        t.x += this.uRotationCenter * this._cachedUScale + this._cachedUOffset;\r\n        t.y += this.vRotationCenter * this._cachedVScale + this._cachedVOffset;\r\n        t.z += this.wRotationCenter;\r\n    }\r\n\r\n    /**\r\n     * Get the current texture matrix which includes the requested offsetting, tiling and rotation components.\r\n     * @returns the transform matrix of the texture.\r\n     */\r\n    public getTextureMatrix(uBase = 1): Matrix {\r\n        if (\r\n            this.uOffset === this._cachedUOffset &&\r\n            this.vOffset === this._cachedVOffset &&\r\n            this.uScale * uBase === this._cachedUScale &&\r\n            this.vScale === this._cachedVScale &&\r\n            this.uAng === this._cachedUAng &&\r\n            this.vAng === this._cachedVAng &&\r\n            this.wAng === this._cachedWAng) {\r\n            return this._cachedTextureMatrix!;\r\n        }\r\n\r\n        this._cachedUOffset = this.uOffset;\r\n        this._cachedVOffset = this.vOffset;\r\n        this._cachedUScale = this.uScale * uBase;\r\n        this._cachedVScale = this.vScale;\r\n        this._cachedUAng = this.uAng;\r\n        this._cachedVAng = this.vAng;\r\n        this._cachedWAng = this.wAng;\r\n\r\n        if (!this._cachedTextureMatrix) {\r\n            this._cachedTextureMatrix = Matrix.Zero();\r\n            this._rowGenerationMatrix = new Matrix();\r\n            this._t0 = Vector3.Zero();\r\n            this._t1 = Vector3.Zero();\r\n            this._t2 = Vector3.Zero();\r\n        }\r\n\r\n        Matrix.RotationYawPitchRollToRef(this.vAng, this.uAng, this.wAng, this._rowGenerationMatrix!);\r\n\r\n        this._prepareRowForTextureGeneration(0, 0, 0, this._t0!);\r\n        this._prepareRowForTextureGeneration(1.0, 0, 0, this._t1!);\r\n        this._prepareRowForTextureGeneration(0, 1.0, 0, this._t2!);\r\n\r\n        this._t1!.subtractInPlace(this._t0!);\r\n        this._t2!.subtractInPlace(this._t0!);\r\n\r\n        Matrix.FromValuesToRef(\r\n            this._t1!.x, this._t1!.y, this._t1!.z, 0.0,\r\n            this._t2!.x, this._t2!.y, this._t2!.z, 0.0,\r\n            this._t0!.x, this._t0!.y, this._t0!.z, 0.0,\r\n            0.0, 0.0, 0.0, 1.0,\r\n            this._cachedTextureMatrix\r\n        );\r\n\r\n        let scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return this._cachedTextureMatrix;\r\n        }\r\n\r\n        scene.markAllMaterialsAsDirty(1, (mat) => {\r\n            return mat.hasTexture(this);\r\n        });\r\n\r\n        return this._cachedTextureMatrix;\r\n    }\r\n\r\n    /**\r\n     * Get the current matrix used to apply reflection. This is useful to rotate an environment texture for instance.\r\n     * @returns The reflection texture transform\r\n     */\r\n    public getReflectionTextureMatrix(): Matrix {\r\n        let scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return this._cachedTextureMatrix!;\r\n        }\r\n\r\n        if (\r\n            this.uOffset === this._cachedUOffset &&\r\n            this.vOffset === this._cachedVOffset &&\r\n            this.uScale === this._cachedUScale &&\r\n            this.vScale === this._cachedVScale &&\r\n            this.coordinatesMode === this._cachedCoordinatesMode) {\r\n            if (this.coordinatesMode === Texture.PROJECTION_MODE) {\r\n                if (this._cachedProjectionMatrixId === scene.getProjectionMatrix().updateFlag) {\r\n                    return this._cachedTextureMatrix!;\r\n                }\r\n            } else {\r\n                return this._cachedTextureMatrix!;\r\n            }\r\n        }\r\n\r\n        if (!this._cachedTextureMatrix) {\r\n            this._cachedTextureMatrix = Matrix.Zero();\r\n        }\r\n\r\n        if (!this._projectionModeMatrix) {\r\n            this._projectionModeMatrix = Matrix.Zero();\r\n        }\r\n\r\n        this._cachedUOffset = this.uOffset;\r\n        this._cachedVOffset = this.vOffset;\r\n        this._cachedUScale = this.uScale;\r\n        this._cachedVScale = this.vScale;\r\n        this._cachedCoordinatesMode = this.coordinatesMode;\r\n\r\n        switch (this.coordinatesMode) {\r\n            case Texture.PLANAR_MODE:\r\n                Matrix.IdentityToRef(this._cachedTextureMatrix);\r\n                (<any>this._cachedTextureMatrix)[0] = this.uScale;\r\n                (<any>this._cachedTextureMatrix)[5] = this.vScale;\r\n                (<any>this._cachedTextureMatrix)[12] = this.uOffset;\r\n                (<any>this._cachedTextureMatrix)[13] = this.vOffset;\r\n                break;\r\n            case Texture.PROJECTION_MODE:\r\n                Matrix.FromValuesToRef(\r\n                    0.5, 0.0, 0.0, 0.0,\r\n                    0.0, -0.5, 0.0, 0.0,\r\n                    0.0, 0.0, 0.0, 0.0,\r\n                    0.5, 0.5, 1.0, 1.0,\r\n                    this._projectionModeMatrix\r\n                );\r\n\r\n                let projectionMatrix = scene.getProjectionMatrix();\r\n                this._cachedProjectionMatrixId = projectionMatrix.updateFlag;\r\n                projectionMatrix.multiplyToRef(this._projectionModeMatrix, this._cachedTextureMatrix);\r\n                break;\r\n            default:\r\n                Matrix.IdentityToRef(this._cachedTextureMatrix);\r\n                break;\r\n        }\r\n\r\n        scene.markAllMaterialsAsDirty(1, (mat) => {\r\n            return (mat.getActiveTextures().indexOf(this) !== -1);\r\n        });\r\n\r\n        return this._cachedTextureMatrix;\r\n    }\r\n\r\n    /**\r\n     * Clones the texture.\r\n     * @returns the cloned texture\r\n     */\r\n    public clone(): Texture {\r\n        return SerializationHelper.Clone(() => {\r\n            return new Texture(this._texture ? this._texture.url : null, this.getScene(), this._noMipmap, this._invertY, this.samplingMode, undefined, undefined, this._texture ? this._texture._buffer : undefined);\r\n        }, this);\r\n    }\r\n\r\n    /**\r\n     * Serialize the texture to a JSON representation we can easily use in the resepective Parse function.\r\n     * @returns The JSON representation of the texture\r\n     */\r\n    public serialize(): any {\r\n        let savedName = this.name;\r\n        if (!Texture.SerializeBuffers) {\r\n            if (StringTools.StartsWith(this.name, \"data:\")) {\r\n                this.name = \"\";\r\n            }\r\n        }\r\n\r\n        var serializationObject = super.serialize();\r\n\r\n        if (!serializationObject) {\r\n            return null;\r\n        }\r\n\r\n        if (Texture.SerializeBuffers) {\r\n            if (typeof this._buffer === \"string\" && (this._buffer as string).substr(0, 5) === \"data:\") {\r\n                serializationObject.base64String = this._buffer;\r\n                serializationObject.name = serializationObject.name.replace(\"data:\", \"\");\r\n            } else if (this.url && StringTools.StartsWith(this.url, \"data:\") && this._buffer instanceof Uint8Array) {\r\n                serializationObject.base64String = \"data:image/png;base64,\" + StringTools.EncodeArrayBufferToBase64(this._buffer);\r\n            }\r\n        }\r\n\r\n        serializationObject.invertY = this._invertY;\r\n        serializationObject.samplingMode = this.samplingMode;\r\n\r\n        this.name = savedName;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Get the current class name of the texture useful for serialization or dynamic coding.\r\n     * @returns \"Texture\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"Texture\";\r\n    }\r\n\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    public dispose(): void {\r\n        super.dispose();\r\n\r\n        this.onLoadObservable.clear();\r\n\r\n        this._delayedOnLoad = null;\r\n        this._delayedOnError = null;\r\n    }\r\n\r\n    /**\r\n     * Parse the JSON representation of a texture in order to recreate the texture in the given scene.\r\n     * @param parsedTexture Define the JSON representation of the texture\r\n     * @param scene Define the scene the parsed texture should be instantiated in\r\n     * @param rootUrl Define the root url of the parsing sequence in the case of relative dependencies\r\n     * @returns The parsed texture if successful\r\n     */\r\n    public static Parse(parsedTexture: any, scene: Scene, rootUrl: string): Nullable<BaseTexture> {\r\n        if (parsedTexture.customType) {\r\n            var customTexture = InstantiationTools.Instantiate(parsedTexture.customType);\r\n            // Update Sampling Mode\r\n            var parsedCustomTexture: any = customTexture.Parse(parsedTexture, scene, rootUrl);\r\n            if (parsedTexture.samplingMode && parsedCustomTexture.updateSamplingMode && parsedCustomTexture._samplingMode) {\r\n                if (parsedCustomTexture._samplingMode !== parsedTexture.samplingMode) {\r\n                    parsedCustomTexture.updateSamplingMode(parsedTexture.samplingMode);\r\n                }\r\n            }\r\n            return parsedCustomTexture;\r\n        }\r\n\r\n        if (parsedTexture.isCube && !parsedTexture.isRenderTarget) {\r\n            return Texture._CubeTextureParser(parsedTexture, scene, rootUrl);\r\n        }\r\n\r\n        if (!parsedTexture.name && !parsedTexture.isRenderTarget) {\r\n            return null;\r\n        }\r\n\r\n        var texture = SerializationHelper.Parse(() => {\r\n            var generateMipMaps: boolean = true;\r\n            if (parsedTexture.noMipmap) {\r\n                generateMipMaps = false;\r\n            }\r\n            if (parsedTexture.mirrorPlane) {\r\n                var mirrorTexture = Texture._CreateMirror(parsedTexture.name, parsedTexture.renderTargetSize, scene, generateMipMaps);\r\n                mirrorTexture._waitingRenderList = parsedTexture.renderList;\r\n                mirrorTexture.mirrorPlane = Plane.FromArray(parsedTexture.mirrorPlane);\r\n\r\n                return mirrorTexture;\r\n            } else if (parsedTexture.isRenderTarget) {\r\n                let renderTargetTexture: Nullable<RenderTargetTexture> = null;\r\n                if (parsedTexture.isCube) {\r\n                    // Search for an existing reflection probe (which contains a cube render target texture)\r\n                    if (scene.reflectionProbes) {\r\n                        for (var index = 0; index < scene.reflectionProbes.length; index++) {\r\n                            const probe = scene.reflectionProbes[index];\r\n                            if (probe.name === parsedTexture.name) {\r\n                                return probe.cubeTexture;\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    renderTargetTexture = Texture._CreateRenderTargetTexture(parsedTexture.name, parsedTexture.renderTargetSize, scene, generateMipMaps);\r\n                    renderTargetTexture._waitingRenderList = parsedTexture.renderList;\r\n                }\r\n\r\n                return renderTargetTexture;\r\n            } else {\r\n                var texture: Texture;\r\n                if (parsedTexture.base64String) {\r\n                    texture = Texture.CreateFromBase64String(parsedTexture.base64String, parsedTexture.name, scene, !generateMipMaps, parsedTexture.invertY);\r\n                } else {\r\n                    let url = rootUrl + parsedTexture.name;\r\n\r\n                    if (Texture.UseSerializedUrlIfAny && parsedTexture.url) {\r\n                        url = parsedTexture.url;\r\n                    }\r\n                    texture = new Texture(url, scene, !generateMipMaps, parsedTexture.invertY);\r\n                }\r\n\r\n                return texture;\r\n            }\r\n        }, parsedTexture, scene);\r\n\r\n        // Clear cache\r\n        if (texture && texture._texture) {\r\n            texture._texture._cachedWrapU = null;\r\n            texture._texture._cachedWrapV = null;\r\n            texture._texture._cachedWrapR = null;\r\n        }\r\n\r\n        // Update Sampling Mode\r\n        if (parsedTexture.samplingMode) {\r\n            var sampling: number = parsedTexture.samplingMode;\r\n            if (texture && texture.samplingMode !== sampling) {\r\n                texture.updateSamplingMode(sampling);\r\n            }\r\n        }\r\n        // Animations\r\n        if (texture && parsedTexture.animations) {\r\n            for (var animationIndex = 0; animationIndex < parsedTexture.animations.length; animationIndex++) {\r\n                var parsedAnimation = parsedTexture.animations[animationIndex];\r\n                const internalClass = _TypeStore.GetClass(\"BABYLON.Animation\");\r\n                if (internalClass) {\r\n                    texture.animations.push(internalClass.Parse(parsedAnimation));\r\n                }\r\n            }\r\n        }\r\n\r\n        return texture;\r\n    }\r\n\r\n    /**\r\n     * Creates a texture from its base 64 representation.\r\n     * @param data Define the base64 payload without the data: prefix\r\n     * @param name Define the name of the texture in the scene useful fo caching purpose for instance\r\n     * @param scene Define the scene the texture should belong to\r\n     * @param noMipmap Forces the texture to not create mip map information if true\r\n     * @param invertY define if the texture needs to be inverted on the y axis during loading\r\n     * @param samplingMode define the sampling mode we want for the texture while fectching from it (Texture.NEAREST_SAMPLINGMODE...)\r\n     * @param onLoad define a callback triggered when the texture has been loaded\r\n     * @param onError define a callback triggered when an error occurred during the loading session\r\n     * @param format define the format of the texture we are trying to load (Engine.TEXTUREFORMAT_RGBA...)\r\n     * @returns the created texture\r\n     */\r\n    public static CreateFromBase64String(data: string, name: string, scene: Scene, noMipmap?: boolean, invertY?: boolean, samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE,\r\n        onLoad: Nullable<() => void> = null, onError: Nullable<() => void> = null, format: number = 5): Texture {\r\n        return new Texture(\"data:\" + name, scene, noMipmap, invertY, samplingMode, onLoad, onError, data, false, format);\r\n    }\r\n\r\n    /**\r\n     * Creates a texture from its data: representation. (data: will be added in case only the payload has been passed in)\r\n     * @param data Define the base64 payload without the data: prefix\r\n     * @param name Define the name of the texture in the scene useful fo caching purpose for instance\r\n     * @param buffer define the buffer to load the texture from in case the texture is loaded from a buffer representation\r\n     * @param scene Define the scene the texture should belong to\r\n     * @param deleteBuffer define if the buffer we are loading the texture from should be deleted after load\r\n     * @param noMipmap Forces the texture to not create mip map information if true\r\n     * @param invertY define if the texture needs to be inverted on the y axis during loading\r\n     * @param samplingMode define the sampling mode we want for the texture while fectching from it (Texture.NEAREST_SAMPLINGMODE...)\r\n     * @param onLoad define a callback triggered when the texture has been loaded\r\n     * @param onError define a callback triggered when an error occurred during the loading session\r\n     * @param format define the format of the texture we are trying to load (Engine.TEXTUREFORMAT_RGBA...)\r\n     * @returns the created texture\r\n     */\r\n    public static LoadFromDataString(name: string, buffer: any, scene: Scene, deleteBuffer: boolean = false, noMipmap: boolean = false, invertY: boolean = true, samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE,\r\n        onLoad: Nullable<() => void> = null, onError: Nullable<(message?: string, exception?: any) => void> = null, format: number = 5): Texture {\r\n        if (name.substr(0, 5) !== \"data:\") {\r\n            name = \"data:\" + name;\r\n        }\r\n\r\n        return new Texture(name, scene, noMipmap, invertY, samplingMode, onLoad, onError, buffer, deleteBuffer, format);\r\n    }\r\n}\r\n\r\n// References the dependencies.\r\nSerializationHelper._TextureParser = Texture.Parse;\r\n"]}