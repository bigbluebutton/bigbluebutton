import { Observable } from "../../Misc/observable";
import { SmartArray } from "../../Misc/smartArray";
import { Nullable, Immutable } from "../../types";
import { Camera } from "../../Cameras/camera";
import { Scene } from "../../scene";
import { Matrix, Vector3 } from "../../Maths/math.vector";
import { Color4 } from '../../Maths/math.color';
import { RenderTargetCreationOptions } from "../../Materials/Textures/renderTargetCreationOptions";
import { AbstractMesh } from "../../Meshes/abstractMesh";
import { SubMesh } from "../../Meshes/subMesh";
import { InternalTexture } from "../../Materials/Textures/internalTexture";
import { Texture } from "../../Materials/Textures/texture";
import { PostProcess } from "../../PostProcesses/postProcess";
import { RenderingManager } from "../../Rendering/renderingManager";
import "../../Engines/Extensions/engine.renderTarget";
import "../../Engines/Extensions/engine.renderTargetCube";
import { Engine } from '../../Engines/engine';
/**
 * This Helps creating a texture that will be created from a camera in your scene.
 * It is basically a dynamic texture that could be used to create special effects for instance.
 * Actually, It is the base of lot of effects in the framework like post process, shadows, effect layers and rendering pipelines...
 */
export declare class RenderTargetTexture extends Texture {
    isCube: boolean;
    /**
     * The texture will only be rendered once which can be useful to improve performance if everything in your render is static for instance.
     */
    static readonly REFRESHRATE_RENDER_ONCE: number;
    /**
     * The texture will only be rendered rendered every frame and is recomended for dynamic contents.
     */
    static readonly REFRESHRATE_RENDER_ONEVERYFRAME: number;
    /**
     * The texture will be rendered every 2 frames which could be enough if your dynamic objects are not
     * the central point of your effect and can save a lot of performances.
     */
    static readonly REFRESHRATE_RENDER_ONEVERYTWOFRAMES: number;
    /**
    * Use this predicate to dynamically define the list of mesh you want to render.
    * If set, the renderList property will be overwritten.
    */
    renderListPredicate: (AbstractMesh: AbstractMesh) => boolean;
    private _renderList;
    /**
    * Use this list to define the list of mesh you want to render.
    */
    get renderList(): Nullable<Array<AbstractMesh>>;
    set renderList(value: Nullable<Array<AbstractMesh>>);
    /**
     * Use this function to overload the renderList array at rendering time.
     * Return null to render with the curent renderList, else return the list of meshes to use for rendering.
     * For 2DArray RTT, layerOrFace is the index of the layer that is going to be rendered, else it is the faceIndex of
     * the cube (if the RTT is a cube, else layerOrFace=0).
     * The renderList passed to the function is the current render list (the one that will be used if the function returns null).
     * The length of this list is passed through renderListLength: don't use renderList.length directly because the array can
     * hold dummy elements!
    */
    getCustomRenderList: (layerOrFace: number, renderList: Nullable<Immutable<Array<AbstractMesh>>>, renderListLength: number) => Nullable<Array<AbstractMesh>>;
    private _hookArray;
    /**
     * Define if particles should be rendered in your texture.
     */
    renderParticles: boolean;
    /**
     * Define if sprites should be rendered in your texture.
     */
    renderSprites: boolean;
    /**
     * Override the default coordinates mode to projection for RTT as it is the most common case for rendered textures.
     */
    coordinatesMode: number;
    /**
     * Define the camera used to render the texture.
     */
    activeCamera: Nullable<Camera>;
    /**
     * Override the render function of the texture with your own one.
     */
    customRenderFunction: (opaqueSubMeshes: SmartArray<SubMesh>, alphaTestSubMeshes: SmartArray<SubMesh>, transparentSubMeshes: SmartArray<SubMesh>, depthOnlySubMeshes: SmartArray<SubMesh>, beforeTransparents?: () => void) => void;
    /**
     * Define if camera post processes should be use while rendering the texture.
     */
    useCameraPostProcesses: boolean;
    /**
     * Define if the camera viewport should be respected while rendering the texture or if the render should be done to the entire texture.
     */
    ignoreCameraViewport: boolean;
    private _postProcessManager;
    private _postProcesses;
    private _resizeObserver;
    /**
    * An event triggered when the texture is unbind.
    */
    onBeforeBindObservable: Observable<RenderTargetTexture>;
    /**
    * An event triggered when the texture is unbind.
    */
    onAfterUnbindObservable: Observable<RenderTargetTexture>;
    private _onAfterUnbindObserver;
    /**
     * Set a after unbind callback in the texture.
     * This has been kept for backward compatibility and use of onAfterUnbindObservable is recommended.
     */
    set onAfterUnbind(callback: () => void);
    /**
    * An event triggered before rendering the texture
    */
    onBeforeRenderObservable: Observable<number>;
    private _onBeforeRenderObserver;
    /**
     * Set a before render callback in the texture.
     * This has been kept for backward compatibility and use of onBeforeRenderObservable is recommended.
     */
    set onBeforeRender(callback: (faceIndex: number) => void);
    /**
    * An event triggered after rendering the texture
    */
    onAfterRenderObservable: Observable<number>;
    private _onAfterRenderObserver;
    /**
     * Set a after render callback in the texture.
     * This has been kept for backward compatibility and use of onAfterRenderObservable is recommended.
     */
    set onAfterRender(callback: (faceIndex: number) => void);
    /**
    * An event triggered after the texture clear
    */
    onClearObservable: Observable<Engine>;
    private _onClearObserver;
    /**
     * Set a clear callback in the texture.
     * This has been kept for backward compatibility and use of onClearObservable is recommended.
     */
    set onClear(callback: (Engine: Engine) => void);
    /**
     * An event triggered when the texture is resized.
     */
    onResizeObservable: Observable<RenderTargetTexture>;
    /**
     * Define the clear color of the Render Target if it should be different from the scene.
     */
    clearColor: Color4;
    protected _size: number | {
        width: number;
        height: number;
        layers?: number;
    };
    protected _initialSizeParameter: number | {
        width: number;
        height: number;
    } | {
        ratio: number;
    };
    protected _sizeRatio: Nullable<number>;
    /** @hidden */
    _generateMipMaps: boolean;
    protected _renderingManager: RenderingManager;
    /** @hidden */
    _waitingRenderList: string[];
    protected _doNotChangeAspectRatio: boolean;
    protected _currentRefreshId: number;
    protected _refreshRate: number;
    protected _textureMatrix: Matrix;
    protected _samples: number;
    protected _renderTargetOptions: RenderTargetCreationOptions;
    /**
     * Gets render target creation options that were used.
     */
    get renderTargetOptions(): RenderTargetCreationOptions;
    protected _engine: Engine;
    protected _onRatioRescale(): void;
    /**
     * Gets or sets the center of the bounding box associated with the texture (when in cube mode)
     * It must define where the camera used to render the texture is set
     */
    boundingBoxPosition: Vector3;
    private _boundingBoxSize;
    /**
     * Gets or sets the size of the bounding box associated with the texture (when in cube mode)
     * When defined, the cubemap will switch to local mode
     * @see https://community.arm.com/graphics/b/blog/posts/reflections-based-on-local-cubemaps-in-unity
     * @example https://www.babylonjs-playground.com/#RNASML
     */
    set boundingBoxSize(value: Vector3);
    get boundingBoxSize(): Vector3;
    /**
     * In case the RTT has been created with a depth texture, get the associated
     * depth texture.
     * Otherwise, return null.
     */
    get depthStencilTexture(): Nullable<InternalTexture>;
    /**
     * Instantiate a render target texture. This is mainly used to render of screen the scene to for instance apply post processse
     * or used a shadow, depth texture...
     * @param name The friendly name of the texture
     * @param size The size of the RTT (number if square, or {width: number, height:number} or {ratio:} to define a ratio from the main scene)
     * @param scene The scene the RTT belongs to. The latest created scene will be used if not precised.
     * @param generateMipMaps True if mip maps need to be generated after render.
     * @param doNotChangeAspectRatio True to not change the aspect ratio of the scene in the RTT
     * @param type The type of the buffer in the RTT (int, half float, float...)
     * @param isCube True if a cube texture needs to be created
     * @param samplingMode The sampling mode to be usedwith the render target (Linear, Nearest...)
     * @param generateDepthBuffer True to generate a depth buffer
     * @param generateStencilBuffer True to generate a stencil buffer
     * @param isMulti True if multiple textures need to be created (Draw Buffers)
     * @param format The internal format of the buffer in the RTT (RED, RG, RGB, RGBA, ALPHA...)
     * @param delayAllocation if the texture allocation should be delayed (default: false)
     */
    constructor(name: string, size: number | {
        width: number;
        height: number;
        layers?: number;
    } | {
        ratio: number;
    }, scene: Nullable<Scene>, generateMipMaps?: boolean, doNotChangeAspectRatio?: boolean, type?: number, isCube?: boolean, samplingMode?: number, generateDepthBuffer?: boolean, generateStencilBuffer?: boolean, isMulti?: boolean, format?: number, delayAllocation?: boolean);
    /**
     * Creates a depth stencil texture.
     * This is only available in WebGL 2 or with the depth texture extension available.
     * @param comparisonFunction Specifies the comparison function to set on the texture. If 0 or undefined, the texture is not in comparison mode
     * @param bilinearFiltering Specifies whether or not bilinear filtering is enable on the texture
     * @param generateStencil Specifies whether or not a stencil should be allocated in the texture
     */
    createDepthStencilTexture(comparisonFunction?: number, bilinearFiltering?: boolean, generateStencil?: boolean): void;
    private _processSizeParameter;
    /**
     * Define the number of samples to use in case of MSAA.
     * It defaults to one meaning no MSAA has been enabled.
     */
    get samples(): number;
    set samples(value: number);
    /**
     * Resets the refresh counter of the texture and start bak from scratch.
     * Could be useful to regenerate the texture if it is setup to render only once.
     */
    resetRefreshCounter(): void;
    /**
     * Define the refresh rate of the texture or the rendering frequency.
     * Use 0 to render just once, 1 to render on every frame, 2 to render every two frames and so on...
     */
    get refreshRate(): number;
    set refreshRate(value: number);
    /**
     * Adds a post process to the render target rendering passes.
     * @param postProcess define the post process to add
     */
    addPostProcess(postProcess: PostProcess): void;
    /**
     * Clear all the post processes attached to the render target
     * @param dispose define if the cleared post processesshould also be disposed (false by default)
     */
    clearPostProcesses(dispose?: boolean): void;
    /**
     * Remove one of the post process from the list of attached post processes to the texture
     * @param postProcess define the post process to remove from the list
     */
    removePostProcess(postProcess: PostProcess): void;
    /** @hidden */
    _shouldRender(): boolean;
    /**
     * Gets the actual render size of the texture.
     * @returns the width of the render size
     */
    getRenderSize(): number;
    /**
     * Gets the actual render width of the texture.
     * @returns the width of the render size
     */
    getRenderWidth(): number;
    /**
     * Gets the actual render height of the texture.
     * @returns the height of the render size
     */
    getRenderHeight(): number;
    /**
     * Gets the actual number of layers of the texture.
     * @returns the number of layers
     */
    getRenderLayers(): number;
    /**
     * Get if the texture can be rescaled or not.
     */
    get canRescale(): boolean;
    /**
     * Resize the texture using a ratio.
     * @param ratio the ratio to apply to the texture size in order to compute the new target size
     */
    scale(ratio: number): void;
    /**
     * Get the texture reflection matrix used to rotate/transform the reflection.
     * @returns the reflection matrix
     */
    getReflectionTextureMatrix(): Matrix;
    /**
     * Resize the texture to a new desired size.
     * Be carrefull as it will recreate all the data in the new texture.
     * @param size Define the new size. It can be:
     *   - a number for squared texture,
     *   - an object containing { width: number, height: number }
     *   - or an object containing a ratio { ratio: number }
     */
    resize(size: number | {
        width: number;
        height: number;
    } | {
        ratio: number;
    }): void;
    private _defaultRenderListPrepared;
    /**
     * Renders all the objects from the render list into the texture.
     * @param useCameraPostProcess Define if camera post processes should be used during the rendering
     * @param dumpForDebug Define if the rendering result should be dumped (copied) for debugging purpose
     */
    render(useCameraPostProcess?: boolean, dumpForDebug?: boolean): void;
    private _bestReflectionRenderTargetDimension;
    private _prepareRenderingManager;
    /**
     * @hidden
     * @param faceIndex face index to bind to if this is a cubetexture
     * @param layer defines the index of the texture to bind in the array
     */
    _bindFrameBuffer(faceIndex?: number, layer?: number): void;
    protected unbindFrameBuffer(engine: Engine, faceIndex: number): void;
    private renderToTarget;
    /**
     * Overrides the default sort function applied in the renderging group to prepare the meshes.
     * This allowed control for front to back rendering or reversly depending of the special needs.
     *
     * @param renderingGroupId The rendering group id corresponding to its index
     * @param opaqueSortCompareFn The opaque queue comparison function use to sort.
     * @param alphaTestSortCompareFn The alpha test queue comparison function use to sort.
     * @param transparentSortCompareFn The transparent queue comparison function use to sort.
     */
    setRenderingOrder(renderingGroupId: number, opaqueSortCompareFn?: Nullable<(a: SubMesh, b: SubMesh) => number>, alphaTestSortCompareFn?: Nullable<(a: SubMesh, b: SubMesh) => number>, transparentSortCompareFn?: Nullable<(a: SubMesh, b: SubMesh) => number>): void;
    /**
     * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.
     *
     * @param renderingGroupId The rendering group id corresponding to its index
     * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.
     */
    setRenderingAutoClearDepthStencil(renderingGroupId: number, autoClearDepthStencil: boolean): void;
    /**
     * Clones the texture.
     * @returns the cloned texture
     */
    clone(): RenderTargetTexture;
    /**
     * Serialize the texture to a JSON representation we can easily use in the resepective Parse function.
     * @returns The JSON representation of the texture
     */
    serialize(): any;
    /**
     *  This will remove the attached framebuffer objects. The texture will not be able to be used as render target anymore
     */
    disposeFramebufferObjects(): void;
    /**
     * Dispose the texture and release its associated resources.
     */
    dispose(): void;
    /** @hidden */
    _rebuild(): void;
    /**
     * Clear the info related to rendering groups preventing retention point in material dispose.
     */
    freeRenderingGroups(): void;
    /**
     * Gets the number of views the corresponding to the texture (eg. a MultiviewRenderTarget will have > 1)
     * @returns the view count
     */
    getViewCount(): number;
}
