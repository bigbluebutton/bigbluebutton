{"version":3,"file":"renderTargetTexture.js","sourceRoot":"","sources":["../../../../sourceES6/core/Materials/Textures/renderTargetTexture.ts"],"names":[],"mappings":"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","sourcesContent":["import { Observer, Observable } from \"../../Misc/observable\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport { SmartArray } from \"../../Misc/smartArray\";\r\nimport { Nullable, Immutable } from \"../../types\";\r\nimport { Camera } from \"../../Cameras/camera\";\r\nimport { Scene } from \"../../scene\";\r\nimport { Matrix, Vector3 } from \"../../Maths/math.vector\";\r\nimport { Color4 } from '../../Maths/math.color';\r\nimport { RenderTargetCreationOptions } from \"../../Materials/Textures/renderTargetCreationOptions\";\r\nimport { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { SubMesh } from \"../../Meshes/subMesh\";\r\nimport { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport { Texture } from \"../../Materials/Textures/texture\";\r\nimport { PostProcessManager } from \"../../PostProcesses/postProcessManager\";\r\nimport { PostProcess } from \"../../PostProcesses/postProcess\";\r\nimport { RenderingManager } from \"../../Rendering/renderingManager\";\r\n\r\n\r\nimport \"../../Engines/Extensions/engine.renderTarget\";\r\nimport \"../../Engines/Extensions/engine.renderTargetCube\";\r\nimport { InstancedMesh } from '../../Meshes/instancedMesh';\r\nimport { Engine } from '../../Engines/engine';\r\n\r\n/**\r\n * This Helps creating a texture that will be created from a camera in your scene.\r\n * It is basically a dynamic texture that could be used to create special effects for instance.\r\n * Actually, It is the base of lot of effects in the framework like post process, shadows, effect layers and rendering pipelines...\r\n */\r\nexport class RenderTargetTexture extends Texture {\r\n    /**\r\n     * The texture will only be rendered once which can be useful to improve performance if everything in your render is static for instance.\r\n     */\r\n    public static readonly REFRESHRATE_RENDER_ONCE: number = 0;\r\n    /**\r\n     * The texture will only be rendered rendered every frame and is recomended for dynamic contents.\r\n     */\r\n    public static readonly REFRESHRATE_RENDER_ONEVERYFRAME: number = 1;\r\n    /**\r\n     * The texture will be rendered every 2 frames which could be enough if your dynamic objects are not\r\n     * the central point of your effect and can save a lot of performances.\r\n     */\r\n    public static readonly REFRESHRATE_RENDER_ONEVERYTWOFRAMES: number = 2;\r\n\r\n    /**\r\n    * Use this predicate to dynamically define the list of mesh you want to render.\r\n    * If set, the renderList property will be overwritten.\r\n    */\r\n    public renderListPredicate: (AbstractMesh: AbstractMesh) => boolean;\r\n\r\n    private _renderList: Nullable<Array<AbstractMesh>>;\r\n    /**\r\n    * Use this list to define the list of mesh you want to render.\r\n    */\r\n    public get renderList(): Nullable<Array<AbstractMesh>> {\r\n        return this._renderList;\r\n    }\r\n\r\n    public set renderList(value: Nullable<Array<AbstractMesh>>) {\r\n        this._renderList = value;\r\n\r\n        if (this._renderList) {\r\n            this._hookArray(this._renderList);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Use this function to overload the renderList array at rendering time.\r\n     * Return null to render with the curent renderList, else return the list of meshes to use for rendering.\r\n     * For 2DArray RTT, layerOrFace is the index of the layer that is going to be rendered, else it is the faceIndex of\r\n     * the cube (if the RTT is a cube, else layerOrFace=0).\r\n     * The renderList passed to the function is the current render list (the one that will be used if the function returns null).\r\n     * The length of this list is passed through renderListLength: don't use renderList.length directly because the array can\r\n     * hold dummy elements!\r\n    */\r\n    public getCustomRenderList: (layerOrFace: number, renderList: Nullable<Immutable<Array<AbstractMesh>>>, renderListLength: number) => Nullable<Array<AbstractMesh>>;\r\n\r\n    private _hookArray(array: AbstractMesh[]): void {\r\n        var oldPush = array.push;\r\n        array.push = (...items: AbstractMesh[]) => {\r\n            let wasEmpty = array.length === 0;\r\n\r\n            var result = oldPush.apply(array, items);\r\n\r\n            if (wasEmpty) {\r\n                this.getScene()!.meshes.forEach((mesh) => {\r\n                    mesh._markSubMeshesAsLightDirty();\r\n                });\r\n            }\r\n\r\n            return result;\r\n        };\r\n\r\n        var oldSplice = array.splice;\r\n        array.splice = (index: number, deleteCount?: number) => {\r\n            var deleted = oldSplice.apply(array, [index, deleteCount]);\r\n\r\n            if (array.length === 0) {\r\n                this.getScene()!.meshes.forEach((mesh) => {\r\n                    mesh._markSubMeshesAsLightDirty();\r\n                });\r\n            }\r\n\r\n            return deleted;\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Define if particles should be rendered in your texture.\r\n     */\r\n    public renderParticles = true;\r\n    /**\r\n     * Define if sprites should be rendered in your texture.\r\n     */\r\n    public renderSprites = false;\r\n    /**\r\n     * Override the default coordinates mode to projection for RTT as it is the most common case for rendered textures.\r\n     */\r\n    public coordinatesMode = Texture.PROJECTION_MODE;\r\n    /**\r\n     * Define the camera used to render the texture.\r\n     */\r\n    public activeCamera: Nullable<Camera>;\r\n    /**\r\n     * Override the render function of the texture with your own one.\r\n     */\r\n    public customRenderFunction: (opaqueSubMeshes: SmartArray<SubMesh>, alphaTestSubMeshes: SmartArray<SubMesh>, transparentSubMeshes: SmartArray<SubMesh>, depthOnlySubMeshes: SmartArray<SubMesh>, beforeTransparents?: () => void) => void;\r\n    /**\r\n     * Define if camera post processes should be use while rendering the texture.\r\n     */\r\n    public useCameraPostProcesses: boolean;\r\n    /**\r\n     * Define if the camera viewport should be respected while rendering the texture or if the render should be done to the entire texture.\r\n     */\r\n    public ignoreCameraViewport: boolean = false;\r\n\r\n    private _postProcessManager: Nullable<PostProcessManager>;\r\n    private _postProcesses: PostProcess[];\r\n    private _resizeObserver: Nullable<Observer<Engine>>;\r\n\r\n    /**\r\n    * An event triggered when the texture is unbind.\r\n    */\r\n    public onBeforeBindObservable = new Observable<RenderTargetTexture>();\r\n\r\n    /**\r\n    * An event triggered when the texture is unbind.\r\n    */\r\n    public onAfterUnbindObservable = new Observable<RenderTargetTexture>();\r\n\r\n    private _onAfterUnbindObserver: Nullable<Observer<RenderTargetTexture>>;\r\n    /**\r\n     * Set a after unbind callback in the texture.\r\n     * This has been kept for backward compatibility and use of onAfterUnbindObservable is recommended.\r\n     */\r\n    public set onAfterUnbind(callback: () => void) {\r\n        if (this._onAfterUnbindObserver) {\r\n            this.onAfterUnbindObservable.remove(this._onAfterUnbindObserver);\r\n        }\r\n        this._onAfterUnbindObserver = this.onAfterUnbindObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n    * An event triggered before rendering the texture\r\n    */\r\n    public onBeforeRenderObservable = new Observable<number>();\r\n\r\n    private _onBeforeRenderObserver: Nullable<Observer<number>>;\r\n    /**\r\n     * Set a before render callback in the texture.\r\n     * This has been kept for backward compatibility and use of onBeforeRenderObservable is recommended.\r\n     */\r\n    public set onBeforeRender(callback: (faceIndex: number) => void) {\r\n        if (this._onBeforeRenderObserver) {\r\n            this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);\r\n        }\r\n        this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n    * An event triggered after rendering the texture\r\n    */\r\n    public onAfterRenderObservable = new Observable<number>();\r\n\r\n    private _onAfterRenderObserver: Nullable<Observer<number>>;\r\n    /**\r\n     * Set a after render callback in the texture.\r\n     * This has been kept for backward compatibility and use of onAfterRenderObservable is recommended.\r\n     */\r\n    public set onAfterRender(callback: (faceIndex: number) => void) {\r\n        if (this._onAfterRenderObserver) {\r\n            this.onAfterRenderObservable.remove(this._onAfterRenderObserver);\r\n        }\r\n        this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n    * An event triggered after the texture clear\r\n    */\r\n    public onClearObservable = new Observable<Engine>();\r\n\r\n    private _onClearObserver: Nullable<Observer<Engine>>;\r\n    /**\r\n     * Set a clear callback in the texture.\r\n     * This has been kept for backward compatibility and use of onClearObservable is recommended.\r\n     */\r\n    public set onClear(callback: (Engine: Engine) => void) {\r\n        if (this._onClearObserver) {\r\n            this.onClearObservable.remove(this._onClearObserver);\r\n        }\r\n        this._onClearObserver = this.onClearObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * An event triggered when the texture is resized.\r\n     */\r\n    public onResizeObservable = new Observable<RenderTargetTexture>();\r\n\r\n    /**\r\n     * Define the clear color of the Render Target if it should be different from the scene.\r\n     */\r\n    public clearColor: Color4;\r\n    protected _size: number | { width: number, height: number, layers?: number };\r\n    protected _initialSizeParameter: number | { width: number, height: number } | { ratio: number };\r\n    protected _sizeRatio: Nullable<number>;\r\n    /** @hidden */\r\n    public _generateMipMaps: boolean;\r\n    protected _renderingManager: RenderingManager;\r\n    /** @hidden */\r\n    public _waitingRenderList: string[];\r\n    protected _doNotChangeAspectRatio: boolean;\r\n    protected _currentRefreshId = -1;\r\n    protected _refreshRate = 1;\r\n    protected _textureMatrix: Matrix;\r\n    protected _samples = 1;\r\n    protected _renderTargetOptions: RenderTargetCreationOptions;\r\n    /**\r\n     * Gets render target creation options that were used.\r\n     */\r\n    public get renderTargetOptions(): RenderTargetCreationOptions {\r\n        return this._renderTargetOptions;\r\n    }\r\n\r\n    protected _engine: Engine;\r\n\r\n    protected _onRatioRescale(): void {\r\n        if (this._sizeRatio) {\r\n            this.resize(this._initialSizeParameter);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the center of the bounding box associated with the texture (when in cube mode)\r\n     * It must define where the camera used to render the texture is set\r\n     */\r\n    public boundingBoxPosition = Vector3.Zero();\r\n\r\n    private _boundingBoxSize: Vector3;\r\n\r\n    /**\r\n     * Gets or sets the size of the bounding box associated with the texture (when in cube mode)\r\n     * When defined, the cubemap will switch to local mode\r\n     * @see https://community.arm.com/graphics/b/blog/posts/reflections-based-on-local-cubemaps-in-unity\r\n     * @example https://www.babylonjs-playground.com/#RNASML\r\n     */\r\n    public set boundingBoxSize(value: Vector3) {\r\n        if (this._boundingBoxSize && this._boundingBoxSize.equals(value)) {\r\n            return;\r\n        }\r\n        this._boundingBoxSize = value;\r\n        let scene = this.getScene();\r\n        if (scene) {\r\n            scene.markAllMaterialsAsDirty(1);\r\n        }\r\n    }\r\n    public get boundingBoxSize(): Vector3 {\r\n        return this._boundingBoxSize;\r\n    }\r\n\r\n    /**\r\n     * In case the RTT has been created with a depth texture, get the associated\r\n     * depth texture.\r\n     * Otherwise, return null.\r\n     */\r\n    public get depthStencilTexture(): Nullable<InternalTexture> {\r\n        return this.getInternalTexture()?._depthStencilTexture || null;\r\n    }\r\n\r\n    /**\r\n     * Instantiate a render target texture. This is mainly used to render of screen the scene to for instance apply post processse\r\n     * or used a shadow, depth texture...\r\n     * @param name The friendly name of the texture\r\n     * @param size The size of the RTT (number if square, or {width: number, height:number} or {ratio:} to define a ratio from the main scene)\r\n     * @param scene The scene the RTT belongs to. The latest created scene will be used if not precised.\r\n     * @param generateMipMaps True if mip maps need to be generated after render.\r\n     * @param doNotChangeAspectRatio True to not change the aspect ratio of the scene in the RTT\r\n     * @param type The type of the buffer in the RTT (int, half float, float...)\r\n     * @param isCube True if a cube texture needs to be created\r\n     * @param samplingMode The sampling mode to be usedwith the render target (Linear, Nearest...)\r\n     * @param generateDepthBuffer True to generate a depth buffer\r\n     * @param generateStencilBuffer True to generate a stencil buffer\r\n     * @param isMulti True if multiple textures need to be created (Draw Buffers)\r\n     * @param format The internal format of the buffer in the RTT (RED, RG, RGB, RGBA, ALPHA...)\r\n     * @param delayAllocation if the texture allocation should be delayed (default: false)\r\n     */\r\n    constructor(name: string, size: number | { width: number, height: number, layers?: number } | { ratio: number }, scene: Nullable<Scene>, generateMipMaps?: boolean, doNotChangeAspectRatio: boolean = true, type: number = 0, public isCube = false, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, generateDepthBuffer = true, generateStencilBuffer = false, isMulti = false, format = 5, delayAllocation = false) {\r\n        super(null, scene, !generateMipMaps);\r\n        scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        this.renderList = new Array<AbstractMesh>();\r\n        this._engine = scene.getEngine();\r\n        this.name = name;\r\n        this.isRenderTarget = true;\r\n        this._initialSizeParameter = size;\r\n\r\n        this._processSizeParameter(size);\r\n\r\n        this._resizeObserver = this.getScene()!.getEngine().onResizeObservable.add(() => {\r\n        });\r\n\r\n        this._generateMipMaps = generateMipMaps ? true : false;\r\n        this._doNotChangeAspectRatio = doNotChangeAspectRatio;\r\n\r\n        // Rendering groups\r\n        this._renderingManager = new RenderingManager(scene);\r\n        this._renderingManager._useSceneAutoClearSetup = true;\r\n\r\n        if (isMulti) {\r\n            return;\r\n        }\r\n\r\n        this._renderTargetOptions = {\r\n            generateMipMaps: generateMipMaps,\r\n            type: type,\r\n            format: format,\r\n            samplingMode: samplingMode,\r\n            generateDepthBuffer: generateDepthBuffer,\r\n            generateStencilBuffer: generateStencilBuffer\r\n        };\r\n\r\n        if (samplingMode === Texture.NEAREST_SAMPLINGMODE) {\r\n            this.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n            this.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        }\r\n\r\n        if (!delayAllocation) {\r\n            if (isCube) {\r\n                this._texture = scene.getEngine().createRenderTargetCubeTexture(this.getRenderSize(), this._renderTargetOptions);\r\n                this.coordinatesMode = Texture.INVCUBIC_MODE;\r\n                this._textureMatrix = Matrix.Identity();\r\n            } else {\r\n                this._texture = scene.getEngine().createRenderTargetTexture(this._size, this._renderTargetOptions);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a depth stencil texture.\r\n     * This is only available in WebGL 2 or with the depth texture extension available.\r\n     * @param comparisonFunction Specifies the comparison function to set on the texture. If 0 or undefined, the texture is not in comparison mode\r\n     * @param bilinearFiltering Specifies whether or not bilinear filtering is enable on the texture\r\n     * @param generateStencil Specifies whether or not a stencil should be allocated in the texture\r\n     */\r\n    public createDepthStencilTexture(comparisonFunction: number = 0, bilinearFiltering: boolean = true, generateStencil: boolean = false): void {\r\n        const internalTexture = this.getInternalTexture();\r\n        if (!this.getScene() || !internalTexture) {\r\n            return;\r\n        }\r\n\r\n        var engine = this.getScene()!.getEngine();\r\n        internalTexture._depthStencilTexture = engine.createDepthStencilTexture(this._size, {\r\n            bilinearFiltering,\r\n            comparisonFunction,\r\n            generateStencil,\r\n            isCube: this.isCube\r\n        });\r\n    }\r\n\r\n    private _processSizeParameter(size: number | { width: number, height: number } | { ratio: number }): void {\r\n        if ((<{ ratio: number }>size).ratio) {\r\n            this._sizeRatio = (<{ ratio: number }>size).ratio;\r\n            this._size = {\r\n                width: this._bestReflectionRenderTargetDimension(this._engine.getRenderWidth(), this._sizeRatio),\r\n                height: this._bestReflectionRenderTargetDimension(this._engine.getRenderHeight(), this._sizeRatio)\r\n            };\r\n        } else {\r\n            this._size = <number | { width: number, height: number, layers?: number }>size;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Define the number of samples to use in case of MSAA.\r\n     * It defaults to one meaning no MSAA has been enabled.\r\n     */\r\n    public get samples(): number {\r\n        return this._samples;\r\n    }\r\n\r\n    public set samples(value: number) {\r\n        if (this._samples === value) {\r\n            return;\r\n        }\r\n\r\n        let scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        this._samples = scene.getEngine().updateRenderTargetTextureSampleCount(this._texture, value);\r\n    }\r\n\r\n    /**\r\n     * Resets the refresh counter of the texture and start bak from scratch.\r\n     * Could be useful to regenerate the texture if it is setup to render only once.\r\n     */\r\n    public resetRefreshCounter(): void {\r\n        this._currentRefreshId = -1;\r\n    }\r\n\r\n    /**\r\n     * Define the refresh rate of the texture or the rendering frequency.\r\n     * Use 0 to render just once, 1 to render on every frame, 2 to render every two frames and so on...\r\n     */\r\n    public get refreshRate(): number {\r\n        return this._refreshRate;\r\n    }\r\n    public set refreshRate(value: number) {\r\n        this._refreshRate = value;\r\n        this.resetRefreshCounter();\r\n    }\r\n\r\n    /**\r\n     * Adds a post process to the render target rendering passes.\r\n     * @param postProcess define the post process to add\r\n     */\r\n    public addPostProcess(postProcess: PostProcess): void {\r\n        if (!this._postProcessManager) {\r\n            let scene = this.getScene();\r\n\r\n            if (!scene) {\r\n                return;\r\n            }\r\n            this._postProcessManager = new PostProcessManager(scene);\r\n            this._postProcesses = new Array<PostProcess>();\r\n        }\r\n\r\n        this._postProcesses.push(postProcess);\r\n        this._postProcesses[0].autoClear = false;\r\n    }\r\n\r\n    /**\r\n     * Clear all the post processes attached to the render target\r\n     * @param dispose define if the cleared post processesshould also be disposed (false by default)\r\n     */\r\n    public clearPostProcesses(dispose: boolean = false): void {\r\n        if (!this._postProcesses) {\r\n            return;\r\n        }\r\n\r\n        if (dispose) {\r\n            for (var postProcess of this._postProcesses) {\r\n                postProcess.dispose();\r\n            }\r\n        }\r\n\r\n        this._postProcesses = [];\r\n    }\r\n\r\n    /**\r\n     * Remove one of the post process from the list of attached post processes to the texture\r\n     * @param postProcess define the post process to remove from the list\r\n     */\r\n    public removePostProcess(postProcess: PostProcess): void {\r\n        if (!this._postProcesses) {\r\n            return;\r\n        }\r\n\r\n        var index = this._postProcesses.indexOf(postProcess);\r\n\r\n        if (index === -1) {\r\n            return;\r\n        }\r\n\r\n        this._postProcesses.splice(index, 1);\r\n\r\n        if (this._postProcesses.length > 0) {\r\n            this._postProcesses[0].autoClear = false;\r\n        }\r\n    }\r\n\r\n    /** @hidden */\r\n    public _shouldRender(): boolean {\r\n        if (this._currentRefreshId === -1) { // At least render once\r\n            this._currentRefreshId = 1;\r\n            return true;\r\n        }\r\n\r\n        if (this.refreshRate === this._currentRefreshId) {\r\n            this._currentRefreshId = 1;\r\n            return true;\r\n        }\r\n\r\n        this._currentRefreshId++;\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets the actual render size of the texture.\r\n     * @returns the width of the render size\r\n     */\r\n    public getRenderSize(): number {\r\n        return this.getRenderWidth();\r\n    }\r\n\r\n    /**\r\n     * Gets the actual render width of the texture.\r\n     * @returns the width of the render size\r\n     */\r\n    public getRenderWidth(): number {\r\n        if ((<{ width: number, height: number }>this._size).width) {\r\n            return (<{ width: number, height: number }>this._size).width;\r\n        }\r\n\r\n        return <number>this._size;\r\n    }\r\n\r\n    /**\r\n     * Gets the actual render height of the texture.\r\n     * @returns the height of the render size\r\n     */\r\n    public getRenderHeight(): number {\r\n        if ((<{ width: number, height: number }>this._size).width) {\r\n            return (<{ width: number, height: number }>this._size).height;\r\n        }\r\n\r\n        return <number>this._size;\r\n    }\r\n\r\n    /**\r\n     * Gets the actual number of layers of the texture.\r\n     * @returns the number of layers\r\n     */\r\n    public getRenderLayers(): number {\r\n        const layers = (<{ width: number, height: number, layers?: number }>this._size).layers;\r\n        if (layers) {\r\n            return layers;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Get if the texture can be rescaled or not.\r\n     */\r\n    public get canRescale(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Resize the texture using a ratio.\r\n     * @param ratio the ratio to apply to the texture size in order to compute the new target size\r\n     */\r\n    public scale(ratio: number): void {\r\n        var newSize = Math.max(1, this.getRenderSize() * ratio);\r\n\r\n        this.resize(newSize);\r\n    }\r\n\r\n    /**\r\n     * Get the texture reflection matrix used to rotate/transform the reflection.\r\n     * @returns the reflection matrix\r\n     */\r\n    public getReflectionTextureMatrix(): Matrix {\r\n        if (this.isCube) {\r\n            return this._textureMatrix;\r\n        }\r\n\r\n        return super.getReflectionTextureMatrix();\r\n    }\r\n\r\n    /**\r\n     * Resize the texture to a new desired size.\r\n     * Be carrefull as it will recreate all the data in the new texture.\r\n     * @param size Define the new size. It can be:\r\n     *   - a number for squared texture,\r\n     *   - an object containing { width: number, height: number }\r\n     *   - or an object containing a ratio { ratio: number }\r\n     */\r\n    public resize(size: number | { width: number, height: number } | { ratio: number }): void {\r\n        var wasCube = this.isCube;\r\n\r\n        this.releaseInternalTexture();\r\n        let scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        this._processSizeParameter(size);\r\n\r\n        if (wasCube) {\r\n            this._texture = scene.getEngine().createRenderTargetCubeTexture(this.getRenderSize(), this._renderTargetOptions);\r\n        } else {\r\n            this._texture = scene.getEngine().createRenderTargetTexture(this._size, this._renderTargetOptions);\r\n        }\r\n\r\n        if (this.onResizeObservable.hasObservers()) {\r\n            this.onResizeObservable.notifyObservers(this);\r\n        }\r\n    }\r\n\r\n    private _defaultRenderListPrepared: boolean;\r\n\r\n    /**\r\n     * Renders all the objects from the render list into the texture.\r\n     * @param useCameraPostProcess Define if camera post processes should be used during the rendering\r\n     * @param dumpForDebug Define if the rendering result should be dumped (copied) for debugging purpose\r\n     */\r\n    public render(useCameraPostProcess: boolean = false, dumpForDebug: boolean = false): void {\r\n        var scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        var engine = scene.getEngine();\r\n\r\n        if (this.useCameraPostProcesses !== undefined) {\r\n            useCameraPostProcess = this.useCameraPostProcesses;\r\n        }\r\n\r\n        if (this._waitingRenderList) {\r\n            this.renderList = [];\r\n            for (var index = 0; index < this._waitingRenderList.length; index++) {\r\n                var id = this._waitingRenderList[index];\r\n                let mesh = scene.getMeshByID(id);\r\n                if (mesh) {\r\n                    this.renderList.push(mesh);\r\n                }\r\n            }\r\n\r\n            delete this._waitingRenderList;\r\n        }\r\n\r\n        // Is predicate defined?\r\n        if (this.renderListPredicate) {\r\n            if (this.renderList) {\r\n                this.renderList.length = 0; // Clear previous renderList\r\n            } else {\r\n                this.renderList = [];\r\n            }\r\n\r\n            var scene = this.getScene();\r\n\r\n            if (!scene) {\r\n                return;\r\n            }\r\n\r\n            var sceneMeshes = scene.meshes;\r\n\r\n            for (var index = 0; index < sceneMeshes.length; index++) {\r\n                var mesh = sceneMeshes[index];\r\n                if (this.renderListPredicate(mesh)) {\r\n                    this.renderList.push(mesh);\r\n                }\r\n            }\r\n        }\r\n\r\n        this.onBeforeBindObservable.notifyObservers(this);\r\n\r\n        // Set custom projection.\r\n        // Needs to be before binding to prevent changing the aspect ratio.\r\n        let camera: Nullable<Camera>;\r\n        if (this.activeCamera) {\r\n            camera = this.activeCamera;\r\n            engine.setViewport(this.activeCamera.viewport, this.getRenderWidth(), this.getRenderHeight());\r\n\r\n            if (this.activeCamera !== scene.activeCamera) {\r\n                scene.setTransformMatrix(this.activeCamera.getViewMatrix(), this.activeCamera.getProjectionMatrix(true));\r\n            }\r\n        }\r\n        else {\r\n            camera = scene.activeCamera;\r\n            if (camera) {\r\n                engine.setViewport(camera.viewport, this.getRenderWidth(), this.getRenderHeight());\r\n            }\r\n        }\r\n\r\n        this._defaultRenderListPrepared = false;\r\n\r\n        if (this.is2DArray) {\r\n            for (let layer = 0; layer < this.getRenderLayers(); layer++) {\r\n                this.renderToTarget(0, useCameraPostProcess, dumpForDebug, layer, camera);\r\n                scene.incrementRenderId();\r\n                scene.resetCachedMaterial();\r\n            }\r\n        }\r\n        else if (this.isCube) {\r\n            for (var face = 0; face < 6; face++) {\r\n                this.renderToTarget(face, useCameraPostProcess, dumpForDebug, undefined, camera);\r\n                scene.incrementRenderId();\r\n                scene.resetCachedMaterial();\r\n            }\r\n        } else {\r\n            this.renderToTarget(0, useCameraPostProcess, dumpForDebug, undefined, camera);\r\n        }\r\n\r\n        this.onAfterUnbindObservable.notifyObservers(this);\r\n\r\n        if (scene.activeCamera) {\r\n            // Do not avoid setting uniforms when multiple scenes are active as another camera may have overwrite these\r\n            if (scene.getEngine().scenes.length > 1 || (this.activeCamera && this.activeCamera !== scene.activeCamera)) {\r\n                scene.setTransformMatrix(scene.activeCamera.getViewMatrix(), scene.activeCamera.getProjectionMatrix(true));\r\n            }\r\n            engine.setViewport(scene.activeCamera.viewport);\r\n        }\r\n\r\n        scene.resetCachedMaterial();\r\n    }\r\n\r\n    private _bestReflectionRenderTargetDimension(renderDimension: number, scale: number): number {\r\n        let minimum = 128;\r\n        let x = renderDimension * scale;\r\n        let curved = Engine.NearestPOT(x + (minimum * minimum / (minimum + x)));\r\n\r\n        // Ensure we don't exceed the render dimension (while staying POT)\r\n        return Math.min(Engine.FloorPOT(renderDimension), curved);\r\n    }\r\n\r\n    private _prepareRenderingManager(currentRenderList: Array<AbstractMesh>, currentRenderListLength: number, camera: Nullable<Camera>, checkLayerMask: boolean): void {\r\n        var scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        this._renderingManager.reset();\r\n\r\n        var sceneRenderId = scene.getRenderId();\r\n        for (var meshIndex = 0; meshIndex < currentRenderListLength; meshIndex++) {\r\n            var mesh = currentRenderList[meshIndex];\r\n\r\n            if (mesh) {\r\n                if (!mesh.isReady(this.refreshRate === 0)) {\r\n                    this.resetRefreshCounter();\r\n                    continue;\r\n                }\r\n\r\n                mesh._preActivateForIntermediateRendering(sceneRenderId);\r\n\r\n                let isMasked;\r\n                if (checkLayerMask && camera) {\r\n                    isMasked = ((mesh.layerMask & camera.layerMask) === 0);\r\n                } else {\r\n                    isMasked = false;\r\n                }\r\n\r\n                if (mesh.isEnabled() && mesh.isVisible && mesh.subMeshes && !isMasked) {\r\n                    if (mesh._activate(sceneRenderId, true) && mesh.subMeshes.length) {\r\n                        if (!mesh.isAnInstance) {\r\n                            mesh._internalAbstractMeshDataInfo._onlyForInstancesIntermediate = false;\r\n                        } else {\r\n                            mesh = (mesh as InstancedMesh).sourceMesh;\r\n                        }\r\n                        mesh._internalAbstractMeshDataInfo._isActiveIntermediate = true;\r\n\r\n                        for (var subIndex = 0; subIndex < mesh.subMeshes.length; subIndex++) {\r\n                            var subMesh = mesh.subMeshes[subIndex];\r\n                            this._renderingManager.dispatch(subMesh, mesh);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        for (var particleIndex = 0; particleIndex < scene.particleSystems.length; particleIndex++) {\r\n            var particleSystem = scene.particleSystems[particleIndex];\r\n\r\n            let emitter: any = particleSystem.emitter;\r\n            if (!particleSystem.isStarted() || !emitter || !emitter.position || !emitter.isEnabled()) {\r\n                continue;\r\n            }\r\n\r\n            if (currentRenderList.indexOf(emitter) >= 0) {\r\n                this._renderingManager.dispatchParticles(particleSystem);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     * @param faceIndex face index to bind to if this is a cubetexture\r\n     * @param layer defines the index of the texture to bind in the array\r\n     */\r\n    public _bindFrameBuffer(faceIndex: number = 0, layer = 0) {\r\n        var scene = this.getScene();\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        var engine = scene.getEngine();\r\n        if (this._texture) {\r\n            engine.bindFramebuffer(this._texture, this.isCube ? faceIndex : undefined, undefined, undefined, this.ignoreCameraViewport, 0, layer);\r\n        }\r\n    }\r\n\r\n    protected unbindFrameBuffer(engine: Engine, faceIndex: number): void {\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n        engine.unBindFramebuffer(this._texture, this.isCube, () => {\r\n            this.onAfterRenderObservable.notifyObservers(faceIndex);\r\n        });\r\n    }\r\n\r\n    private renderToTarget(faceIndex: number, useCameraPostProcess: boolean, dumpForDebug: boolean, layer = 0, camera: Nullable<Camera> = null): void {\r\n        var scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        var engine = scene.getEngine();\r\n\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n\r\n        // Bind\r\n        if (this._postProcessManager) {\r\n            this._postProcessManager._prepareFrame(this._texture, this._postProcesses);\r\n        }\r\n        else if (!useCameraPostProcess || !scene.postProcessManager._prepareFrame(this._texture)) {\r\n            this._bindFrameBuffer(faceIndex, layer);\r\n        }\r\n\r\n        if (this.is2DArray) {\r\n            this.onBeforeRenderObservable.notifyObservers(layer);\r\n        }\r\n        else {\r\n            this.onBeforeRenderObservable.notifyObservers(faceIndex);\r\n        }\r\n\r\n        // Get the list of meshes to render\r\n        let currentRenderList: Nullable<Array<AbstractMesh>> = null;\r\n        let defaultRenderList = this.renderList ? this.renderList : scene.getActiveMeshes().data;\r\n        let defaultRenderListLength = this.renderList ? this.renderList.length : scene.getActiveMeshes().length;\r\n\r\n        if (this.getCustomRenderList) {\r\n            currentRenderList = this.getCustomRenderList(this.is2DArray ? layer : faceIndex, defaultRenderList, defaultRenderListLength);\r\n        }\r\n\r\n        if (!currentRenderList) {\r\n            // No custom render list provided, we prepare the rendering for the default list, but check\r\n            // first if we did not already performed the preparation before so as to avoid re-doing it several times\r\n            if (!this._defaultRenderListPrepared) {\r\n                this._prepareRenderingManager(defaultRenderList, defaultRenderListLength, camera, !this.renderList);\r\n                this._defaultRenderListPrepared = true;\r\n            }\r\n            currentRenderList = defaultRenderList;\r\n        } else {\r\n            // Prepare the rendering for the custom render list provided\r\n            this._prepareRenderingManager(currentRenderList, currentRenderList.length, camera, false);\r\n        }\r\n\r\n        // Clear\r\n        if (this.onClearObservable.hasObservers()) {\r\n            this.onClearObservable.notifyObservers(engine);\r\n        } else {\r\n            engine.clear(this.clearColor || scene.clearColor, true, true, true);\r\n        }\r\n\r\n        if (!this._doNotChangeAspectRatio) {\r\n            scene.updateTransformMatrix(true);\r\n        }\r\n\r\n        // Before Camera Draw\r\n        for (let step of scene._beforeRenderTargetDrawStage) {\r\n            step.action(this);\r\n        }\r\n\r\n        // Render\r\n        this._renderingManager.render(this.customRenderFunction, currentRenderList, this.renderParticles, this.renderSprites);\r\n\r\n        // After Camera Draw\r\n        for (let step of scene._afterRenderTargetDrawStage) {\r\n            step.action(this);\r\n        }\r\n\r\n        if (this._postProcessManager) {\r\n            this._postProcessManager._finalizeFrame(false, this._texture, faceIndex, this._postProcesses, this.ignoreCameraViewport);\r\n        }\r\n        else if (useCameraPostProcess) {\r\n            scene.postProcessManager._finalizeFrame(false, this._texture, faceIndex);\r\n        }\r\n\r\n        if (!this._doNotChangeAspectRatio) {\r\n            scene.updateTransformMatrix(true);\r\n        }\r\n\r\n        // Dump ?\r\n        if (dumpForDebug) {\r\n            Tools.DumpFramebuffer(this.getRenderWidth(), this.getRenderHeight(), engine);\r\n        }\r\n\r\n        // Unbind\r\n        if (!this.isCube || faceIndex === 5) {\r\n            if (this.isCube) {\r\n\r\n                if (faceIndex === 5) {\r\n                    engine.generateMipMapsForCubemap(this._texture);\r\n                }\r\n            }\r\n\r\n            this.unbindFrameBuffer(engine, faceIndex);\r\n\r\n        } else {\r\n            this.onAfterRenderObservable.notifyObservers(faceIndex);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Overrides the default sort function applied in the renderging group to prepare the meshes.\r\n     * This allowed control for front to back rendering or reversly depending of the special needs.\r\n     *\r\n     * @param renderingGroupId The rendering group id corresponding to its index\r\n     * @param opaqueSortCompareFn The opaque queue comparison function use to sort.\r\n     * @param alphaTestSortCompareFn The alpha test queue comparison function use to sort.\r\n     * @param transparentSortCompareFn The transparent queue comparison function use to sort.\r\n     */\r\n    public setRenderingOrder(renderingGroupId: number,\r\n        opaqueSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null,\r\n        alphaTestSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null,\r\n        transparentSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null): void {\r\n\r\n        this._renderingManager.setRenderingOrder(renderingGroupId,\r\n            opaqueSortCompareFn,\r\n            alphaTestSortCompareFn,\r\n            transparentSortCompareFn);\r\n    }\r\n\r\n    /**\r\n     * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.\r\n     *\r\n     * @param renderingGroupId The rendering group id corresponding to its index\r\n     * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.\r\n     */\r\n    public setRenderingAutoClearDepthStencil(renderingGroupId: number, autoClearDepthStencil: boolean): void {\r\n        this._renderingManager.setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil);\r\n        this._renderingManager._useSceneAutoClearSetup = false;\r\n    }\r\n\r\n    /**\r\n     * Clones the texture.\r\n     * @returns the cloned texture\r\n     */\r\n    public clone(): RenderTargetTexture {\r\n        var textureSize = this.getSize();\r\n        var newTexture = new RenderTargetTexture(\r\n            this.name,\r\n            textureSize,\r\n            this.getScene(),\r\n            this._renderTargetOptions.generateMipMaps,\r\n            this._doNotChangeAspectRatio,\r\n            this._renderTargetOptions.type,\r\n            this.isCube,\r\n            this._renderTargetOptions.samplingMode,\r\n            this._renderTargetOptions.generateDepthBuffer,\r\n            this._renderTargetOptions.generateStencilBuffer\r\n        );\r\n\r\n        // Base texture\r\n        newTexture.hasAlpha = this.hasAlpha;\r\n        newTexture.level = this.level;\r\n\r\n        // RenderTarget Texture\r\n        newTexture.coordinatesMode = this.coordinatesMode;\r\n        if (this.renderList) {\r\n            newTexture.renderList = this.renderList.slice(0);\r\n        }\r\n\r\n        return newTexture;\r\n    }\r\n\r\n    /**\r\n     * Serialize the texture to a JSON representation we can easily use in the resepective Parse function.\r\n     * @returns The JSON representation of the texture\r\n     */\r\n    public serialize(): any {\r\n        if (!this.name) {\r\n            return null;\r\n        }\r\n\r\n        var serializationObject = super.serialize();\r\n\r\n        serializationObject.renderTargetSize = this.getRenderSize();\r\n        serializationObject.renderList = [];\r\n\r\n        if (this.renderList) {\r\n            for (var index = 0; index < this.renderList.length; index++) {\r\n                serializationObject.renderList.push(this.renderList[index].id);\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     *  This will remove the attached framebuffer objects. The texture will not be able to be used as render target anymore\r\n     */\r\n    public disposeFramebufferObjects(): void {\r\n        let objBuffer = this.getInternalTexture();\r\n        let scene = this.getScene();\r\n        if (objBuffer && scene) {\r\n            scene.getEngine()._releaseFramebufferObjects(objBuffer);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    public dispose(): void {\r\n        this.onResizeObservable.clear();\r\n        this.onClearObservable.clear();\r\n        this.onAfterRenderObservable.clear();\r\n        this.onAfterUnbindObservable.clear();\r\n        this.onBeforeBindObservable.clear();\r\n        this.onBeforeRenderObservable.clear();\r\n\r\n        if (this._postProcessManager) {\r\n            this._postProcessManager.dispose();\r\n            this._postProcessManager = null;\r\n        }\r\n\r\n        this.clearPostProcesses(true);\r\n\r\n        if (this._resizeObserver) {\r\n            this.getScene()!.getEngine().onResizeObservable.remove(this._resizeObserver);\r\n            this._resizeObserver = null;\r\n        }\r\n\r\n        this.renderList = null;\r\n\r\n        // Remove from custom render targets\r\n        var scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        var index = scene.customRenderTargets.indexOf(this);\r\n\r\n        if (index >= 0) {\r\n            scene.customRenderTargets.splice(index, 1);\r\n        }\r\n\r\n        for (var camera of scene.cameras) {\r\n            index = camera.customRenderTargets.indexOf(this);\r\n\r\n            if (index >= 0) {\r\n                camera.customRenderTargets.splice(index, 1);\r\n            }\r\n        }\r\n\r\n        if (this.depthStencilTexture) {\r\n            this.getScene()!.getEngine()._releaseTexture(this.depthStencilTexture);\r\n        }\r\n\r\n        super.dispose();\r\n    }\r\n\r\n    /** @hidden */\r\n    public _rebuild(): void {\r\n        if (this.refreshRate === RenderTargetTexture.REFRESHRATE_RENDER_ONCE) {\r\n            this.refreshRate = RenderTargetTexture.REFRESHRATE_RENDER_ONCE;\r\n        }\r\n\r\n        if (this._postProcessManager) {\r\n            this._postProcessManager._rebuild();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear the info related to rendering groups preventing retention point in material dispose.\r\n     */\r\n    public freeRenderingGroups(): void {\r\n        if (this._renderingManager) {\r\n            this._renderingManager.freeRenderingGroups();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the number of views the corresponding to the texture (eg. a MultiviewRenderTarget will have > 1)\r\n     * @returns the view count\r\n     */\r\n    public getViewCount() {\r\n        return 1;\r\n    }\r\n}\r\n\r\nTexture._CreateRenderTargetTexture = (name: string, renderTargetSize: number, scene: Scene, generateMipMaps: boolean) => {\r\n    return new RenderTargetTexture(name, renderTargetSize, scene, generateMipMaps);\r\n};\r\n"]}