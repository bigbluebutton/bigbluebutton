{"version":3,"file":"proceduralTextureSceneComponent.js","sourceRoot":"","sources":["../../../../../sourceES6/core/Materials/Textures/Procedurals/proceduralTextureSceneComponent.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,KAAK,EAAE,MAAM,qBAAqB,CAAC;AAE5C,OAAO,EAAE,uBAAuB,EAAmB,MAAM,yBAAyB,CAAC;AAanF;;;GAGG;AACH;IAWI;;;OAGG;IACH,yCAAY,KAAY;QAdxB;;WAEG;QACa,SAAI,GAAG,uBAAuB,CAAC,sBAAsB,CAAC;QAYlE,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QACnB,IAAI,CAAC,KAAK,CAAC,kBAAkB,GAAG,IAAI,KAAK,EAAqB,CAAC;IACnE,CAAC;IAED;;OAEG;IACI,kDAAQ,GAAf;QACI,IAAI,CAAC,KAAK,CAAC,iBAAiB,CAAC,YAAY,CAAC,uBAAuB,CAAC,kCAAkC,EAAE,IAAI,EAAE,IAAI,CAAC,YAAY,CAAC,CAAC;IACnI,CAAC;IAED;;;OAGG;IACI,iDAAO,GAAd;QACI,sBAAsB;IAC1B,CAAC;IAED;;OAEG;IACI,iDAAO,GAAd;QACI,sBAAsB;IAC1B,CAAC;IAEO,sDAAY,GAApB;QACI,IAAI,IAAI,CAAC,KAAK,CAAC,yBAAyB,EAAE;YACtC,KAAK,CAAC,uBAAuB,CAAC,qBAAqB,EAAE,IAAI,CAAC,KAAK,CAAC,kBAAkB,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;YAC/F,KAAK,IAAI,eAAe,GAAG,CAAC,EAAE,eAAe,GAAG,IAAI,CAAC,KAAK,CAAC,kBAAkB,CAAC,MAAM,EAAE,eAAe,EAAE,EAAE;gBACrG,IAAI,iBAAiB,GAAG,IAAI,CAAC,KAAK,CAAC,kBAAkB,CAAC,eAAe,CAAC,CAAC;gBACvE,IAAI,iBAAiB,CAAC,aAAa,EAAE,EAAE;oBACnC,iBAAiB,CAAC,MAAM,EAAE,CAAC;iBAC9B;aACJ;YACD,KAAK,CAAC,qBAAqB,CAAC,qBAAqB,EAAE,IAAI,CAAC,KAAK,CAAC,kBAAkB,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;SAChG;IACL,CAAC;IACL,sCAAC;AAAD,CAAC,AAtDD,IAsDC","sourcesContent":["import { Tools } from \"../../../Misc/tools\";\r\nimport { Scene } from \"../../../scene\";\r\nimport { SceneComponentConstants, ISceneComponent } from \"../../../sceneComponent\";\r\n\r\nimport { ProceduralTexture } from \"./proceduralTexture\";\r\n\r\ndeclare module \"../../../abstractScene\" {\r\n    export interface AbstractScene {\r\n        /**\r\n         * The list of procedural textures added to the scene\r\n         * @see http://doc.babylonjs.com/how_to/how_to_use_procedural_textures\r\n         */\r\n        proceduralTextures: Array<ProceduralTexture>;\r\n    }\r\n}\r\n/**\r\n * Defines the Procedural Texture scene component responsible to manage any Procedural Texture\r\n * in a given scene.\r\n */\r\nexport class ProceduralTextureSceneComponent implements ISceneComponent {\r\n    /**\r\n     * The component name helpfull to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_PROCEDURALTEXTURE;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene: Scene) {\r\n        this.scene = scene;\r\n        this.scene.proceduralTextures = new Array<ProceduralTexture>();\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene._beforeClearStage.registerStep(SceneComponentConstants.STEP_BEFORECLEAR_PROCEDURALTEXTURE, this, this._beforeClear);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        // Nothing to do here.\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated ressources.\r\n     */\r\n    public dispose(): void {\r\n        // Nothing to do here.\r\n    }\r\n\r\n    private _beforeClear(): void {\r\n        if (this.scene.proceduralTexturesEnabled) {\r\n            Tools.StartPerformanceCounter(\"Procedural textures\", this.scene.proceduralTextures.length > 0);\r\n            for (var proceduralIndex = 0; proceduralIndex < this.scene.proceduralTextures.length; proceduralIndex++) {\r\n                var proceduralTexture = this.scene.proceduralTextures[proceduralIndex];\r\n                if (proceduralTexture._shouldRender()) {\r\n                    proceduralTexture.render();\r\n                }\r\n            }\r\n            Tools.EndPerformanceCounter(\"Procedural textures\", this.scene.proceduralTextures.length > 0);\r\n        }\r\n    }\r\n}\r\n"]}