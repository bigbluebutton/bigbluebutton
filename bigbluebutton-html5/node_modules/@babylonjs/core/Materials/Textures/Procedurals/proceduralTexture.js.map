{"version":3,"file":"proceduralTexture.js","sourceRoot":"","sources":["../../../../../sourceES6/core/Materials/Textures/Procedurals/proceduralTexture.ts"],"names":[],"mappings":"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","sourcesContent":["import { serialize } from \"../../../Misc/decorators\";\r\nimport { Observable } from \"../../../Misc/observable\";\r\nimport { Nullable } from \"../../../types\";\r\nimport { Scene } from \"../../../scene\";\r\nimport { Matrix, Vector3, Vector2 } from \"../../../Maths/math.vector\";\r\nimport { Color4, Color3 } from '../../../Maths/math.color';\r\nimport { Engine } from \"../../../Engines/engine\";\r\nimport { VertexBuffer } from \"../../../Meshes/buffer\";\r\nimport { SceneComponentConstants } from \"../../../sceneComponent\";\r\n\r\nimport { Material } from \"../../../Materials/material\";\r\nimport { Effect } from \"../../../Materials/effect\";\r\nimport { Texture } from \"../../../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../../../Materials/Textures/renderTargetTexture\";\r\nimport { ProceduralTextureSceneComponent } from \"./proceduralTextureSceneComponent\";\r\n\r\nimport \"../../../Engines/Extensions/engine.renderTarget\";\r\nimport \"../../../Engines/Extensions/engine.renderTargetCube\";\r\nimport \"../../../Shaders/procedural.vertex\";\r\nimport { DataBuffer } from '../../../Meshes/dataBuffer';\r\n\r\n/**\r\n * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes calmpler' images.\r\n * This is the base class of any Procedural texture and contains most of the shareable code.\r\n * @see http://doc.babylonjs.com/how_to/how_to_use_procedural_textures\r\n */\r\nexport class ProceduralTexture extends Texture {\r\n    /**\r\n     * Define if the texture is enabled or not (disabled texture will not render)\r\n     */\r\n    @serialize()\r\n    public isEnabled = true;\r\n\r\n    /**\r\n     * Define if the texture must be cleared before rendering (default is true)\r\n     */\r\n    @serialize()\r\n    public autoClear = true;\r\n\r\n    /**\r\n     * Callback called when the texture is generated\r\n     */\r\n    public onGenerated: () => void;\r\n\r\n    /**\r\n     * Event raised when the texture is generated\r\n     */\r\n    public onGeneratedObservable = new Observable<ProceduralTexture>();\r\n\r\n    /** @hidden */\r\n    @serialize()\r\n    public _generateMipMaps: boolean;\r\n\r\n    /** @hidden **/\r\n    public _effect: Effect;\r\n\r\n    /** @hidden */\r\n    public _textures: { [key: string]: Texture } = {};\r\n\r\n    @serialize()\r\n    private _size: number;\r\n    private _currentRefreshId = -1;\r\n    private _frameId = -1;\r\n    private _refreshRate = 1;\r\n    private _vertexBuffers: { [key: string]: Nullable<VertexBuffer> } = {};\r\n    private _indexBuffer: Nullable<DataBuffer>;\r\n    private _uniforms = new Array<string>();\r\n    private _samplers = new Array<string>();\r\n    private _fragment: any;\r\n\r\n    private _floats: { [key: string]: number } = {};\r\n    private _ints: { [key: string]: number } = {};\r\n    private _floatsArrays: { [key: string]: number[] } = {};\r\n    private _colors3: { [key: string]: Color3 } = {};\r\n    private _colors4: { [key: string]: Color4 } = {};\r\n    private _vectors2: { [key: string]: Vector2 } = {};\r\n    private _vectors3: { [key: string]: Vector3 } = {};\r\n    private _matrices: { [key: string]: Matrix } = {};\r\n\r\n    private _fallbackTexture: Nullable<Texture>;\r\n\r\n    private _fallbackTextureUsed = false;\r\n    private _engine: Engine;\r\n\r\n    private _cachedDefines = \"\";\r\n\r\n    private _contentUpdateId = -1;\r\n    private _contentData: Nullable<ArrayBufferView>;\r\n\r\n    /**\r\n     * Instantiates a new procedural texture.\r\n     * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes called 'refMaps' or 'sampler' images.\r\n     * This is the base class of any Procedural texture and contains most of the shareable code.\r\n     * @see http://doc.babylonjs.com/how_to/how_to_use_procedural_textures\r\n     * @param name  Define the name of the texture\r\n     * @param size Define the size of the texture to create\r\n     * @param fragment Define the fragment shader to use to generate the texture or null if it is defined later\r\n     * @param scene Define the scene the texture belongs to\r\n     * @param fallbackTexture Define a fallback texture in case there were issues to create the custom texture\r\n     * @param generateMipMaps Define if the texture should creates mip maps or not\r\n     * @param isCube Define if the texture is a cube texture or not (this will render each faces of the cube)\r\n     */\r\n    constructor(name: string, size: any, fragment: any, scene: Nullable<Scene>, fallbackTexture: Nullable<Texture> = null, generateMipMaps = true, public isCube = false) {\r\n        super(null, scene, !generateMipMaps);\r\n\r\n        scene = this.getScene()!;\r\n        let component = scene._getComponent(SceneComponentConstants.NAME_PROCEDURALTEXTURE);\r\n        if (!component) {\r\n            component = new ProceduralTextureSceneComponent(scene);\r\n            scene._addComponent(component);\r\n        }\r\n        scene.proceduralTextures.push(this);\r\n\r\n        this._engine = scene.getEngine();\r\n\r\n        this.name = name;\r\n        this.isRenderTarget = true;\r\n        this._size = size;\r\n        this._generateMipMaps = generateMipMaps;\r\n\r\n        this.setFragment(fragment);\r\n\r\n        this._fallbackTexture = fallbackTexture;\r\n\r\n        if (isCube) {\r\n            this._texture = this._engine.createRenderTargetCubeTexture(size, { generateMipMaps: generateMipMaps, generateDepthBuffer: false, generateStencilBuffer: false });\r\n            this.setFloat(\"face\", 0);\r\n        }\r\n        else {\r\n            this._texture = this._engine.createRenderTargetTexture(size, { generateMipMaps: generateMipMaps, generateDepthBuffer: false, generateStencilBuffer: false });\r\n        }\r\n\r\n        // VBO\r\n        var vertices = [];\r\n        vertices.push(1, 1);\r\n        vertices.push(-1, 1);\r\n        vertices.push(-1, -1);\r\n        vertices.push(1, -1);\r\n\r\n        this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(this._engine, vertices, VertexBuffer.PositionKind, false, false, 2);\r\n\r\n        this._createIndexBuffer();\r\n    }\r\n\r\n    /**\r\n     * The effect that is created when initializing the post process.\r\n     * @returns The created effect corresponding the the postprocess.\r\n     */\r\n    public getEffect(): Effect {\r\n        return this._effect;\r\n    }\r\n\r\n    /**\r\n     * Gets texture content (Use this function wisely as reading from a texture can be slow)\r\n     * @returns an ArrayBufferView (Uint8Array or Float32Array)\r\n     */\r\n    public getContent(): Nullable<ArrayBufferView> {\r\n        if (this._contentData && this._frameId === this._contentUpdateId) {\r\n            return this._contentData;\r\n        }\r\n\r\n        this._contentData = this.readPixels(0, 0, this._contentData);\r\n        this._contentUpdateId = this._frameId;\r\n\r\n        return this._contentData;\r\n    }\r\n\r\n    private _createIndexBuffer(): void {\r\n        var engine = this._engine;\r\n\r\n        // Indices\r\n        var indices = [];\r\n        indices.push(0);\r\n        indices.push(1);\r\n        indices.push(2);\r\n\r\n        indices.push(0);\r\n        indices.push(2);\r\n        indices.push(3);\r\n\r\n        this._indexBuffer = engine.createIndexBuffer(indices);\r\n    }\r\n\r\n    /** @hidden */\r\n    public _rebuild(): void {\r\n        let vb = this._vertexBuffers[VertexBuffer.PositionKind];\r\n\r\n        if (vb) {\r\n            vb._rebuild();\r\n        }\r\n\r\n        this._createIndexBuffer();\r\n\r\n        if (this.refreshRate === RenderTargetTexture.REFRESHRATE_RENDER_ONCE) {\r\n            this.refreshRate = RenderTargetTexture.REFRESHRATE_RENDER_ONCE;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resets the texture in order to recreate its associated resources.\r\n     * This can be called in case of context loss\r\n     */\r\n    public reset(): void {\r\n        if (this._effect === undefined) {\r\n            return;\r\n        }\r\n        this._effect.dispose();\r\n    }\r\n\r\n    protected _getDefines(): string {\r\n        return \"\";\r\n    }\r\n\r\n    /**\r\n     * Is the texture ready to be used ? (rendered at least once)\r\n     * @returns true if ready, otherwise, false.\r\n     */\r\n    public isReady(): boolean {\r\n        var engine = this._engine;\r\n        var shaders;\r\n\r\n        if (!this._fragment) {\r\n            return false;\r\n        }\r\n\r\n        if (this._fallbackTextureUsed) {\r\n            return true;\r\n        }\r\n\r\n        let defines = this._getDefines();\r\n        if (this._effect && defines === this._cachedDefines && this._effect.isReady()) {\r\n            return true;\r\n        }\r\n\r\n        if (this._fragment.fragmentElement !== undefined) {\r\n            shaders = { vertex: \"procedural\", fragmentElement: this._fragment.fragmentElement };\r\n        }\r\n        else {\r\n            shaders = { vertex: \"procedural\", fragment: this._fragment };\r\n        }\r\n\r\n        this._cachedDefines = defines;\r\n\r\n        this._effect = engine.createEffect(shaders,\r\n            [VertexBuffer.PositionKind],\r\n            this._uniforms,\r\n            this._samplers,\r\n            defines, undefined, undefined, () => {\r\n                this.releaseInternalTexture();\r\n\r\n                if (this._fallbackTexture) {\r\n                    this._texture = this._fallbackTexture._texture;\r\n\r\n                    if (this._texture) {\r\n                        this._texture.incrementReferences();\r\n                    }\r\n                }\r\n\r\n                this._fallbackTextureUsed = true;\r\n            });\r\n\r\n        return this._effect.isReady();\r\n    }\r\n\r\n    /**\r\n     * Resets the refresh counter of the texture and start bak from scratch.\r\n     * Could be useful to regenerate the texture if it is setup to render only once.\r\n     */\r\n    public resetRefreshCounter(): void {\r\n        this._currentRefreshId = -1;\r\n    }\r\n\r\n    /**\r\n     * Set the fragment shader to use in order to render the texture.\r\n     * @param fragment This can be set to a path (into the shader store) or to a json object containing a fragmentElement property.\r\n     */\r\n    public setFragment(fragment: any) {\r\n        this._fragment = fragment;\r\n    }\r\n\r\n    /**\r\n     * Define the refresh rate of the texture or the rendering frequency.\r\n     * Use 0 to render just once, 1 to render on every frame, 2 to render every two frames and so on...\r\n     */\r\n    @serialize()\r\n    public get refreshRate(): number {\r\n        return this._refreshRate;\r\n    }\r\n\r\n    public set refreshRate(value: number) {\r\n        this._refreshRate = value;\r\n        this.resetRefreshCounter();\r\n    }\r\n\r\n    /** @hidden */\r\n    public _shouldRender(): boolean {\r\n        if (!this.isEnabled || !this.isReady() || !this._texture) {\r\n            if (this._texture) {\r\n                this._texture.isReady = false;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        if (this._fallbackTextureUsed) {\r\n            return false;\r\n        }\r\n\r\n        if (this._currentRefreshId === -1) { // At least render once\r\n            this._currentRefreshId = 1;\r\n            this._frameId++;\r\n            return true;\r\n        }\r\n\r\n        if (this.refreshRate === this._currentRefreshId) {\r\n            this._currentRefreshId = 1;\r\n            this._frameId++;\r\n            return true;\r\n        }\r\n\r\n        this._currentRefreshId++;\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Get the size the texture is rendering at.\r\n     * @returns the size (texture is always squared)\r\n     */\r\n    public getRenderSize(): number {\r\n        return this._size;\r\n    }\r\n\r\n    /**\r\n     * Resize the texture to new value.\r\n     * @param size Define the new size the texture should have\r\n     * @param generateMipMaps Define whether the new texture should create mip maps\r\n     */\r\n    public resize(size: number, generateMipMaps: boolean): void {\r\n        if (this._fallbackTextureUsed) {\r\n            return;\r\n        }\r\n\r\n        this.releaseInternalTexture();\r\n        this._texture = this._engine.createRenderTargetTexture(size, generateMipMaps);\r\n\r\n        // Update properties\r\n        this._size = size;\r\n        this._generateMipMaps = generateMipMaps;\r\n    }\r\n\r\n    private _checkUniform(uniformName: string): void {\r\n        if (this._uniforms.indexOf(uniformName) === -1) {\r\n            this._uniforms.push(uniformName);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set a texture in the shader program used to render.\r\n     * @param name Define the name of the uniform samplers as defined in the shader\r\n     * @param texture Define the texture to bind to this sampler\r\n     * @return the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setTexture(name: string, texture: Texture): ProceduralTexture {\r\n        if (this._samplers.indexOf(name) === -1) {\r\n            this._samplers.push(name);\r\n        }\r\n        this._textures[name] = texture;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a float in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setFloat(name: string, value: number): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._floats[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a int in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setInt(name: string, value: number): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._ints[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set an array of floats in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setFloats(name: string, value: number[]): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._floatsArrays[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 in the shader from a Color3.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor3(name: string, value: Color3): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._colors3[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 in the shader from a Color4.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor4(name: string, value: Color4): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._colors4[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec2 in the shader from a Vector2.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector2(name: string, value: Vector2): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._vectors2[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 in the shader from a Vector3.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector3(name: string, value: Vector3): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._vectors3[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a mat4 in the shader from a MAtrix.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setMatrix(name: string, value: Matrix): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._matrices[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Render the texture to its associated render target.\r\n     * @param useCameraPostProcess Define if camera post process should be applied to the texture\r\n     */\r\n    public render(useCameraPostProcess?: boolean): void {\r\n        var scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        var engine = this._engine;\r\n\r\n        // Render\r\n        engine.enableEffect(this._effect);\r\n        engine.setState(false);\r\n\r\n        // Texture\r\n        for (var name in this._textures) {\r\n            this._effect.setTexture(name, this._textures[name]);\r\n        }\r\n\r\n        // Float\r\n        for (name in this._ints) {\r\n            this._effect.setInt(name, this._ints[name]);\r\n        }\r\n\r\n        // Float\r\n        for (name in this._floats) {\r\n            this._effect.setFloat(name, this._floats[name]);\r\n        }\r\n\r\n        // Floats\r\n        for (name in this._floatsArrays) {\r\n            this._effect.setArray(name, this._floatsArrays[name]);\r\n        }\r\n\r\n        // Color3\r\n        for (name in this._colors3) {\r\n            this._effect.setColor3(name, this._colors3[name]);\r\n        }\r\n\r\n        // Color4\r\n        for (name in this._colors4) {\r\n            var color = this._colors4[name];\r\n            this._effect.setFloat4(name, color.r, color.g, color.b, color.a);\r\n        }\r\n\r\n        // Vector2\r\n        for (name in this._vectors2) {\r\n            this._effect.setVector2(name, this._vectors2[name]);\r\n        }\r\n\r\n        // Vector3\r\n        for (name in this._vectors3) {\r\n            this._effect.setVector3(name, this._vectors3[name]);\r\n        }\r\n\r\n        // Matrix\r\n        for (name in this._matrices) {\r\n            this._effect.setMatrix(name, this._matrices[name]);\r\n        }\r\n\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n\r\n        if (this.isCube) {\r\n            for (var face = 0; face < 6; face++) {\r\n                engine.bindFramebuffer(this._texture, face, undefined, undefined, true);\r\n\r\n                // VBOs\r\n                engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._effect);\r\n\r\n                this._effect.setFloat(\"face\", face);\r\n\r\n                // Clear\r\n                if (this.autoClear) {\r\n                    engine.clear(scene.clearColor, true, false, false);\r\n                }\r\n\r\n                // Draw order\r\n                engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n\r\n                // Mipmaps\r\n                if (face === 5) {\r\n                    engine.generateMipMapsForCubemap(this._texture);\r\n                }\r\n            }\r\n        } else {\r\n            engine.bindFramebuffer(this._texture, 0, undefined, undefined, true);\r\n\r\n            // VBOs\r\n            engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._effect);\r\n\r\n            // Clear\r\n            if (this.autoClear) {\r\n                engine.clear(scene.clearColor, true, false, false);\r\n            }\r\n\r\n            // Draw order\r\n            engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n        }\r\n\r\n        // Unbind\r\n        engine.unBindFramebuffer(this._texture, this.isCube);\r\n\r\n        if (this.onGenerated) {\r\n            this.onGenerated();\r\n        }\r\n\r\n        this.onGeneratedObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Clone the texture.\r\n     * @returns the cloned texture\r\n     */\r\n    public clone(): ProceduralTexture {\r\n        var textureSize = this.getSize();\r\n        var newTexture = new ProceduralTexture(this.name, textureSize.width, this._fragment, <Scene>this.getScene(), this._fallbackTexture, this._generateMipMaps);\r\n\r\n        // Base texture\r\n        newTexture.hasAlpha = this.hasAlpha;\r\n        newTexture.level = this.level;\r\n\r\n        // RenderTarget Texture\r\n        newTexture.coordinatesMode = this.coordinatesMode;\r\n\r\n        return newTexture;\r\n    }\r\n\r\n    /**\r\n     * Dispose the texture and release its asoociated resources.\r\n     */\r\n    public dispose(): void {\r\n        let scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        var index = scene.proceduralTextures.indexOf(this);\r\n\r\n        if (index >= 0) {\r\n            scene.proceduralTextures.splice(index, 1);\r\n        }\r\n\r\n        var vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\r\n        if (vertexBuffer) {\r\n            vertexBuffer.dispose();\r\n            this._vertexBuffers[VertexBuffer.PositionKind] = null;\r\n        }\r\n\r\n        if (this._indexBuffer && this._engine._releaseBuffer(this._indexBuffer)) {\r\n            this._indexBuffer = null;\r\n        }\r\n\r\n        super.dispose();\r\n    }\r\n}\r\n"]}