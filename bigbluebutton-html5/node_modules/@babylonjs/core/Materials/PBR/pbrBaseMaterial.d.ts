import { Nullable } from "../../types";
import { Scene } from "../../scene";
import { Matrix } from "../../Maths/math.vector";
import { SubMesh } from "../../Meshes/subMesh";
import { AbstractMesh } from "../../Meshes/abstractMesh";
import { Mesh } from "../../Meshes/mesh";
import { IMaterialClearCoatDefines, PBRClearCoatConfiguration } from "./pbrClearCoatConfiguration";
import { IMaterialAnisotropicDefines, PBRAnisotropicConfiguration } from "./pbrAnisotropicConfiguration";
import { IMaterialBRDFDefines, PBRBRDFConfiguration } from "./pbrBRDFConfiguration";
import { IMaterialSheenDefines, PBRSheenConfiguration } from "./pbrSheenConfiguration";
import { IMaterialSubSurfaceDefines, PBRSubSurfaceConfiguration } from "./pbrSubSurfaceConfiguration";
import { Color3 } from '../../Maths/math.color';
import { ImageProcessingConfiguration, IImageProcessingConfigurationDefines } from "../../Materials/imageProcessingConfiguration";
import { Material, IMaterialCompilationOptions } from "../../Materials/material";
import { MaterialDefines } from "../../Materials/materialDefines";
import { PushMaterial } from "../../Materials/pushMaterial";
import { BaseTexture } from "../../Materials/Textures/baseTexture";
import { IAnimatable } from '../../Animations/animatable.interface';
import "../../Materials/Textures/baseTexture.polynomial";
import "../../Shaders/pbr.fragment";
import "../../Shaders/pbr.vertex";
/**
 * Manages the defines for the PBR Material.
 * @hidden
 */
export declare class PBRMaterialDefines extends MaterialDefines implements IImageProcessingConfigurationDefines, IMaterialClearCoatDefines, IMaterialAnisotropicDefines, IMaterialBRDFDefines, IMaterialSheenDefines, IMaterialSubSurfaceDefines {
    PBR: boolean;
    MAINUV1: boolean;
    MAINUV2: boolean;
    UV1: boolean;
    UV2: boolean;
    ALBEDO: boolean;
    GAMMAALBEDO: boolean;
    ALBEDODIRECTUV: number;
    VERTEXCOLOR: boolean;
    AMBIENT: boolean;
    AMBIENTDIRECTUV: number;
    AMBIENTINGRAYSCALE: boolean;
    OPACITY: boolean;
    VERTEXALPHA: boolean;
    OPACITYDIRECTUV: number;
    OPACITYRGB: boolean;
    ALPHATEST: boolean;
    DEPTHPREPASS: boolean;
    ALPHABLEND: boolean;
    ALPHAFROMALBEDO: boolean;
    ALPHATESTVALUE: string;
    SPECULAROVERALPHA: boolean;
    RADIANCEOVERALPHA: boolean;
    ALPHAFRESNEL: boolean;
    LINEARALPHAFRESNEL: boolean;
    PREMULTIPLYALPHA: boolean;
    EMISSIVE: boolean;
    EMISSIVEDIRECTUV: number;
    REFLECTIVITY: boolean;
    REFLECTIVITYDIRECTUV: number;
    SPECULARTERM: boolean;
    MICROSURFACEFROMREFLECTIVITYMAP: boolean;
    MICROSURFACEAUTOMATIC: boolean;
    LODBASEDMICROSFURACE: boolean;
    MICROSURFACEMAP: boolean;
    MICROSURFACEMAPDIRECTUV: number;
    METALLICWORKFLOW: boolean;
    ROUGHNESSSTOREINMETALMAPALPHA: boolean;
    ROUGHNESSSTOREINMETALMAPGREEN: boolean;
    METALLNESSSTOREINMETALMAPBLUE: boolean;
    AOSTOREINMETALMAPRED: boolean;
    METALLICF0FACTORFROMMETALLICMAP: boolean;
    ENVIRONMENTBRDF: boolean;
    ENVIRONMENTBRDF_RGBD: boolean;
    NORMAL: boolean;
    TANGENT: boolean;
    BUMP: boolean;
    BUMPDIRECTUV: number;
    OBJECTSPACE_NORMALMAP: boolean;
    PARALLAX: boolean;
    PARALLAXOCCLUSION: boolean;
    NORMALXYSCALE: boolean;
    LIGHTMAP: boolean;
    LIGHTMAPDIRECTUV: number;
    USELIGHTMAPASSHADOWMAP: boolean;
    GAMMALIGHTMAP: boolean;
    RGBDLIGHTMAP: boolean;
    REFLECTION: boolean;
    REFLECTIONMAP_3D: boolean;
    REFLECTIONMAP_SPHERICAL: boolean;
    REFLECTIONMAP_PLANAR: boolean;
    REFLECTIONMAP_CUBIC: boolean;
    USE_LOCAL_REFLECTIONMAP_CUBIC: boolean;
    REFLECTIONMAP_PROJECTION: boolean;
    REFLECTIONMAP_SKYBOX: boolean;
    REFLECTIONMAP_EXPLICIT: boolean;
    REFLECTIONMAP_EQUIRECTANGULAR: boolean;
    REFLECTIONMAP_EQUIRECTANGULAR_FIXED: boolean;
    REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED: boolean;
    INVERTCUBICMAP: boolean;
    USESPHERICALFROMREFLECTIONMAP: boolean;
    USEIRRADIANCEMAP: boolean;
    SPHERICAL_HARMONICS: boolean;
    USESPHERICALINVERTEX: boolean;
    REFLECTIONMAP_OPPOSITEZ: boolean;
    LODINREFLECTIONALPHA: boolean;
    GAMMAREFLECTION: boolean;
    RGBDREFLECTION: boolean;
    LINEARSPECULARREFLECTION: boolean;
    RADIANCEOCCLUSION: boolean;
    HORIZONOCCLUSION: boolean;
    INSTANCES: boolean;
    NUM_BONE_INFLUENCERS: number;
    BonesPerMesh: number;
    BONETEXTURE: boolean;
    NONUNIFORMSCALING: boolean;
    MORPHTARGETS: boolean;
    MORPHTARGETS_NORMAL: boolean;
    MORPHTARGETS_TANGENT: boolean;
    MORPHTARGETS_UV: boolean;
    NUM_MORPH_INFLUENCERS: number;
    IMAGEPROCESSING: boolean;
    VIGNETTE: boolean;
    VIGNETTEBLENDMODEMULTIPLY: boolean;
    VIGNETTEBLENDMODEOPAQUE: boolean;
    TONEMAPPING: boolean;
    TONEMAPPING_ACES: boolean;
    CONTRAST: boolean;
    COLORCURVES: boolean;
    COLORGRADING: boolean;
    COLORGRADING3D: boolean;
    SAMPLER3DGREENDEPTH: boolean;
    SAMPLER3DBGRMAP: boolean;
    IMAGEPROCESSINGPOSTPROCESS: boolean;
    EXPOSURE: boolean;
    MULTIVIEW: boolean;
    USEPHYSICALLIGHTFALLOFF: boolean;
    USEGLTFLIGHTFALLOFF: boolean;
    TWOSIDEDLIGHTING: boolean;
    SHADOWFLOAT: boolean;
    CLIPPLANE: boolean;
    CLIPPLANE2: boolean;
    CLIPPLANE3: boolean;
    CLIPPLANE4: boolean;
    CLIPPLANE5: boolean;
    CLIPPLANE6: boolean;
    POINTSIZE: boolean;
    FOG: boolean;
    LOGARITHMICDEPTH: boolean;
    FORCENORMALFORWARD: boolean;
    SPECULARAA: boolean;
    CLEARCOAT: boolean;
    CLEARCOAT_DEFAULTIOR: boolean;
    CLEARCOAT_TEXTURE: boolean;
    CLEARCOAT_TEXTUREDIRECTUV: number;
    CLEARCOAT_BUMP: boolean;
    CLEARCOAT_BUMPDIRECTUV: number;
    CLEARCOAT_TINT: boolean;
    CLEARCOAT_TINT_TEXTURE: boolean;
    CLEARCOAT_TINT_TEXTUREDIRECTUV: number;
    ANISOTROPIC: boolean;
    ANISOTROPIC_TEXTURE: boolean;
    ANISOTROPIC_TEXTUREDIRECTUV: number;
    BRDF_V_HEIGHT_CORRELATED: boolean;
    MS_BRDF_ENERGY_CONSERVATION: boolean;
    SPECULAR_GLOSSINESS_ENERGY_CONSERVATION: boolean;
    SHEEN: boolean;
    SHEEN_TEXTURE: boolean;
    SHEEN_TEXTUREDIRECTUV: number;
    SHEEN_LINKWITHALBEDO: boolean;
    SUBSURFACE: boolean;
    SS_REFRACTION: boolean;
    SS_TRANSLUCENCY: boolean;
    SS_SCATERRING: boolean;
    SS_THICKNESSANDMASK_TEXTURE: boolean;
    SS_THICKNESSANDMASK_TEXTUREDIRECTUV: number;
    SS_REFRACTIONMAP_3D: boolean;
    SS_REFRACTIONMAP_OPPOSITEZ: boolean;
    SS_LODINREFRACTIONALPHA: boolean;
    SS_GAMMAREFRACTION: boolean;
    SS_RGBDREFRACTION: boolean;
    SS_LINEARSPECULARREFRACTION: boolean;
    SS_LINKREFRACTIONTOTRANSPARENCY: boolean;
    SS_MASK_FROM_THICKNESS_TEXTURE: boolean;
    UNLIT: boolean;
    DEBUGMODE: number;
    /**
     * Initializes the PBR Material defines.
     */
    constructor();
    /**
     * Resets the PBR Material defines.
     */
    reset(): void;
}
/**
 * The Physically based material base class of BJS.
 *
 * This offers the main features of a standard PBR material.
 * For more information, please refer to the documentation :
 * https://doc.babylonjs.com/how_to/physically_based_rendering
 */
export declare abstract class PBRBaseMaterial extends PushMaterial {
    /**
     * PBRMaterialTransparencyMode: No transparency mode, Alpha channel is not use.
     */
    static readonly PBRMATERIAL_OPAQUE = 0;
    /**
     * PBRMaterialTransparencyMode: Alpha Test mode, pixel are discarded below a certain threshold defined by the alpha cutoff value.
     */
    static readonly PBRMATERIAL_ALPHATEST = 1;
    /**
     * PBRMaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.
     */
    static readonly PBRMATERIAL_ALPHABLEND = 2;
    /**
     * PBRMaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.
     * They are also discarded below the alpha cutoff threshold to improve performances.
     */
    static readonly PBRMATERIAL_ALPHATESTANDBLEND = 3;
    /**
     * Defines the default value of how much AO map is occluding the analytical lights
     * (point spot...).
     */
    static DEFAULT_AO_ON_ANALYTICAL_LIGHTS: number;
    /**
     * PBRMaterialLightFalloff Physical: light is falling off following the inverse squared distance law.
     */
    static readonly LIGHTFALLOFF_PHYSICAL = 0;
    /**
     * PBRMaterialLightFalloff gltf: light is falling off as described in the gltf moving to PBR document
     * to enhance interoperability with other engines.
     */
    static readonly LIGHTFALLOFF_GLTF = 1;
    /**
     * PBRMaterialLightFalloff Standard: light is falling off like in the standard material
     * to enhance interoperability with other materials.
     */
    static readonly LIGHTFALLOFF_STANDARD = 2;
    /**
     * Intensity of the direct lights e.g. the four lights available in your scene.
     * This impacts both the direct diffuse and specular highlights.
     */
    protected _directIntensity: number;
    /**
     * Intensity of the emissive part of the material.
     * This helps controlling the emissive effect without modifying the emissive color.
     */
    protected _emissiveIntensity: number;
    /**
     * Intensity of the environment e.g. how much the environment will light the object
     * either through harmonics for rough material or through the refelction for shiny ones.
     */
    protected _environmentIntensity: number;
    /**
     * This is a special control allowing the reduction of the specular highlights coming from the
     * four lights of the scene. Those highlights may not be needed in full environment lighting.
     */
    protected _specularIntensity: number;
    /**
     * This stores the direct, emissive, environment, and specular light intensities into a Vector4.
     */
    private _lightingInfos;
    /**
     * Debug Control allowing disabling the bump map on this material.
     */
    protected _disableBumpMap: boolean;
    /**
     * AKA Diffuse Texture in standard nomenclature.
     */
    protected _albedoTexture: Nullable<BaseTexture>;
    /**
     * AKA Occlusion Texture in other nomenclature.
     */
    protected _ambientTexture: Nullable<BaseTexture>;
    /**
     * AKA Occlusion Texture Intensity in other nomenclature.
     */
    protected _ambientTextureStrength: number;
    /**
     * Defines how much the AO map is occluding the analytical lights (point spot...).
     * 1 means it completely occludes it
     * 0 mean it has no impact
     */
    protected _ambientTextureImpactOnAnalyticalLights: number;
    /**
     * Stores the alpha values in a texture.
     */
    protected _opacityTexture: Nullable<BaseTexture>;
    /**
     * Stores the reflection values in a texture.
     */
    protected _reflectionTexture: Nullable<BaseTexture>;
    /**
     * Stores the emissive values in a texture.
     */
    protected _emissiveTexture: Nullable<BaseTexture>;
    /**
     * AKA Specular texture in other nomenclature.
     */
    protected _reflectivityTexture: Nullable<BaseTexture>;
    /**
     * Used to switch from specular/glossiness to metallic/roughness workflow.
     */
    protected _metallicTexture: Nullable<BaseTexture>;
    /**
     * Specifies the metallic scalar of the metallic/roughness workflow.
     * Can also be used to scale the metalness values of the metallic texture.
     */
    protected _metallic: Nullable<number>;
    /**
     * Specifies the roughness scalar of the metallic/roughness workflow.
     * Can also be used to scale the roughness values of the metallic texture.
     */
    protected _roughness: Nullable<number>;
    /**
     * Specifies the an F0 factor to help configuring the material F0.
     * Instead of the default 4%, 8% * factor will be used. As the factor is defaulting
     * to 0.5 the previously hard coded value stays the same.
     * Can also be used to scale the F0 values of the metallic texture.
     */
    protected _metallicF0Factor: number;
    /**
     * Specifies whether the F0 factor can be fetched from the mettalic texture.
     * If set to true, please adapt the metallicF0Factor to ensure it fits with
     * your expectation as it multiplies with the texture data.
     */
    protected _useMetallicF0FactorFromMetallicTexture: boolean;
    /**
     * Used to enable roughness/glossiness fetch from a separate channel depending on the current mode.
     * Gray Scale represents roughness in metallic mode and glossiness in specular mode.
     */
    protected _microSurfaceTexture: Nullable<BaseTexture>;
    /**
     * Stores surface normal data used to displace a mesh in a texture.
     */
    protected _bumpTexture: Nullable<BaseTexture>;
    /**
     * Stores the pre-calculated light information of a mesh in a texture.
     */
    protected _lightmapTexture: Nullable<BaseTexture>;
    /**
     * The color of a material in ambient lighting.
     */
    protected _ambientColor: Color3;
    /**
     * AKA Diffuse Color in other nomenclature.
     */
    protected _albedoColor: Color3;
    /**
     * AKA Specular Color in other nomenclature.
     */
    protected _reflectivityColor: Color3;
    /**
     * The color applied when light is reflected from a material.
     */
    protected _reflectionColor: Color3;
    /**
     * The color applied when light is emitted from a material.
     */
    protected _emissiveColor: Color3;
    /**
     * AKA Glossiness in other nomenclature.
     */
    protected _microSurface: number;
    /**
     * Specifies that the material will use the light map as a show map.
     */
    protected _useLightmapAsShadowmap: boolean;
    /**
     * This parameters will enable/disable Horizon occlusion to prevent normal maps to look shiny when the normal
     * makes the reflect vector face the model (under horizon).
     */
    protected _useHorizonOcclusion: boolean;
    /**
     * This parameters will enable/disable radiance occlusion by preventing the radiance to lit
     * too much the area relying on ambient texture to define their ambient occlusion.
     */
    protected _useRadianceOcclusion: boolean;
    /**
     * Specifies that the alpha is coming form the albedo channel alpha channel for alpha blending.
     */
    protected _useAlphaFromAlbedoTexture: boolean;
    /**
     * Specifies that the material will keeps the specular highlights over a transparent surface (only the most limunous ones).
     * A car glass is a good exemple of that. When sun reflects on it you can not see what is behind.
     */
    protected _useSpecularOverAlpha: boolean;
    /**
     * Specifies if the reflectivity texture contains the glossiness information in its alpha channel.
     */
    protected _useMicroSurfaceFromReflectivityMapAlpha: boolean;
    /**
     * Specifies if the metallic texture contains the roughness information in its alpha channel.
     */
    protected _useRoughnessFromMetallicTextureAlpha: boolean;
    /**
     * Specifies if the metallic texture contains the roughness information in its green channel.
     */
    protected _useRoughnessFromMetallicTextureGreen: boolean;
    /**
     * Specifies if the metallic texture contains the metallness information in its blue channel.
     */
    protected _useMetallnessFromMetallicTextureBlue: boolean;
    /**
     * Specifies if the metallic texture contains the ambient occlusion information in its red channel.
     */
    protected _useAmbientOcclusionFromMetallicTextureRed: boolean;
    /**
     * Specifies if the ambient texture contains the ambient occlusion information in its red channel only.
     */
    protected _useAmbientInGrayScale: boolean;
    /**
     * In case the reflectivity map does not contain the microsurface information in its alpha channel,
     * The material will try to infer what glossiness each pixel should be.
     */
    protected _useAutoMicroSurfaceFromReflectivityMap: boolean;
    /**
     * Defines the  falloff type used in this material.
     * It by default is Physical.
     */
    protected _lightFalloff: number;
    /**
     * Specifies that the material will keeps the reflection highlights over a transparent surface (only the most limunous ones).
     * A car glass is a good exemple of that. When the street lights reflects on it you can not see what is behind.
     */
    protected _useRadianceOverAlpha: boolean;
    /**
     * Allows using an object space normal map (instead of tangent space).
     */
    protected _useObjectSpaceNormalMap: boolean;
    /**
     * Allows using the bump map in parallax mode.
     */
    protected _useParallax: boolean;
    /**
     * Allows using the bump map in parallax occlusion mode.
     */
    protected _useParallaxOcclusion: boolean;
    /**
     * Controls the scale bias of the parallax mode.
     */
    protected _parallaxScaleBias: number;
    /**
     * If sets to true, disables all the lights affecting the material.
     */
    protected _disableLighting: boolean;
    /**
     * Number of Simultaneous lights allowed on the material.
     */
    protected _maxSimultaneousLights: number;
    /**
     * If sets to true, x component of normal map value will be inverted (x = 1.0 - x).
     */
    protected _invertNormalMapX: boolean;
    /**
     * If sets to true, y component of normal map value will be inverted (y = 1.0 - y).
     */
    protected _invertNormalMapY: boolean;
    /**
     * If sets to true and backfaceCulling is false, normals will be flipped on the backside.
     */
    protected _twoSidedLighting: boolean;
    /**
     * Defines the alpha limits in alpha test mode.
     */
    protected _alphaCutOff: number;
    /**
     * Enforces alpha test in opaque or blend mode in order to improve the performances of some situations.
     */
    protected _forceAlphaTest: boolean;
    /**
     * A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.
     * And/Or occlude the blended part. (alpha is converted to gamma to compute the fresnel)
     */
    protected _useAlphaFresnel: boolean;
    /**
     * A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.
     * And/Or occlude the blended part. (alpha stays linear to compute the fresnel)
     */
    protected _useLinearAlphaFresnel: boolean;
    /**
     * The transparency mode of the material.
     */
    protected _transparencyMode: Nullable<number>;
    /**
     * Specifies the environment BRDF texture used to comput the scale and offset roughness values
     * from cos thetav and roughness:
     * http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf
     */
    protected _environmentBRDFTexture: Nullable<BaseTexture>;
    /**
     * Force the shader to compute irradiance in the fragment shader in order to take bump in account.
     */
    protected _forceIrradianceInFragment: boolean;
    /**
     * Force normal to face away from face.
     */
    protected _forceNormalForward: boolean;
    /**
     * Enables specular anti aliasing in the PBR shader.
     * It will both interacts on the Geometry for analytical and IBL lighting.
     * It also prefilter the roughness map based on the bump values.
     */
    protected _enableSpecularAntiAliasing: boolean;
    /**
     * Default configuration related to image processing available in the PBR Material.
     */
    protected _imageProcessingConfiguration: ImageProcessingConfiguration;
    /**
     * Keep track of the image processing observer to allow dispose and replace.
     */
    private _imageProcessingObserver;
    /**
     * Attaches a new image processing configuration to the PBR Material.
     * @param configuration
     */
    protected _attachImageProcessingConfiguration(configuration: Nullable<ImageProcessingConfiguration>): void;
    /**
     * Stores the available render targets.
     */
    private _renderTargets;
    /**
     * Sets the global ambient color for the material used in lighting calculations.
     */
    private _globalAmbientColor;
    /**
     * Enables the use of logarithmic depth buffers, which is good for wide depth buffers.
     */
    private _useLogarithmicDepth;
    /**
     * If set to true, no lighting calculations will be applied.
     */
    private _unlit;
    private _debugMode;
    /**
     * @hidden
     * This is reserved for the inspector.
     * Defines the material debug mode.
     * It helps seeing only some components of the material while troubleshooting.
     */
    debugMode: number;
    /**
     * @hidden
     * This is reserved for the inspector.
     * Specify from where on screen the debug mode should start.
     * The value goes from -1 (full screen) to 1 (not visible)
     * It helps with side by side comparison against the final render
     * This defaults to -1
     */
    private debugLimit;
    /**
     * @hidden
     * This is reserved for the inspector.
     * As the default viewing range might not be enough (if the ambient is really small for instance)
     * You can use the factor to better multiply the final value.
     */
    private debugFactor;
    /**
     * Defines the clear coat layer parameters for the material.
     */
    readonly clearCoat: PBRClearCoatConfiguration;
    /**
     * Defines the anisotropic parameters for the material.
     */
    readonly anisotropy: PBRAnisotropicConfiguration;
    /**
     * Defines the BRDF parameters for the material.
     */
    readonly brdf: PBRBRDFConfiguration;
    /**
     * Defines the Sheen parameters for the material.
     */
    readonly sheen: PBRSheenConfiguration;
    /**
     * Defines the SubSurface parameters for the material.
     */
    readonly subSurface: PBRSubSurfaceConfiguration;
    /**
     * Custom callback helping to override the default shader used in the material.
     */
    customShaderNameResolve: (shaderName: string, uniforms: string[], uniformBuffers: string[], samplers: string[], defines: PBRMaterialDefines) => string;
    protected _rebuildInParallel: boolean;
    /**
     * Instantiates a new PBRMaterial instance.
     *
     * @param name The material name
     * @param scene The scene the material will be use in.
     */
    constructor(name: string, scene: Scene);
    /**
     * Gets a boolean indicating that current material needs to register RTT
     */
    get hasRenderTargetTextures(): boolean;
    /**
     * Gets the name of the material class.
     */
    getClassName(): string;
    /**
     * Enabled the use of logarithmic depth buffers, which is good for wide depth buffers.
     */
    get useLogarithmicDepth(): boolean;
    /**
     * Enabled the use of logarithmic depth buffers, which is good for wide depth buffers.
     */
    set useLogarithmicDepth(value: boolean);
    /**
     * Gets the current transparency mode.
     */
    get transparencyMode(): Nullable<number>;
    /**
     * Sets the transparency mode of the material.
     *
     * | Value | Type                                | Description |
     * | ----- | ----------------------------------- | ----------- |
     * | 0     | OPAQUE                              |             |
     * | 1     | ALPHATEST                           |             |
     * | 2     | ALPHABLEND                          |             |
     * | 3     | ALPHATESTANDBLEND                   |             |
     *
     */
    set transparencyMode(value: Nullable<number>);
    /**
     * Returns true if alpha blending should be disabled.
     */
    private get _disableAlphaBlending();
    /**
     * Specifies whether or not this material should be rendered in alpha blend mode.
     */
    needAlphaBlending(): boolean;
    /**
     * Specifies if the mesh will require alpha blending.
     * @param mesh - BJS mesh.
     */
    needAlphaBlendingForMesh(mesh: AbstractMesh): boolean;
    /**
     * Specifies whether or not this material should be rendered in alpha test mode.
     */
    needAlphaTesting(): boolean;
    /**
     * Specifies whether or not the alpha value of the albedo texture should be used for alpha blending.
     */
    protected _shouldUseAlphaFromAlbedoTexture(): boolean;
    /**
     * Gets the texture used for the alpha test.
     */
    getAlphaTestTexture(): Nullable<BaseTexture>;
    /**
     * Specifies that the submesh is ready to be used.
     * @param mesh - BJS mesh.
     * @param subMesh - A submesh of the BJS mesh.  Used to check if it is ready.
     * @param useInstances - Specifies that instances should be used.
     * @returns - boolean indicating that the submesh is ready or not.
     */
    isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean;
    /**
     * Specifies if the material uses metallic roughness workflow.
     * @returns boolean specifiying if the material uses metallic roughness workflow.
    */
    isMetallicWorkflow(): boolean;
    private _prepareEffect;
    private _prepareDefines;
    /**
     * Force shader compilation
     */
    forceCompilation(mesh: AbstractMesh, onCompiled?: (material: Material) => void, options?: Partial<IMaterialCompilationOptions>): void;
    /**
     * Initializes the uniform buffer layout for the shader.
     */
    buildUniformLayout(): void;
    /**
     * Unbinds the material from the mesh
     */
    unbind(): void;
    /**
     * Binds the submesh data.
     * @param world - The world matrix.
     * @param mesh - The BJS mesh.
     * @param subMesh - A submesh of the BJS mesh.
     */
    bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void;
    /**
     * Returns the animatable textures.
     * @returns - Array of animatable textures.
     */
    getAnimatables(): IAnimatable[];
    /**
     * Returns the texture used for reflections.
     * @returns - Reflection texture if present.  Otherwise, returns the environment texture.
     */
    private _getReflectionTexture;
    /**
     * Returns an array of the actively used textures.
     * @returns - Array of BaseTextures
     */
    getActiveTextures(): BaseTexture[];
    /**
     * Checks to see if a texture is used in the material.
     * @param texture - Base texture to use.
     * @returns - Boolean specifying if a texture is used in the material.
     */
    hasTexture(texture: BaseTexture): boolean;
    /**
     * Disposes the resources of the material.
     * @param forceDisposeEffect - Forces the disposal of effects.
     * @param forceDisposeTextures - Forces the disposal of all textures.
     */
    dispose(forceDisposeEffect?: boolean, forceDisposeTextures?: boolean): void;
}
