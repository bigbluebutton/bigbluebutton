{"version":3,"file":"IPhysicsEngine.js","sourceRoot":"","sources":["../../../sourceES6/core/Physics/IPhysicsEngine.ts"],"names":[],"mappings":"","sourcesContent":["import { Nullable } from \"../types\";\r\nimport { Vector3, Quaternion } from \"../Maths/math.vector\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { PhysicsImpostor, IPhysicsEnabledObject } from \"./physicsImpostor\";\r\nimport { PhysicsJoint, IMotorEnabledJoint } from \"./physicsJoint\";\r\nimport { PhysicsRaycastResult } from \"./physicsRaycastResult\";\r\n\r\n/**\r\n * Interface used to describe a physics joint\r\n */\r\nexport interface PhysicsImpostorJoint {\r\n    /** Defines the main impostor to which the joint is linked */\r\n    mainImpostor: PhysicsImpostor;\r\n    /** Defines the impostor that is connected to the main impostor using this joint */\r\n    connectedImpostor: PhysicsImpostor;\r\n    /** Defines the joint itself */\r\n    joint: PhysicsJoint;\r\n}\r\n\r\n/** @hidden */\r\nexport interface IPhysicsEnginePlugin {\r\n    world: any;\r\n    name: string;\r\n    setGravity(gravity: Vector3): void;\r\n    setTimeStep(timeStep: number): void;\r\n    getTimeStep(): number;\r\n    executeStep(delta: number, impostors: Array<PhysicsImpostor>): void; //not forgetting pre and post events\r\n    applyImpulse(impostor: PhysicsImpostor, force: Vector3, contactPoint: Vector3): void;\r\n    applyForce(impostor: PhysicsImpostor, force: Vector3, contactPoint: Vector3): void;\r\n    generatePhysicsBody(impostor: PhysicsImpostor): void;\r\n    removePhysicsBody(impostor: PhysicsImpostor): void;\r\n    generateJoint(joint: PhysicsImpostorJoint): void;\r\n    removeJoint(joint: PhysicsImpostorJoint): void;\r\n    isSupported(): boolean;\r\n    setTransformationFromPhysicsBody(impostor: PhysicsImpostor): void;\r\n    setPhysicsBodyTransformation(impostor: PhysicsImpostor, newPosition: Vector3, newRotation: Quaternion): void;\r\n    setLinearVelocity(impostor: PhysicsImpostor, velocity: Nullable<Vector3>): void;\r\n    setAngularVelocity(impostor: PhysicsImpostor, velocity: Nullable<Vector3>): void;\r\n    getLinearVelocity(impostor: PhysicsImpostor): Nullable<Vector3>;\r\n    getAngularVelocity(impostor: PhysicsImpostor): Nullable<Vector3>;\r\n    setBodyMass(impostor: PhysicsImpostor, mass: number): void;\r\n    getBodyMass(impostor: PhysicsImpostor): number;\r\n    getBodyFriction(impostor: PhysicsImpostor): number;\r\n    setBodyFriction(impostor: PhysicsImpostor, friction: number): void;\r\n    getBodyRestitution(impostor: PhysicsImpostor): number;\r\n    setBodyRestitution(impostor: PhysicsImpostor, restitution: number): void;\r\n    getBodyPressure?(impostor: PhysicsImpostor): number;\r\n    setBodyPressure?(impostor: PhysicsImpostor, pressure: number): void;\r\n    getBodyStiffness?(impostor: PhysicsImpostor): number;\r\n    setBodyStiffness?(impostor: PhysicsImpostor, stiffness: number): void;\r\n    getBodyVelocityIterations?(impostor: PhysicsImpostor): number;\r\n    setBodyVelocityIterations?(impostor: PhysicsImpostor, velocityIterations: number): void;\r\n    getBodyPositionIterations?(impostor: PhysicsImpostor): number;\r\n    setBodyPositionIterations?(impostor: PhysicsImpostor, positionIterations: number): void;\r\n    appendAnchor?(impostor: PhysicsImpostor, otherImpostor: PhysicsImpostor, width: number, height: number, influence: number, noCollisionBetweenLinkedBodies: boolean): void;\r\n    appendHook?(impostor: PhysicsImpostor, otherImpostor: PhysicsImpostor, length: number, influence: number, noCollisionBetweenLinkedBodies: boolean): void;\r\n    sleepBody(impostor: PhysicsImpostor): void;\r\n    wakeUpBody(impostor: PhysicsImpostor): void;\r\n    raycast(from: Vector3, to: Vector3): PhysicsRaycastResult;\r\n    //Joint Update\r\n    updateDistanceJoint(joint: PhysicsJoint, maxDistance: number, minDistance?: number): void;\r\n    setMotor(joint: IMotorEnabledJoint, speed: number, maxForce?: number, motorIndex?: number): void;\r\n    setLimit(joint: IMotorEnabledJoint, upperLimit: number, lowerLimit?: number, motorIndex?: number): void;\r\n    getRadius(impostor: PhysicsImpostor): number;\r\n    getBoxSizeToRef(impostor: PhysicsImpostor, result: Vector3): void;\r\n    syncMeshWithImpostor(mesh: AbstractMesh, impostor: PhysicsImpostor): void;\r\n    dispose(): void;\r\n}\r\n\r\n/**\r\n * Interface used to define a physics engine\r\n * @see http://doc.babylonjs.com/how_to/using_the_physics_engine\r\n */\r\nexport interface IPhysicsEngine {\r\n    /**\r\n     * Gets the gravity vector used by the simulation\r\n     */\r\n    gravity: Vector3;\r\n\r\n    /**\r\n     * Sets the gravity vector used by the simulation\r\n     * @param gravity defines the gravity vector to use\r\n     */\r\n    setGravity(gravity: Vector3): void;\r\n\r\n    /**\r\n     * Set the time step of the physics engine.\r\n     * Default is 1/60.\r\n     * To slow it down, enter 1/600 for example.\r\n     * To speed it up, 1/30\r\n     * @param newTimeStep the new timestep to apply to this world.\r\n     */\r\n    setTimeStep(newTimeStep: number): void;\r\n\r\n    /**\r\n     * Get the time step of the physics engine.\r\n     * @returns the current time step\r\n     */\r\n    getTimeStep(): number;\r\n\r\n    /**\r\n     * Set the sub time step of the physics engine.\r\n     * Default is 0 meaning there is no sub steps\r\n     * To increase physics resolution precision, set a small value (like 1 ms)\r\n     * @param subTimeStep defines the new sub timestep used for physics resolution.\r\n     */\r\n    setSubTimeStep(subTimeStep: number) : void;\r\n\r\n    /**\r\n     * Get the sub time step of the physics engine.\r\n     * @returns the current sub time step\r\n     */\r\n    getSubTimeStep(): number;\r\n\r\n    /**\r\n     * Release all resources\r\n     */\r\n    dispose(): void;\r\n\r\n    /**\r\n     * Gets the name of the current physics plugin\r\n     * @returns the name of the plugin\r\n     */\r\n    getPhysicsPluginName(): string;\r\n\r\n    /**\r\n     * Adding a new impostor for the impostor tracking.\r\n     * This will be done by the impostor itself.\r\n     * @param impostor the impostor to add\r\n     */\r\n    addImpostor(impostor: PhysicsImpostor): void;\r\n\r\n    /**\r\n     * Remove an impostor from the engine.\r\n     * This impostor and its mesh will not longer be updated by the physics engine.\r\n     * @param impostor the impostor to remove\r\n     */\r\n    removeImpostor(impostor: PhysicsImpostor): void;\r\n\r\n    /**\r\n     * Add a joint to the physics engine\r\n     * @param mainImpostor defines the main impostor to which the joint is added.\r\n     * @param connectedImpostor defines the impostor that is connected to the main impostor using this joint\r\n     * @param joint defines the joint that will connect both impostors.\r\n     */\r\n    addJoint(mainImpostor: PhysicsImpostor, connectedImpostor: PhysicsImpostor, joint: PhysicsJoint): void;\r\n\r\n    /**\r\n     * Removes a joint from the simulation\r\n     * @param mainImpostor defines the impostor used with the joint\r\n     * @param connectedImpostor defines the other impostor connected to the main one by the joint\r\n     * @param joint defines the joint to remove\r\n     */\r\n    removeJoint(mainImpostor: PhysicsImpostor, connectedImpostor: PhysicsImpostor, joint: PhysicsJoint): void;\r\n\r\n    /**\r\n     * Gets the current plugin used to run the simulation\r\n     * @returns current plugin\r\n     */\r\n    getPhysicsPlugin(): IPhysicsEnginePlugin;\r\n\r\n    /**\r\n     * Gets the list of physic impostors\r\n     * @returns an array of PhysicsImpostor\r\n     */\r\n    getImpostors(): Array<PhysicsImpostor>;\r\n\r\n    /**\r\n     * Gets the impostor for a physics enabled object\r\n     * @param object defines the object impersonated by the impostor\r\n     * @returns the PhysicsImpostor or null if not found\r\n     */\r\n    getImpostorForPhysicsObject(object: IPhysicsEnabledObject): Nullable<PhysicsImpostor>;\r\n\r\n    /**\r\n     * Gets the impostor for a physics body object\r\n     * @param body defines physics body used by the impostor\r\n     * @returns the PhysicsImpostor or null if not found\r\n     */\r\n    getImpostorWithPhysicsBody(body: any): Nullable<PhysicsImpostor>;\r\n\r\n    /**\r\n     * Does a raycast in the physics world\r\n     * @param from when should the ray start?\r\n     * @param to when should the ray end?\r\n     * @returns PhysicsRaycastResult\r\n     */\r\n    raycast(from: Vector3, to: Vector3): PhysicsRaycastResult;\r\n\r\n    /**\r\n     * Called by the scene. No need to call it.\r\n     * @param delta defines the timespam between frames\r\n     */\r\n    _step(delta: number): void;\r\n}\r\n"]}