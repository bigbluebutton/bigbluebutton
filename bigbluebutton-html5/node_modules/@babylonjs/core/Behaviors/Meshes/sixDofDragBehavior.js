import { AbstractMesh } from "../../Meshes/abstractMesh";
import { Scene } from "../../scene";
import { PointerEventTypes } from "../../Events/pointerEvents";
import { Vector3, Quaternion, Matrix } from "../../Maths/math.vector";
import { Observable } from "../../Misc/observable";
import { Camera } from "../../Cameras/camera";
import { PivotTools } from "../../Misc/pivotTools";
/**
 * A behavior that when attached to a mesh will allow the mesh to be dragged around based on directions and origin of the pointer's ray
 */
var SixDofDragBehavior = /** @class */ (function () {
    /**
     * Instantiates a behavior that when attached to a mesh will allow the mesh to be dragged around based on directions and origin of the pointer's ray
     */
    function SixDofDragBehavior() {
        this._sceneRenderObserver = null;
        this._targetPosition = new Vector3(0, 0, 0);
        this._moving = false;
        this._startingOrientation = new Quaternion();
        /**
         * How much faster the object should move when the controller is moving towards it. This is useful to bring objects that are far away from the user to them faster. Set this to 0 to avoid any speed increase. (Default: 3)
         */
        this.zDragFactor = 3;
        /**
         * If the object should rotate to face the drag origin
         */
        this.rotateDraggedObject = true;
        /**
         * If the behavior is currently in a dragging state
         */
        this.dragging = false;
        /**
         * The distance towards the target drag position to move each frame. This can be useful to avoid jitter. Set this to 1 for no delay. (Default: 0.2)
         */
        this.dragDeltaRatio = 0.2;
        /**
         * The id of the pointer that is currently interacting with the behavior (-1 when no pointer is active)
         */
        this.currentDraggingPointerID = -1;
        /**
         * If camera controls should be detached during the drag
         */
        this.detachCameraControls = true;
        /**
         * Fires each time a drag starts
         */
        this.onDragStartObservable = new Observable();
        /**
         *  Fires each time a drag ends (eg. mouse release after drag)
         */
        this.onDragEndObservable = new Observable();
    }
    Object.defineProperty(SixDofDragBehavior.prototype, "name", {
        /**
         *  The name of the behavior
         */
        get: function () {
            return "SixDofDrag";
        },
        enumerable: true,
        configurable: true
    });
    /**
     *  Initializes the behavior
     */
    SixDofDragBehavior.prototype.init = function () { };
    Object.defineProperty(SixDofDragBehavior.prototype, "_pointerCamera", {
        /**
         * In the case of multiplea active cameras, the cameraToUseForPointers should be used if set instead of active camera
         */
        get: function () {
            if (this._scene.cameraToUseForPointers) {
                return this._scene.cameraToUseForPointers;
            }
            else {
                return this._scene.activeCamera;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Attaches the scale behavior the passed in mesh
     * @param ownerNode The mesh that will be scaled around once attached
     */
    SixDofDragBehavior.prototype.attach = function (ownerNode) {
        var _this = this;
        this._ownerNode = ownerNode;
        this._scene = this._ownerNode.getScene();
        if (!SixDofDragBehavior._virtualScene) {
            SixDofDragBehavior._virtualScene = new Scene(this._scene.getEngine());
            SixDofDragBehavior._virtualScene.detachControl();
            this._scene.getEngine().scenes.pop();
        }
        var pickedMesh = null;
        var lastSixDofOriginPosition = new Vector3(0, 0, 0);
        // Setup virtual meshes to be used for dragging without dirtying the existing scene
        this._virtualOriginMesh = new AbstractMesh("", SixDofDragBehavior._virtualScene);
        this._virtualOriginMesh.rotationQuaternion = new Quaternion();
        this._virtualDragMesh = new AbstractMesh("", SixDofDragBehavior._virtualScene);
        this._virtualDragMesh.rotationQuaternion = new Quaternion();
        var pickPredicate = function (m) {
            return _this._ownerNode == m || m.isDescendantOf(_this._ownerNode);
        };
        var attachedElement = null;
        this._pointerObserver = this._scene.onPointerObservable.add(function (pointerInfo, eventState) {
            if (pointerInfo.type == PointerEventTypes.POINTERDOWN) {
                if (!_this.dragging && pointerInfo.pickInfo && pointerInfo.pickInfo.hit && pointerInfo.pickInfo.pickedMesh && pointerInfo.pickInfo.ray && pickPredicate(pointerInfo.pickInfo.pickedMesh)) {
                    if (_this._pointerCamera && _this._pointerCamera.cameraRigMode == Camera.RIG_MODE_NONE) {
                        pointerInfo.pickInfo.ray.origin.copyFrom(_this._pointerCamera.globalPosition);
                    }
                    pickedMesh = _this._ownerNode;
                    PivotTools._RemoveAndStorePivotPoint(pickedMesh);
                    lastSixDofOriginPosition.copyFrom(pointerInfo.pickInfo.ray.origin);
                    // Set position and orientation of the controller
                    _this._virtualOriginMesh.position.copyFrom(pointerInfo.pickInfo.ray.origin);
                    _this._virtualOriginMesh.lookAt(pointerInfo.pickInfo.ray.origin.add(pointerInfo.pickInfo.ray.direction));
                    // Attach the virtual drag mesh to the virtual origin mesh so it can be dragged
                    _this._virtualOriginMesh.removeChild(_this._virtualDragMesh);
                    pickedMesh.computeWorldMatrix();
                    _this._virtualDragMesh.position.copyFrom(pickedMesh.absolutePosition);
                    if (!pickedMesh.rotationQuaternion) {
                        pickedMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(pickedMesh.rotation.y, pickedMesh.rotation.x, pickedMesh.rotation.z);
                    }
                    var oldParent = pickedMesh.parent;
                    pickedMesh.setParent(null);
                    _this._virtualDragMesh.rotationQuaternion.copyFrom(pickedMesh.rotationQuaternion);
                    pickedMesh.setParent(oldParent);
                    _this._virtualOriginMesh.addChild(_this._virtualDragMesh);
                    // Update state
                    _this._targetPosition.copyFrom(_this._virtualDragMesh.absolutePosition);
                    _this.dragging = true;
                    _this.currentDraggingPointerID = pointerInfo.event.pointerId;
                    // Detatch camera controls
                    if (_this.detachCameraControls && _this._pointerCamera && !_this._pointerCamera.leftCamera) {
                        if (_this._pointerCamera.inputs.attachedElement) {
                            attachedElement = _this._pointerCamera.inputs.attachedElement;
                            _this._pointerCamera.detachControl(_this._pointerCamera.inputs.attachedElement);
                        }
                        else {
                            attachedElement = null;
                        }
                    }
                    PivotTools._RestorePivotPoint(pickedMesh);
                    _this.onDragStartObservable.notifyObservers({});
                }
            }
            else if (pointerInfo.type == PointerEventTypes.POINTERUP) {
                if (_this.currentDraggingPointerID == pointerInfo.event.pointerId) {
                    _this.dragging = false;
                    _this._moving = false;
                    _this.currentDraggingPointerID = -1;
                    pickedMesh = null;
                    _this._virtualOriginMesh.removeChild(_this._virtualDragMesh);
                    // Reattach camera controls
                    if (_this.detachCameraControls && attachedElement && _this._pointerCamera && !_this._pointerCamera.leftCamera) {
                        _this._pointerCamera.attachControl(attachedElement, true);
                    }
                    _this.onDragEndObservable.notifyObservers({});
                }
            }
            else if (pointerInfo.type == PointerEventTypes.POINTERMOVE) {
                if (_this.currentDraggingPointerID == pointerInfo.event.pointerId && _this.dragging && pointerInfo.pickInfo && pointerInfo.pickInfo.ray && pickedMesh) {
                    var zDragFactor = _this.zDragFactor;
                    if (_this._pointerCamera && _this._pointerCamera.cameraRigMode == Camera.RIG_MODE_NONE) {
                        pointerInfo.pickInfo.ray.origin.copyFrom(_this._pointerCamera.globalPosition);
                        zDragFactor = 0;
                    }
                    // Calculate controller drag distance in controller space
                    var originDragDifference = pointerInfo.pickInfo.ray.origin.subtract(lastSixDofOriginPosition);
                    lastSixDofOriginPosition.copyFrom(pointerInfo.pickInfo.ray.origin);
                    var localOriginDragDifference = -Vector3.Dot(originDragDifference, pointerInfo.pickInfo.ray.direction);
                    _this._virtualOriginMesh.addChild(_this._virtualDragMesh);
                    // Determine how much the controller moved to/away towards the dragged object and use this to move the object further when its further away
                    _this._virtualDragMesh.position.z -= _this._virtualDragMesh.position.z < 1 ? localOriginDragDifference * _this.zDragFactor : localOriginDragDifference * zDragFactor * _this._virtualDragMesh.position.z;
                    if (_this._virtualDragMesh.position.z < 0) {
                        _this._virtualDragMesh.position.z = 0;
                    }
                    // Update the controller position
                    _this._virtualOriginMesh.position.copyFrom(pointerInfo.pickInfo.ray.origin);
                    _this._virtualOriginMesh.lookAt(pointerInfo.pickInfo.ray.origin.add(pointerInfo.pickInfo.ray.direction));
                    _this._virtualOriginMesh.removeChild(_this._virtualDragMesh);
                    // Move the virtualObjectsPosition into the picked mesh's space if needed
                    _this._targetPosition.copyFrom(_this._virtualDragMesh.absolutePosition);
                    if (pickedMesh.parent) {
                        Vector3.TransformCoordinatesToRef(_this._targetPosition, Matrix.Invert(pickedMesh.parent.getWorldMatrix()), _this._targetPosition);
                    }
                    if (!_this._moving) {
                        _this._startingOrientation.copyFrom(_this._virtualDragMesh.rotationQuaternion);
                    }
                    _this._moving = true;
                }
            }
        });
        var tmpQuaternion = new Quaternion();
        // On every frame move towards target scaling to avoid jitter caused by vr controllers
        this._sceneRenderObserver = ownerNode.getScene().onBeforeRenderObservable.add(function () {
            if (_this.dragging && _this._moving && pickedMesh) {
                PivotTools._RemoveAndStorePivotPoint(pickedMesh);
                // Slowly move mesh to avoid jitter
                pickedMesh.position.addInPlace(_this._targetPosition.subtract(pickedMesh.position).scale(_this.dragDeltaRatio));
                if (_this.rotateDraggedObject) {
                    // Get change in rotation
                    tmpQuaternion.copyFrom(_this._startingOrientation);
                    tmpQuaternion.x = -tmpQuaternion.x;
                    tmpQuaternion.y = -tmpQuaternion.y;
                    tmpQuaternion.z = -tmpQuaternion.z;
                    _this._virtualDragMesh.rotationQuaternion.multiplyToRef(tmpQuaternion, tmpQuaternion);
                    // Convert change in rotation to only y axis rotation
                    Quaternion.RotationYawPitchRollToRef(tmpQuaternion.toEulerAngles("xyz").y, 0, 0, tmpQuaternion);
                    tmpQuaternion.multiplyToRef(_this._startingOrientation, tmpQuaternion);
                    // Slowly move mesh to avoid jitter
                    var oldParent = pickedMesh.parent;
                    // Only rotate the mesh if it's parent has uniform scaling
                    if (!oldParent || (oldParent.scaling && !oldParent.scaling.isNonUniformWithinEpsilon(0.001))) {
                        pickedMesh.setParent(null);
                        Quaternion.SlerpToRef(pickedMesh.rotationQuaternion, tmpQuaternion, _this.dragDeltaRatio, pickedMesh.rotationQuaternion);
                        pickedMesh.setParent(oldParent);
                    }
                }
                PivotTools._RestorePivotPoint(pickedMesh);
            }
        });
    };
    /**
     *  Detaches the behavior from the mesh
     */
    SixDofDragBehavior.prototype.detach = function () {
        if (this._scene) {
            this._scene.onPointerObservable.remove(this._pointerObserver);
        }
        if (this._ownerNode) {
            this._ownerNode.getScene().onBeforeRenderObservable.remove(this._sceneRenderObserver);
        }
        if (this._virtualOriginMesh) {
            this._virtualOriginMesh.dispose();
        }
        if (this._virtualDragMesh) {
            this._virtualDragMesh.dispose();
        }
        this.onDragEndObservable.clear();
        this.onDragStartObservable.clear();
    };
    return SixDofDragBehavior;
}());
export { SixDofDragBehavior };
//# sourceMappingURL=sixDofDragBehavior.js.map