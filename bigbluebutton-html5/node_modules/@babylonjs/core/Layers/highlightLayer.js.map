{"version":3,"file":"highlightLayer.js","sourceRoot":"","sources":["../../../sourceES6/core/Layers/highlightLayer.ts"],"names":[],"mappings":"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","sourcesContent":["import { serialize, SerializationHelper } from \"../Misc/decorators\";\r\nimport { Observer, Observable } from \"../Misc/observable\";\r\nimport { Nullable } from \"../types\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport { Scene } from \"../scene\";\r\nimport { Vector2 } from \"../Maths/math.vector\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { VertexBuffer } from \"../Meshes/buffer\";\r\nimport { SubMesh } from \"../Meshes/subMesh\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { Effect } from \"../Materials/effect\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport { PostProcess, PostProcessOptions } from \"../PostProcesses/postProcess\";\r\nimport { PassPostProcess } from \"../PostProcesses/passPostProcess\";\r\nimport { BlurPostProcess } from \"../PostProcesses/blurPostProcess\";\r\nimport { EffectLayer } from \"./effectLayer\";\r\nimport { AbstractScene } from \"../abstractScene\";\r\n\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { _TypeStore } from '../Misc/typeStore';\r\nimport { Color4, Color3 } from '../Maths/math.color';\r\n\r\nimport \"../Shaders/glowMapMerge.fragment\";\r\nimport \"../Shaders/glowMapMerge.vertex\";\r\nimport \"../Shaders/glowBlurPostProcess.fragment\";\r\n\r\ndeclare module \"../abstractScene\" {\r\n    export interface AbstractScene {\r\n        /**\r\n         * Return a the first highlight layer of the scene with a given name.\r\n         * @param name The name of the highlight layer to look for.\r\n         * @return The highlight layer if found otherwise null.\r\n         */\r\n        getHighlightLayerByName(name: string): Nullable<HighlightLayer>;\r\n    }\r\n}\r\n\r\nAbstractScene.prototype.getHighlightLayerByName = function(name: string): Nullable<HighlightLayer> {\r\n    for (var index = 0; index < this.effectLayers.length; index++) {\r\n        if (this.effectLayers[index].name === name && this.effectLayers[index].getEffectName() === HighlightLayer.EffectName) {\r\n            return (<any>this.effectLayers[index]) as HighlightLayer;\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n * Special Glow Blur post process only blurring the alpha channel\r\n * It enforces keeping the most luminous color in the color channel.\r\n */\r\nclass GlowBlurPostProcess extends PostProcess {\r\n    constructor(name: string, public direction: Vector2, public kernel: number, options: number | PostProcessOptions, camera: Nullable<Camera>, samplingMode: number = Texture.BILINEAR_SAMPLINGMODE, engine?: Engine, reusable?: boolean) {\r\n        super(name, \"glowBlurPostProcess\", [\"screenSize\", \"direction\", \"blurWidth\"], null, options, camera, samplingMode, engine, reusable);\r\n\r\n        this.onApplyObservable.add((effect: Effect) => {\r\n            effect.setFloat2(\"screenSize\", this.width, this.height);\r\n            effect.setVector2(\"direction\", this.direction);\r\n            effect.setFloat(\"blurWidth\", this.kernel);\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * Highlight layer options. This helps customizing the behaviour\r\n * of the highlight layer.\r\n */\r\nexport interface IHighlightLayerOptions {\r\n    /**\r\n     * Multiplication factor apply to the canvas size to compute the render target size\r\n     * used to generated the glowing objects (the smaller the faster).\r\n     */\r\n    mainTextureRatio: number;\r\n\r\n    /**\r\n     * Enforces a fixed size texture to ensure resize independant blur.\r\n     */\r\n    mainTextureFixedSize?: number;\r\n\r\n    /**\r\n     * Multiplication factor apply to the main texture size in the first step of the blur to reduce the size\r\n     * of the picture to blur (the smaller the faster).\r\n     */\r\n    blurTextureSizeRatio: number;\r\n\r\n    /**\r\n     * How big in texel of the blur texture is the vertical blur.\r\n     */\r\n    blurVerticalSize: number;\r\n\r\n    /**\r\n     * How big in texel of the blur texture is the horizontal blur.\r\n     */\r\n    blurHorizontalSize: number;\r\n\r\n    /**\r\n     * Alpha blending mode used to apply the blur. Default is combine.\r\n     */\r\n    alphaBlendingMode: number;\r\n\r\n    /**\r\n     * The camera attached to the layer.\r\n     */\r\n    camera: Nullable<Camera>;\r\n\r\n    /**\r\n     * Should we display highlight as a solid stroke?\r\n     */\r\n    isStroke?: boolean;\r\n\r\n    /**\r\n     * The rendering group to draw the layer in.\r\n     */\r\n    renderingGroupId: number;\r\n}\r\n\r\n/**\r\n * Storage interface grouping all the information required for glowing a mesh.\r\n */\r\ninterface IHighlightLayerMesh {\r\n    /**\r\n     * The glowy mesh\r\n     */\r\n    mesh: Mesh;\r\n    /**\r\n     * The color of the glow\r\n     */\r\n    color: Color3;\r\n    /**\r\n     * The mesh render callback use to insert stencil information\r\n     */\r\n    observerHighlight: Nullable<Observer<Mesh>>;\r\n    /**\r\n     * The mesh render callback use to come to the default behavior\r\n     */\r\n    observerDefault: Nullable<Observer<Mesh>>;\r\n    /**\r\n     * If it exists, the emissive color of the material will be used to generate the glow.\r\n     * Else it falls back to the current color.\r\n     */\r\n    glowEmissiveOnly: boolean;\r\n}\r\n\r\n/**\r\n * Storage interface grouping all the information required for an excluded mesh.\r\n */\r\ninterface IHighlightLayerExcludedMesh {\r\n    /**\r\n     * The glowy mesh\r\n     */\r\n    mesh: Mesh;\r\n    /**\r\n     * The mesh render callback use to prevent stencil use\r\n     */\r\n    beforeBind: Nullable<Observer<Mesh>>;\r\n    /**\r\n     * The mesh render callback use to restore previous stencil use\r\n     */\r\n    afterRender: Nullable<Observer<Mesh>>;\r\n}\r\n\r\n/**\r\n * The highlight layer Helps adding a glow effect around a mesh.\r\n *\r\n * Once instantiated in a scene, simply use the addMesh or removeMesh method to add or remove\r\n * glowy meshes to your scene.\r\n *\r\n * !!! THIS REQUIRES AN ACTIVE STENCIL BUFFER ON THE CANVAS !!!\r\n */\r\nexport class HighlightLayer extends EffectLayer {\r\n    /**\r\n     * Effect Name of the highlight layer.\r\n     */\r\n    public static readonly EffectName = \"HighlightLayer\";\r\n\r\n    /**\r\n     * The neutral color used during the preparation of the glow effect.\r\n     * This is black by default as the blend operation is a blend operation.\r\n     */\r\n    public static NeutralColor: Color4 = new Color4(0, 0, 0, 0);\r\n\r\n    /**\r\n     * Stencil value used for glowing meshes.\r\n     */\r\n    public static GlowingMeshStencilReference = 0x02;\r\n\r\n    /**\r\n     * Stencil value used for the other meshes in the scene.\r\n     */\r\n    public static NormalMeshStencilReference = 0x01;\r\n\r\n    /**\r\n     * Specifies whether or not the inner glow is ACTIVE in the layer.\r\n     */\r\n    @serialize()\r\n    public innerGlow: boolean = true;\r\n\r\n    /**\r\n     * Specifies whether or not the outer glow is ACTIVE in the layer.\r\n     */\r\n    @serialize()\r\n    public outerGlow: boolean = true;\r\n\r\n    /**\r\n     * Specifies the horizontal size of the blur.\r\n     */\r\n    public set blurHorizontalSize(value: number) {\r\n        this._horizontalBlurPostprocess.kernel = value;\r\n    }\r\n\r\n    /**\r\n     * Specifies the vertical size of the blur.\r\n     */\r\n    public set blurVerticalSize(value: number) {\r\n        this._verticalBlurPostprocess.kernel = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the horizontal size of the blur.\r\n     */\r\n    @serialize()\r\n    public get blurHorizontalSize(): number {\r\n        return this._horizontalBlurPostprocess.kernel;\r\n    }\r\n\r\n    /**\r\n     * Gets the vertical size of the blur.\r\n     */\r\n    @serialize()\r\n    public get blurVerticalSize(): number {\r\n        return this._verticalBlurPostprocess.kernel;\r\n    }\r\n\r\n    /**\r\n     * An event triggered when the highlight layer is being blurred.\r\n     */\r\n    public onBeforeBlurObservable = new Observable<HighlightLayer>();\r\n\r\n    /**\r\n     * An event triggered when the highlight layer has been blurred.\r\n     */\r\n    public onAfterBlurObservable = new Observable<HighlightLayer>();\r\n\r\n    private _instanceGlowingMeshStencilReference = HighlightLayer.GlowingMeshStencilReference++;\r\n\r\n    @serialize(\"options\")\r\n    private _options: IHighlightLayerOptions;\r\n    private _downSamplePostprocess: PassPostProcess;\r\n    private _horizontalBlurPostprocess: GlowBlurPostProcess;\r\n    private _verticalBlurPostprocess: GlowBlurPostProcess;\r\n    private _blurTexture: RenderTargetTexture;\r\n\r\n    private _meshes: Nullable<{ [id: string]: Nullable<IHighlightLayerMesh> }> = {};\r\n    private _excludedMeshes: Nullable<{ [id: string]: Nullable<IHighlightLayerExcludedMesh> }> = {};\r\n\r\n    /**\r\n     * Instantiates a new highlight Layer and references it to the scene..\r\n     * @param name The name of the layer\r\n     * @param scene The scene to use the layer in\r\n     * @param options Sets of none mandatory options to use with the layer (see IHighlightLayerOptions for more information)\r\n     */\r\n    constructor(public name: string, scene: Scene, options?: Partial<IHighlightLayerOptions>) {\r\n        super(name, scene);\r\n        this.neutralColor = HighlightLayer.NeutralColor;\r\n\r\n        // Warn on stencil\r\n        if (!this._engine.isStencilEnable) {\r\n            Logger.Warn(\"Rendering the Highlight Layer requires the stencil to be active on the canvas. var engine = new Engine(canvas, antialias, { stencil: true }\");\r\n        }\r\n\r\n        // Adapt options\r\n        this._options = {\r\n            mainTextureRatio: 0.5,\r\n            blurTextureSizeRatio: 0.5,\r\n            blurHorizontalSize: 1.0,\r\n            blurVerticalSize: 1.0,\r\n            alphaBlendingMode: 2,\r\n            camera: null,\r\n            renderingGroupId: -1,\r\n            ...options,\r\n        };\r\n\r\n        // Initialize the layer\r\n        this._init({\r\n            alphaBlendingMode: this._options.alphaBlendingMode,\r\n            camera: this._options.camera,\r\n            mainTextureFixedSize: this._options.mainTextureFixedSize,\r\n            mainTextureRatio: this._options.mainTextureRatio,\r\n            renderingGroupId: this._options.renderingGroupId\r\n        });\r\n\r\n        // Do not render as long as no meshes have been added\r\n        this._shouldRender = false;\r\n    }\r\n\r\n    /**\r\n     * Get the effect name of the layer.\r\n     * @return The effect name\r\n     */\r\n    public getEffectName(): string {\r\n        return HighlightLayer.EffectName;\r\n    }\r\n\r\n    /**\r\n     * Create the merge effect. This is the shader use to blit the information back\r\n     * to the main canvas at the end of the scene rendering.\r\n     */\r\n    protected _createMergeEffect(): Effect {\r\n        // Effect\r\n        return this._engine.createEffect(\"glowMapMerge\",\r\n            [VertexBuffer.PositionKind],\r\n            [\"offset\"],\r\n            [\"textureSampler\"],\r\n            this._options.isStroke ? \"#define STROKE \\n\" : undefined);\r\n\r\n    }\r\n\r\n    /**\r\n     * Creates the render target textures and post processes used in the highlight layer.\r\n     */\r\n    protected _createTextureAndPostProcesses(): void {\r\n        var blurTextureWidth = this._mainTextureDesiredSize.width * this._options.blurTextureSizeRatio;\r\n        var blurTextureHeight = this._mainTextureDesiredSize.height * this._options.blurTextureSizeRatio;\r\n        blurTextureWidth = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(blurTextureWidth, this._maxSize) : blurTextureWidth;\r\n        blurTextureHeight = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(blurTextureHeight, this._maxSize) : blurTextureHeight;\r\n\r\n        var textureType = 0;\r\n        if (this._engine.getCaps().textureHalfFloatRender) {\r\n            textureType = 2;\r\n        }\r\n        else {\r\n            textureType = 0;\r\n        }\r\n\r\n        this._blurTexture = new RenderTargetTexture(\"HighlightLayerBlurRTT\",\r\n            {\r\n                width: blurTextureWidth,\r\n                height: blurTextureHeight\r\n            },\r\n            this._scene,\r\n            false,\r\n            true,\r\n            textureType);\r\n        this._blurTexture.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this._blurTexture.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        this._blurTexture.anisotropicFilteringLevel = 16;\r\n        this._blurTexture.updateSamplingMode(Texture.TRILINEAR_SAMPLINGMODE);\r\n        this._blurTexture.renderParticles = false;\r\n        this._blurTexture.ignoreCameraViewport = true;\r\n\r\n        this._textures = [this._blurTexture];\r\n\r\n        if (this._options.alphaBlendingMode === 2) {\r\n            this._downSamplePostprocess = new PassPostProcess(\"HighlightLayerPPP\", this._options.blurTextureSizeRatio,\r\n                null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine());\r\n            this._downSamplePostprocess.onApplyObservable.add((effect) => {\r\n                effect.setTexture(\"textureSampler\", this._mainTexture);\r\n            });\r\n\r\n            this._horizontalBlurPostprocess = new GlowBlurPostProcess(\"HighlightLayerHBP\", new Vector2(1.0, 0), this._options.blurHorizontalSize, 1,\r\n                null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine());\r\n            this._horizontalBlurPostprocess.onApplyObservable.add((effect) => {\r\n                effect.setFloat2(\"screenSize\", blurTextureWidth, blurTextureHeight);\r\n            });\r\n\r\n            this._verticalBlurPostprocess = new GlowBlurPostProcess(\"HighlightLayerVBP\", new Vector2(0, 1.0), this._options.blurVerticalSize, 1,\r\n                null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine());\r\n            this._verticalBlurPostprocess.onApplyObservable.add((effect) => {\r\n                effect.setFloat2(\"screenSize\", blurTextureWidth, blurTextureHeight);\r\n            });\r\n\r\n            this._postProcesses = [this._downSamplePostprocess, this._horizontalBlurPostprocess, this._verticalBlurPostprocess];\r\n        }\r\n        else {\r\n            this._horizontalBlurPostprocess = new BlurPostProcess(\"HighlightLayerHBP\", new Vector2(1.0, 0), this._options.blurHorizontalSize / 2, {\r\n                width: blurTextureWidth,\r\n                height: blurTextureHeight\r\n            },\r\n                null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, textureType);\r\n            this._horizontalBlurPostprocess.width = blurTextureWidth;\r\n            this._horizontalBlurPostprocess.height = blurTextureHeight;\r\n            this._horizontalBlurPostprocess.onApplyObservable.add((effect) => {\r\n                effect.setTexture(\"textureSampler\", this._mainTexture);\r\n            });\r\n\r\n            this._verticalBlurPostprocess = new BlurPostProcess(\"HighlightLayerVBP\", new Vector2(0, 1.0), this._options.blurVerticalSize / 2, {\r\n                width: blurTextureWidth,\r\n                height: blurTextureHeight\r\n            },\r\n                null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, textureType);\r\n\r\n            this._postProcesses = [this._horizontalBlurPostprocess, this._verticalBlurPostprocess];\r\n        }\r\n\r\n        this._mainTexture.onAfterUnbindObservable.add(() => {\r\n            this.onBeforeBlurObservable.notifyObservers(this);\r\n\r\n            let internalTexture = this._blurTexture.getInternalTexture();\r\n            if (internalTexture) {\r\n                this._scene.postProcessManager.directRender(\r\n                    this._postProcesses,\r\n                    internalTexture,\r\n                    true);\r\n            }\r\n\r\n            this.onAfterBlurObservable.notifyObservers(this);\r\n        });\r\n\r\n        // Prevent autoClear.\r\n        this._postProcesses.map((pp) => { pp.autoClear = false; });\r\n    }\r\n\r\n    /**\r\n     * Returns wether or nood the layer needs stencil enabled during the mesh rendering.\r\n     */\r\n    public needStencil(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Checks for the readiness of the element composing the layer.\r\n     * @param subMesh the mesh to check for\r\n     * @param useInstances specify wether or not to use instances to render the mesh\r\n     * @param emissiveTexture the associated emissive texture used to generate the glow\r\n     * @return true if ready otherwise, false\r\n     */\r\n    public isReady(subMesh: SubMesh, useInstances: boolean): boolean {\r\n        let material = subMesh.getMaterial();\r\n        let mesh = subMesh.getRenderingMesh();\r\n\r\n        if (!material || !mesh || !this._meshes) {\r\n            return false;\r\n        }\r\n\r\n        let emissiveTexture: Nullable<Texture> = null;\r\n        let highlightLayerMesh = this._meshes[mesh.uniqueId];\r\n\r\n        if (highlightLayerMesh && highlightLayerMesh.glowEmissiveOnly && material) {\r\n            emissiveTexture = (<any>material).emissiveTexture;\r\n        }\r\n        return super._isReady(subMesh, useInstances, emissiveTexture);\r\n    }\r\n\r\n    /**\r\n     * Implementation specific of rendering the generating effect on the main canvas.\r\n     * @param effect The effect used to render through\r\n     */\r\n    protected _internalRender(effect: Effect): void {\r\n        // Texture\r\n        effect.setTexture(\"textureSampler\", this._blurTexture);\r\n\r\n        // Cache\r\n        var engine = this._engine;\r\n        engine.cacheStencilState();\r\n\r\n        // Stencil operations\r\n        engine.setStencilOperationPass(7681);\r\n        engine.setStencilOperationFail(7680);\r\n        engine.setStencilOperationDepthFail(7680);\r\n\r\n        // Draw order\r\n        engine.setStencilMask(0x00);\r\n        engine.setStencilBuffer(true);\r\n        engine.setStencilFunctionReference(this._instanceGlowingMeshStencilReference);\r\n\r\n        // 2 passes inner outer\r\n        if (this.outerGlow) {\r\n            effect.setFloat(\"offset\", 0);\r\n            engine.setStencilFunction(517);\r\n            engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n        }\r\n        if (this.innerGlow) {\r\n            effect.setFloat(\"offset\", 1);\r\n            engine.setStencilFunction(514);\r\n            engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n        }\r\n\r\n        // Restore Cache\r\n        engine.restoreStencilState();\r\n    }\r\n\r\n    /**\r\n     * Returns true if the layer contains information to display, otherwise false.\r\n     */\r\n    public shouldRender(): boolean {\r\n        if (super.shouldRender()) {\r\n            return this._meshes ? true : false;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the mesh should render, otherwise false.\r\n     * @param mesh The mesh to render\r\n     * @returns true if it should render otherwise false\r\n     */\r\n    protected _shouldRenderMesh(mesh: Mesh): boolean {\r\n        // Excluded Mesh\r\n        if (this._excludedMeshes && this._excludedMeshes[mesh.uniqueId]) {\r\n            return false;\r\n        }\r\n\r\n        if (!super.hasMesh(mesh)) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Sets the required values for both the emissive texture and and the main color.\r\n     */\r\n    protected _setEmissiveTextureAndColor(mesh: Mesh, subMesh: SubMesh, material: Material): void {\r\n        var highlightLayerMesh = this._meshes![mesh.uniqueId];\r\n        if (highlightLayerMesh) {\r\n            this._emissiveTextureAndColor.color.set(\r\n                highlightLayerMesh.color.r,\r\n                highlightLayerMesh.color.g,\r\n                highlightLayerMesh.color.b,\r\n                1.0);\r\n        }\r\n        else {\r\n            this._emissiveTextureAndColor.color.set(\r\n                this.neutralColor.r,\r\n                this.neutralColor.g,\r\n                this.neutralColor.b,\r\n                this.neutralColor.a);\r\n        }\r\n\r\n        if (highlightLayerMesh && highlightLayerMesh.glowEmissiveOnly && material) {\r\n            this._emissiveTextureAndColor.texture = (<any>material).emissiveTexture;\r\n            this._emissiveTextureAndColor.color.set(\r\n                1.0,\r\n                1.0,\r\n                1.0,\r\n                1.0);\r\n        }\r\n        else {\r\n            this._emissiveTextureAndColor.texture = null;\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Add a mesh in the exclusion list to prevent it to impact or being impacted by the highlight layer.\r\n     * @param mesh The mesh to exclude from the highlight layer\r\n     */\r\n    public addExcludedMesh(mesh: Mesh) {\r\n        if (!this._excludedMeshes) {\r\n            return;\r\n        }\r\n\r\n        var meshExcluded = this._excludedMeshes[mesh.uniqueId];\r\n        if (!meshExcluded) {\r\n            this._excludedMeshes[mesh.uniqueId] = {\r\n                mesh: mesh,\r\n                beforeBind: mesh.onBeforeBindObservable.add((mesh: Mesh) => {\r\n                    mesh.getEngine().setStencilBuffer(false);\r\n                }),\r\n                afterRender: mesh.onAfterRenderObservable.add((mesh: Mesh) => {\r\n                    mesh.getEngine().setStencilBuffer(true);\r\n                }),\r\n            };\r\n        }\r\n    }\r\n\r\n    /**\r\n      * Remove a mesh from the exclusion list to let it impact or being impacted by the highlight layer.\r\n      * @param mesh The mesh to highlight\r\n      */\r\n    public removeExcludedMesh(mesh: Mesh) {\r\n        if (!this._excludedMeshes) {\r\n            return;\r\n        }\r\n\r\n        var meshExcluded = this._excludedMeshes[mesh.uniqueId];\r\n        if (meshExcluded) {\r\n            if (meshExcluded.beforeBind) {\r\n                mesh.onBeforeBindObservable.remove(meshExcluded.beforeBind);\r\n            }\r\n\r\n            if (meshExcluded.afterRender) {\r\n                mesh.onAfterRenderObservable.remove(meshExcluded.afterRender);\r\n            }\r\n        }\r\n\r\n        this._excludedMeshes[mesh.uniqueId] = null;\r\n    }\r\n\r\n    /**\r\n     * Determine if a given mesh will be highlighted by the current HighlightLayer\r\n     * @param mesh mesh to test\r\n     * @returns true if the mesh will be highlighted by the current HighlightLayer\r\n     */\r\n    public hasMesh(mesh: AbstractMesh): boolean {\r\n        if (!this._meshes) {\r\n            return false;\r\n        }\r\n\r\n        if (!super.hasMesh(mesh)) {\r\n            return false;\r\n        }\r\n\r\n        return this._meshes[mesh.uniqueId] !== undefined && this._meshes[mesh.uniqueId] !== null;\r\n    }\r\n\r\n    /**\r\n     * Add a mesh in the highlight layer in order to make it glow with the chosen color.\r\n     * @param mesh The mesh to highlight\r\n     * @param color The color of the highlight\r\n     * @param glowEmissiveOnly Extract the glow from the emissive texture\r\n     */\r\n    public addMesh(mesh: Mesh, color: Color3, glowEmissiveOnly = false) {\r\n        if (!this._meshes) {\r\n            return;\r\n        }\r\n\r\n        var meshHighlight = this._meshes[mesh.uniqueId];\r\n        if (meshHighlight) {\r\n            meshHighlight.color = color;\r\n        }\r\n        else {\r\n            this._meshes[mesh.uniqueId] = {\r\n                mesh: mesh,\r\n                color: color,\r\n                // Lambda required for capture due to Observable this context\r\n                observerHighlight: mesh.onBeforeBindObservable.add((mesh: Mesh) => {\r\n                    if (this.isEnabled) {\r\n                        if (this._excludedMeshes && this._excludedMeshes[mesh.uniqueId]) {\r\n                            this._defaultStencilReference(mesh);\r\n                        }\r\n                        else {\r\n                            mesh.getScene().getEngine().setStencilFunctionReference(this._instanceGlowingMeshStencilReference);\r\n                        }\r\n                    }\r\n                }),\r\n                observerDefault: mesh.onAfterRenderObservable.add((mesh: Mesh) => {\r\n                    if (this.isEnabled) {\r\n                        this._defaultStencilReference(mesh);\r\n                    }\r\n                }),\r\n                glowEmissiveOnly: glowEmissiveOnly\r\n            };\r\n\r\n            mesh.onDisposeObservable.add(() => {\r\n                this._disposeMesh(mesh);\r\n            });\r\n        }\r\n\r\n        this._shouldRender = true;\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh from the highlight layer in order to make it stop glowing.\r\n     * @param mesh The mesh to highlight\r\n     */\r\n    public removeMesh(mesh: Mesh) {\r\n        if (!this._meshes) {\r\n            return;\r\n        }\r\n\r\n        var meshHighlight = this._meshes[mesh.uniqueId];\r\n        if (meshHighlight) {\r\n\r\n            if (meshHighlight.observerHighlight) {\r\n                mesh.onBeforeBindObservable.remove(meshHighlight.observerHighlight);\r\n            }\r\n\r\n            if (meshHighlight.observerDefault) {\r\n                mesh.onAfterRenderObservable.remove(meshHighlight.observerDefault);\r\n            }\r\n            delete this._meshes[mesh.uniqueId];\r\n        }\r\n\r\n        this._shouldRender = false;\r\n        for (var meshHighlightToCheck in this._meshes) {\r\n            if (this._meshes[meshHighlightToCheck]) {\r\n                this._shouldRender = true;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove all the meshes currently referenced in the highlight layer\r\n     */\r\n    public removeAllMeshes(): void {\r\n        if (!this._meshes) {\r\n            return;\r\n        }\r\n\r\n        for (const uniqueId in this._meshes) {\r\n            if (this._meshes.hasOwnProperty(uniqueId)) {\r\n                const mesh = this._meshes[uniqueId];\r\n                if (mesh) {\r\n                    this.removeMesh(mesh.mesh);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Force the stencil to the normal expected value for none glowing parts\r\n     */\r\n    private _defaultStencilReference(mesh: Mesh) {\r\n        mesh.getScene().getEngine().setStencilFunctionReference(HighlightLayer.NormalMeshStencilReference);\r\n    }\r\n\r\n    /**\r\n     * Free any resources and references associated to a mesh.\r\n     * Internal use\r\n     * @param mesh The mesh to free.\r\n     * @hidden\r\n     */\r\n    public _disposeMesh(mesh: Mesh): void {\r\n        this.removeMesh(mesh);\r\n        this.removeExcludedMesh(mesh);\r\n    }\r\n\r\n    /**\r\n     * Dispose the highlight layer and free resources.\r\n     */\r\n    public dispose(): void {\r\n        if (this._meshes) {\r\n            // Clean mesh references\r\n            for (let id in this._meshes) {\r\n                let meshHighlight = this._meshes[id];\r\n                if (meshHighlight && meshHighlight.mesh) {\r\n\r\n                    if (meshHighlight.observerHighlight) {\r\n                        meshHighlight.mesh.onBeforeBindObservable.remove(meshHighlight.observerHighlight);\r\n                    }\r\n\r\n                    if (meshHighlight.observerDefault) {\r\n                        meshHighlight.mesh.onAfterRenderObservable.remove(meshHighlight.observerDefault);\r\n                    }\r\n                }\r\n            }\r\n            this._meshes = null;\r\n        }\r\n\r\n        if (this._excludedMeshes) {\r\n            for (let id in this._excludedMeshes) {\r\n                let meshHighlight = this._excludedMeshes[id];\r\n                if (meshHighlight) {\r\n\r\n                    if (meshHighlight.beforeBind) {\r\n                        meshHighlight.mesh.onBeforeBindObservable.remove(meshHighlight.beforeBind);\r\n                    }\r\n\r\n                    if (meshHighlight.afterRender) {\r\n                        meshHighlight.mesh.onAfterRenderObservable.remove(meshHighlight.afterRender);\r\n                    }\r\n                }\r\n            }\r\n            this._excludedMeshes = null;\r\n        }\r\n\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n      * Gets the class name of the effect layer\r\n      * @returns the string with the class name of the effect layer\r\n      */\r\n    public getClassName(): string {\r\n        return \"HighlightLayer\";\r\n    }\r\n\r\n    /**\r\n     * Serializes this Highlight layer\r\n     * @returns a serialized Highlight layer object\r\n     */\r\n    public serialize(): any {\r\n        var serializationObject = SerializationHelper.Serialize(this);\r\n        serializationObject.customType = \"BABYLON.HighlightLayer\";\r\n\r\n        // Highlighted meshes\r\n        serializationObject.meshes = [];\r\n\r\n        if (this._meshes) {\r\n            for (var m in this._meshes) {\r\n                var mesh = this._meshes[m];\r\n\r\n                if (mesh) {\r\n                    serializationObject.meshes.push({\r\n                        glowEmissiveOnly: mesh.glowEmissiveOnly,\r\n                        color: mesh.color.asArray(),\r\n                        meshId: mesh.mesh.id\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        // Excluded meshes\r\n        serializationObject.excludedMeshes = [];\r\n\r\n        if (this._excludedMeshes) {\r\n            for (var e in this._excludedMeshes) {\r\n                var excludedMesh = this._excludedMeshes[e];\r\n\r\n                if (excludedMesh) {\r\n                    serializationObject.excludedMeshes.push(excludedMesh.mesh.id);\r\n                }\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a Highlight layer from parsed Highlight layer data\r\n     * @param parsedHightlightLayer defines the Highlight layer data\r\n     * @param scene defines the current scene\r\n     * @param rootUrl defines the root URL containing the Highlight layer information\r\n     * @returns a parsed Highlight layer\r\n     */\r\n    public static Parse(parsedHightlightLayer: any, scene: Scene, rootUrl: string): HighlightLayer {\r\n        var hl = SerializationHelper.Parse(() => new HighlightLayer(parsedHightlightLayer.name, scene, parsedHightlightLayer.options), parsedHightlightLayer, scene, rootUrl);\r\n        var index;\r\n\r\n        // Excluded meshes\r\n        for (index = 0; index < parsedHightlightLayer.excludedMeshes.length; index++) {\r\n            var mesh = scene.getMeshByID(parsedHightlightLayer.excludedMeshes[index]);\r\n            if (mesh) {\r\n                hl.addExcludedMesh(<Mesh>mesh);\r\n            }\r\n        }\r\n\r\n        // Included meshes\r\n        for (index = 0; index < parsedHightlightLayer.meshes.length; index++) {\r\n            var highlightedMesh = parsedHightlightLayer.meshes[index];\r\n            var mesh = scene.getMeshByID(highlightedMesh.meshId);\r\n\r\n            if (mesh) {\r\n                hl.addMesh(<Mesh>mesh, Color3.FromArray(highlightedMesh.color), highlightedMesh.glowEmissiveOnly);\r\n            }\r\n        }\r\n\r\n        return hl;\r\n    }\r\n}\r\n\r\n_TypeStore.RegisteredTypes[\"BABYLON.HighlightLayer\"] = HighlightLayer;"]}