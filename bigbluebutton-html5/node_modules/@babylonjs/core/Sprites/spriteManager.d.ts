import { IDisposable, Scene } from "../scene";
import { Nullable } from "../types";
import { Observable } from "../Misc/observable";
import { Sprite } from "./sprite";
import { PickingInfo } from "../Collisions/pickingInfo";
import { Camera } from "../Cameras/camera";
import { Texture } from "../Materials/Textures/texture";
import "../Shaders/sprites.fragment";
import "../Shaders/sprites.vertex";
declare type Ray = import("../Culling/ray").Ray;
/**
 * Defines the minimum interface to fullfil in order to be a sprite manager.
 */
export interface ISpriteManager extends IDisposable {
    /**
     * Restricts the camera to viewing objects with the same layerMask.
     * A camera with a layerMask of 1 will render spriteManager.layerMask & camera.layerMask!== 0
     */
    layerMask: number;
    /**
     * Gets or sets a boolean indicating if the mesh can be picked (by scene.pick for instance or through actions). Default is true
     */
    isPickable: boolean;
    /**
     * Specifies the rendering group id for this mesh (0 by default)
     * @see http://doc.babylonjs.com/resources/transparency_and_how_meshes_are_rendered#rendering-groups
     */
    renderingGroupId: number;
    /**
     * Defines the list of sprites managed by the manager.
     */
    sprites: Array<Sprite>;
    /**
     * Tests the intersection of a sprite with a specific ray.
     * @param ray The ray we are sending to test the collision
     * @param camera The camera space we are sending rays in
     * @param predicate A predicate allowing excluding sprites from the list of object to test
     * @param fastCheck Is the hit test done in a OOBB or AOBB fashion the faster, the less precise
     * @returns picking info or null.
     */
    intersects(ray: Ray, camera: Camera, predicate?: (sprite: Sprite) => boolean, fastCheck?: boolean): Nullable<PickingInfo>;
    /**
     * Intersects the sprites with a ray
     * @param ray defines the ray to intersect with
     * @param camera defines the current active camera
     * @param predicate defines a predicate used to select candidate sprites
     * @returns null if no hit or a PickingInfo array
     */
    multiIntersects(ray: Ray, camera: Camera, predicate?: (sprite: Sprite) => boolean): Nullable<PickingInfo[]>;
    /**
     * Renders the list of sprites on screen.
     */
    render(): void;
}
/**
 * Class used to manage multiple sprites on the same spritesheet
 * @see http://doc.babylonjs.com/babylon101/sprites
 */
export declare class SpriteManager implements ISpriteManager {
    /** defines the manager's name */
    name: string;
    /** Gets the list of sprites */
    sprites: Sprite[];
    /** Gets or sets the rendering group id (0 by default) */
    renderingGroupId: number;
    /** Gets or sets camera layer mask */
    layerMask: number;
    /** Gets or sets a boolean indicating if the manager must consider scene fog when rendering */
    fogEnabled: boolean;
    /** Gets or sets a boolean indicating if the sprites are pickable */
    isPickable: boolean;
    /** Defines the default width of a cell in the spritesheet */
    cellWidth: number;
    /** Defines the default height of a cell in the spritesheet */
    cellHeight: number;
    /** Associative array from JSON sprite data file */
    private _cellData;
    /** Array of sprite names from JSON sprite data file */
    private _spriteMap;
    /** True when packed cell data from JSON file is ready*/
    private _packedAndReady;
    /**
    * An event triggered when the manager is disposed.
    */
    onDisposeObservable: Observable<SpriteManager>;
    private _onDisposeObserver;
    /**
     * Callback called when the manager is disposed
     */
    set onDispose(callback: () => void);
    private _capacity;
    private _fromPacked;
    private _spriteTexture;
    private _epsilon;
    private _scene;
    private _vertexData;
    private _buffer;
    private _vertexBuffers;
    private _indexBuffer;
    private _effectBase;
    private _effectFog;
    /**
     * Gets or sets the spritesheet texture
     */
    get texture(): Texture;
    set texture(value: Texture);
    private _blendMode;
    /**
     * Blend mode use to render the particle, it can be any of
     * the static undefined properties provided in this class.
     * Default value is 2
     */
    get blendMode(): number;
    set blendMode(blendMode: number);
    /** Disables writing to the depth buffer when rendering the sprites.
     *  It can be handy to disable depth writing when using textures without alpha channel
     *  and setting some specific blend modes.
    */
    disableDepthWrite: boolean;
    /**
     * Creates a new sprite manager
     * @param name defines the manager's name
     * @param imgUrl defines the sprite sheet url
     * @param capacity defines the maximum allowed number of sprites
     * @param cellSize defines the size of a sprite cell
     * @param scene defines the hosting scene
     * @param epsilon defines the epsilon value to align texture (0.01 by default)
     * @param samplingMode defines the smapling mode to use with spritesheet
     * @param fromPacked set to false; do not alter
     * @param spriteJSON null otherwise a JSON object defining sprite sheet data; do not alter
     */
    constructor(
    /** defines the manager's name */
    name: string, imgUrl: string, capacity: number, cellSize: any, scene: Scene, epsilon?: number, samplingMode?: number, fromPacked?: boolean, spriteJSON?: any | null);
    private _makePacked;
    private _appendSpriteVertex;
    /**
     * Intersects the sprites with a ray
     * @param ray defines the ray to intersect with
     * @param camera defines the current active camera
     * @param predicate defines a predicate used to select candidate sprites
     * @param fastCheck defines if a fast check only must be done (the first potential sprite is will be used and not the closer)
     * @returns null if no hit or a PickingInfo
     */
    intersects(ray: Ray, camera: Camera, predicate?: (sprite: Sprite) => boolean, fastCheck?: boolean): Nullable<PickingInfo>;
    /**
     * Intersects the sprites with a ray
     * @param ray defines the ray to intersect with
     * @param camera defines the current active camera
     * @param predicate defines a predicate used to select candidate sprites
     * @returns null if no hit or a PickingInfo array
     */
    multiIntersects(ray: Ray, camera: Camera, predicate?: (sprite: Sprite) => boolean): Nullable<PickingInfo[]>;
    /**
     * Render all child sprites
     */
    render(): void;
    /**
     * Release associated resources
     */
    dispose(): void;
}
export {};
