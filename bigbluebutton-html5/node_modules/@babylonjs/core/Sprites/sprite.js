import { Vector3 } from "../Maths/math.vector";
import { Color4 } from '../Maths/math.color';
/**
 * Class used to represent a sprite
 * @see http://doc.babylonjs.com/babylon101/sprites
 */
var Sprite = /** @class */ (function () {
    /**
     * Creates a new Sprite
     * @param name defines the name
     * @param manager defines the manager
     */
    function Sprite(
    /** defines the name */
    name, manager) {
        this.name = name;
        /** Gets or sets the main color */
        this.color = new Color4(1.0, 1.0, 1.0, 1.0);
        /** Gets or sets the width */
        this.width = 1.0;
        /** Gets or sets the height */
        this.height = 1.0;
        /** Gets or sets rotation angle */
        this.angle = 0;
        /** Gets or sets a boolean indicating if UV coordinates should be inverted in U axis */
        this.invertU = 0;
        /** Gets or sets a boolean indicating if UV coordinates should be inverted in B axis */
        this.invertV = 0;
        /** Gets the list of attached animations */
        this.animations = new Array();
        /** Gets or sets a boolean indicating if the sprite can be picked */
        this.isPickable = false;
        this._animationStarted = false;
        this._loopAnimation = false;
        this._fromIndex = 0;
        this._toIndex = 0;
        this._delay = 0;
        this._direction = 1;
        this._time = 0;
        /**
         * Gets or sets a boolean indicating if the sprite is visible (renderable). Default is true
         */
        this.isVisible = true;
        this._manager = manager;
        this._manager.sprites.push(this);
        this.position = Vector3.Zero();
    }
    Object.defineProperty(Sprite.prototype, "size", {
        /**
         * Gets or sets the sprite size
         */
        get: function () {
            return this.width;
        },
        set: function (value) {
            this.width = value;
            this.height = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Starts an animation
     * @param from defines the initial key
     * @param to defines the end key
     * @param loop defines if the animation must loop
     * @param delay defines the start delay (in ms)
     * @param onAnimationEnd defines a callback to call when animation ends
     */
    Sprite.prototype.playAnimation = function (from, to, loop, delay, onAnimationEnd) {
        this._fromIndex = from;
        this._toIndex = to;
        this._loopAnimation = loop;
        this._delay = delay;
        this._animationStarted = true;
        if (from < to) {
            this._direction = 1;
        }
        else {
            this._direction = -1;
            this._toIndex = from;
            this._fromIndex = to;
        }
        this.cellIndex = from;
        this._time = 0;
        this._onAnimationEnd = onAnimationEnd;
    };
    /** Stops current animation (if any) */
    Sprite.prototype.stopAnimation = function () {
        this._animationStarted = false;
    };
    /** @hidden */
    Sprite.prototype._animate = function (deltaTime) {
        if (!this._animationStarted) {
            return;
        }
        this._time += deltaTime;
        if (this._time > this._delay) {
            this._time = this._time % this._delay;
            this.cellIndex += this._direction;
            if (this._direction > 0 && this.cellIndex > this._toIndex || this._direction < 0 && this.cellIndex < this._fromIndex) {
                if (this._loopAnimation) {
                    this.cellIndex = this._direction > 0 ? this._fromIndex : this._toIndex;
                }
                else {
                    this.cellIndex = this._toIndex;
                    this._animationStarted = false;
                    if (this._onAnimationEnd) {
                        this._onAnimationEnd();
                    }
                    if (this.disposeWhenFinishedAnimating) {
                        this.dispose();
                    }
                }
            }
        }
    };
    /** Release associated resources */
    Sprite.prototype.dispose = function () {
        for (var i = 0; i < this._manager.sprites.length; i++) {
            if (this._manager.sprites[i] == this) {
                this._manager.sprites.splice(i, 1);
            }
        }
    };
    return Sprite;
}());
export { Sprite };
//# sourceMappingURL=sprite.js.map