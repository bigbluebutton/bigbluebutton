<?xml version="1.0" encoding="utf-8"?>

<!--

     BigBlueButton open source conferencing system - http://www.bigbluebutton.org/

     Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).

     This program is free software; you can redistribute it and/or modify it under the
     terms of the GNU Lesser General Public License as published by the Free Software
     Foundation; either version 3.0 of the License, or (at your option) any later
     version.

     BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
     WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
     PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.

     You should have received a copy of the GNU Lesser General Public License along
     with BigBlueButton; if not, see <http://www.gnu.org/licenses/>.

-->

<mx:Canvas xmlns="org.bigbluebutton.common.*"
        xmlns:mx="http://www.adobe.com/2006/mxml"
        width="100%"
        height="100%"
        creationComplete="onCreationComplete()"
        implements="org.bigbluebutton.common.IBbbCanvas"
        xmlns:mate="http://mate.asfusion.com/"
        backgroundColor="#C0C0C0">

    <mate:Listener type="{    ViewStreamEvent.STOP    }" method="onStopViewStreamEvent" />
    <mate:Listener type="{    LocaleChangeEvent.LOCALE_CHANGED    }" method="localeChanged" />
    <mate:Listener type="{    BBBEvent.RECONNECT_DISCONNECTED_EVENT    }" method="handleDisconnectedEvent" />

    <mx:Script>
        <![CDATA[
      import com.asfusion.mate.events.Dispatcher;     
      import flexlib.mdi.events.MDIWindowEvent;      
      import mx.events.ResizeEvent;
      import mx.core.UIComponent;      
      import org.bigbluebutton.common.Images;
      import org.bigbluebutton.common.events.LocaleChangeEvent;
      import org.bigbluebutton.core.managers.UserManager;
      import org.bigbluebutton.main.api.JSLog;
      import org.bigbluebutton.main.views.MainCanvas;
      import org.bigbluebutton.modules.screenshare.events.CursorEvent;
      import org.bigbluebutton.modules.screenshare.events.StartedViewingEvent;
      import org.bigbluebutton.modules.screenshare.events.ViewStreamEvent;
      import org.bigbluebutton.modules.screenshare.events.ViewWindowEvent;
      import org.bigbluebutton.modules.screenshare.managers.SmartWindowResizer;
      import org.bigbluebutton.modules.screenshare.model.ScreenshareModel;
      import org.bigbluebutton.modules.screenshare.model.ScreenshareOptions;
      import org.bigbluebutton.util.i18n.ResourceUtil;
      import org.as3commons.logging.api.ILogger;
      import org.as3commons.logging.api.getClassLogger;
      import org.bigbluebutton.core.managers.ReconnectionManager;
      import org.bigbluebutton.main.events.BBBEvent;
      import org.bigbluebutton.modules.screenshare.services.red5.Connection;
      import org.bigbluebutton.core.UsersUtil;
      
      private static const LOG:String = "SC::ScreenshareViewWIndow - ";
      private static const LOGGER:ILogger = getClassLogger(ScreenshareViewWindow);
      
			private var screenHeight:Number = Capabilities.screenResolutionY;
			private var screenWidth:Number = Capabilities.screenResolutionX;
						
			private var images:Images = new Images();
			//[Bindable] public var fitToWidthIcon:Class = images.magnifier;
			//[Bindable] public var fitToActualSizeIcon:Class = images.mag_reset;
					
      private var streamAvailable:Boolean = false;
      
			private var video:Video;
			private var ns:NetStream;
			private var videoWithWarnings:VideoWithWarnings = new VideoWithWarnings();
			private var videoHolder:UIComponent;
			private var streamId:String;
			private var videoHeight:Number = 1;
			private var videoWidth:Number = 1;
			private var loaded:Boolean = false;
			
			private static const VIDEO_WIDTH_PADDING:int = 7;
			private static const VIDEO_HEIGHT_PADDING:int = 65;
			[Bindable] private var _actualSize:Boolean = false;

			private var resizer:SmartWindowResizer = new SmartWindowResizer();

			private var whiteboardCanvas:IBbbCanvas = null;
			private var whiteboardCanvasHolder:Canvas = new Canvas();

			// The following code block is to deal with a bug in FLexLib 
			// with MDI windows not responding well to being maximized
			private var savedWindowWidth:Number;
			private var savedWindowHeight:Number;
			private var savedX:Number;
			private var savedY:Number;
			private var isMaximized:Boolean = false;
			private var connection:Connection;
      
			[Bindable] private var baseIndex:int;
			[Bindable] private var dsOptions:ScreenshareOptions;
									
			private function init():void{
				dsOptions = new ScreenshareOptions();
				baseIndex = dsOptions.baseTabIndex;
			}
									
			private function onCreationComplete():void{
        viewScreenshareStream();
        
				addEventListener(ResizeEvent.RESIZE, onResizeEvent);
				this.addChildAt(videoWithWarnings,0);
				videoHolder = videoWithWarnings.videoHolder;
				videoHolder.percentWidth = 100;
				videoHolder.percentHeight = 100;
				
				resourcesChanged();
				onResizeEvent();
				loaded = true;
               
        var logData:Object = UsersUtil.initLogData();
        logData.tags = ["screenshare"];
        logData.width = videoWidth;
        logData.height = videoHeight;
        logData.streamId = streamId;
        
        LOGGER.info(JSON.stringify(logData));
			}
			
			private function onResizeEvent(e:ResizeEvent = null):void {
				if (!loaded) return;
				LOGGER.debug("ScreenshareViewWindow::onResizeEvent");
				if (actualSize) {
					onResizeCallback(this.width, this.height, videoWidth, videoHeight, Math.max((this.width - videoWidth) / 2, 0), Math.max((this.height - videoHeight) / 2, 0));
				} else {
					resizer.onResize(this.width, this.height, false, video.width, video.height, videoWidth / videoHeight, false, onResizeCallback);
				}
			}
					
			public function startVideo(connection:Connection):void{
        var logData:Object = new Object();
        logData.width = videoWidth;
        logData.height = videoHeight;
        logData.streamId = streamId;
        
        JSLog.debug(LOG + "startVideo", logData);
        
				this.connection = connection;
			}
			            
      private function viewScreenshareStream():void{
        videoWidth = ScreenshareModel.getInstance().width;
        videoHeight = ScreenshareModel.getInstance().height;
        streamId = ScreenshareModel.getInstance().streamId;
        
        var logData:Object = UsersUtil.initLogData();
        logData.tags = ["screenshare"];
        logData.width = videoWidth;
        logData.height = videoHeight;
        logData.streamId = streamId;
        
        LOGGER.info(JSON.stringify(logData));
        
        ns = new NetStream(connection.getConnection());
        ns.addEventListener( NetStatusEvent.NET_STATUS, onNetStatus );
        ns.addEventListener(AsyncErrorEvent.ASYNC_ERROR, onAsyncError);
        ns.client = this;
        ns.bufferTime = 0;
        ns.receiveVideo(true);
        ns.receiveAudio(false);
        
        video = new Video(videoWidth, videoHeight);
        video.width = videoWidth;
        video.height = videoHeight;
        video.smoothing = true;
        video.attachNetStream(ns);
        ns.play(streamId);	
        streamAvailable = true;

        videoWithWarnings.setCallback(setVideo);
      }
      
      public function onMetaData(info:Object):void{
        trace("metadata: width=" + info.width + " height=" + info.height);
        
        var logData:Object = UsersUtil.initLogData();
        logData.tags = ["screenshare"];
        logData.width = info.width;
        logData.height = info.height;
        
        LOGGER.info(JSON.stringify(logData));
      }
      

			public function onParentResized(width:Number, height:Number):void {
				onResizeEvent();
			}

			private function onResizeCallback(externalWidth:int, externalHeight:int, internalWidth:int, internalHeight:int, internalOffsetX:int, internalOffsetY:int):void {
				if(videoHolder != null) {
					/* Reposition video within window */
					videoWithWarnings.x = internalOffsetX;
					videoWithWarnings.y = internalOffsetY;

					videoWithWarnings.width = video.width = internalWidth;
					videoWithWarnings.height = video.height = internalHeight;

					// update the whiteboard canvas holder and overlay with new video dimensions
					updateWhiteboardCanvasHolder();
					updateWhiteboardCanvasOverlay();
				}
			}

			private function setVideo():void {
				LOGGER.debug("Callback called. Adding video, its whiteboard canvas and resizing components...");
				videoHolder.addChild(video);
				addWhiteboardCanvasHolder();
				addWhiteboardCanvasOverlay();
				onResizeEvent();
			}

			private function addWhiteboardCanvasHolder():void{
				if(video != null) {
					this.addChildAt(whiteboardCanvasHolder, 1);
					LOGGER.debug("Whiteboard canvas holder added");
				}
			}

			private function cleanCanvasHolder():void{
				while (this.whiteboardCanvasHolder.rawChildren.numChildren > 0) {
					this.whiteboardCanvasHolder.rawChildren.removeChildAt(0);
				}
			}

			private function updateWhiteboardCanvasHolder():void{
				if (video != null && videoHolder != null) {
					whiteboardCanvasHolder.x = videoWithWarnings.x;
					whiteboardCanvasHolder.y = videoWithWarnings.y;
					whiteboardCanvasHolder.width = videoWithWarnings.width;
					whiteboardCanvasHolder.height = videoWithWarnings.height;
					LOGGER.debug("Whiteboard canvas holder dimensions updated");
				}
			}

			public function addWhiteboardCanvasOverlay():void {
				updateWhiteboardCanvasOverlay();
				if (video != null && whiteboardCanvas != null && videoHolder != null) {
					this.addChild(whiteboardCanvas as Canvas);
					LOGGER.debug("Whiteboard Canvas OVERLAY added.");
				}
				else {
					LOGGER.error("COULD NOT add whiteboard overlay");
				}
			}

			private function updateWhiteboardCanvasOverlay():void{
				if (video != null && whiteboardCanvas != null && videoHolder != null) {
					whiteboardCanvas.moveCanvas(videoWithWarnings.x, videoWithWarnings.y);

					var zoomPercentage:Number = (videoWithWarnings.width / videoWidth)*100;
					if(zoomPercentage > 0)
						whiteboardCanvas.zoomCanvas(videoWithWarnings.width, videoWithWarnings.height, zoomPercentage);

					LOGGER.debug("Whiteboard canvas overlay dimensions updated");
				}
			}
/*
      protected function updateButtonsPosition():void {
        if (this.width < bottomBar.width) {
          bottomBar.visible = false;
        }
        
        if (bottomBar.visible == false) {
          bottomBar.y = bottomBar.x = 0;
        } else {
          bottomBar.y = (this.height - bottomBar.height) / 2;
          bottomBar.x = (this.width - bottomBar.width) / 2;
        }
      }
*/
			public function stopViewing():void {
				ns.close();
				closeWindow();				
			}
			
			private function onStopViewStreamEvent(event:ViewStreamEvent):void {
				stopViewing();
			}
						
			private function onAsyncError(e:AsyncErrorEvent):void{
        LOGGER.debug("asyncerror " + e.toString());
        var logData:Object = UsersUtil.initLogData();
        logData.tags = ["screenshare"];
        logData.message = "asyncerror";
        LOGGER.info(JSON.stringify(logData));
			}
			
			private function onNetStatus(e:NetStatusEvent):void{
        var logData:Object = UsersUtil.initLogData();
        logData.tags = ["screenshare"];
        logData.stream = streamId;
        
				switch(e.info.code){
  				case "NetStream.Play.Start":
            logData.message = "NetStream.Publish.Start for broadcast stream " + streamId;
            LOGGER.info(JSON.stringify(logData));
  					break;
  				case "NetStream.Play.UnpublishNotify":
            logData.message = "NetStream.Play.UnpublishNotify for broadcast stream " + streamId;
            LOGGER.info(JSON.stringify(logData));
  					stopViewing();
  					break;
				}
			}
			
			private function toggleActualSize():void {
				actualSize = !actualSize;
			}
			
			public function set actualSize(value:Boolean):void {
				_actualSize = value;
				onResizeEvent();
			}
			
			public function get actualSize():Boolean {
				return _actualSize;
			}
			
			private function closeWindow():void {
				dispatchEvent(new ViewWindowEvent(ViewWindowEvent.CLOSE));
			}
			
			override protected function resourcesChanged():void{
				super.resourcesChanged();
			}
			
			private function localeChanged(e:Event):void{
				resourcesChanged();
			}

			/** Inherited from IBbbCanvas*/
			public function addRawChild(child:DisplayObject):void {
				whiteboardCanvasHolder.rawChildren.addChild(child);
			}

			public function removeRawChild(child:DisplayObject):void {
				this.whiteboardCanvasHolder.rawChildren.removeChild(child);
			}

			public function doesContain(child:DisplayObject):Boolean {
				return this.whiteboardCanvasHolder.rawChildren.contains(child);
			}

			public function acceptOverlayCanvas(overlay:IBbbCanvas):void {
				LOGGER.debug("ScreenshareViewWindow: acceptOverlayCanvas");
				cleanCanvasHolder();
				whiteboardCanvas = overlay;
			}

			private function handleWhiteboardCanvasClick(e:MouseEvent):void {
				LOGGER.debug("ScreenshareViewWindow: handleWhiteboardCanvasClick");
			}

			public function moveCanvas(x:Number, y:Number):void {
				LOGGER.debug("ScreenshareViewWindow: moveCanvas");
			}

			public function zoomCanvas(width:Number, height:Number, zoom:Number):void {
				LOGGER.debug("ScreenshareViewWindow: zoomCanvas");
			}

			public function showCanvas(show:Boolean):void {
				LOGGER.debug("ScreenshareViewWindow: showCanvas");
			}
            
       public function handleDisconnectedEvent(event:BBBEvent):void {
          if (event.payload.type == ReconnectionManager.DESKSHARE_CONNECTION) {
            closeWindow();  
          }
      }
			
		]]>
    </mx:Script>

</mx:Canvas>
